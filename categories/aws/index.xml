<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aws on Shogo&#39;s Blog</title>
    <link>https://shogo82148.github.io/categories/aws/</link>
    <description>Recent content in Aws on Shogo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 12 Feb 2019 12:46:00 +0900</lastBuildDate>
    
	<atom:link href="https://shogo82148.github.io/categories/aws/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>外部サービスでもIAM Roleで認証がしたい！</title>
      <link>https://shogo82148.github.io/blog/2019/02/12/ssm-sign-proxy/</link>
      <pubDate>Tue, 12 Feb 2019 12:46:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/02/12/ssm-sign-proxy/</guid>
      <description>背景 外部サービスのAPIやWebHookを叩くときには、多くの場合 API トークンが必要になります。 もちろん API トークン無しでも叩けるサービスはありますが、GitHub APIのようにトークン無しではリクエスト数が大きく制限されたり、 一部機能が制限されてしまう場合があります。
外部連携サービスが増えてくると、このAPIトークンをどうやって管理するかが問題になってきます。 プロダクションに投入されているサービスは普通複数のサーバーから構成されており、各サーバーにAPIトークンを配布するのはちょっと面倒です。 この問題に対して、以下のようなことが行われて来ました。
 プライベートネットワークからのアクセスに限定した Proxy を立てる APIトークンの管理は Proxy に任せる  DevOpsが注目され、Slackの利用が広まったころに、このような目的で書かれたProxyサーバーがよく登場しました。
 社内IRCをSlackに移行した時にやったこと  この記事で紹介されている kayac/nopaste  Slackboard〜Slackプロキシサーバ in Go〜 Slackプロキシサーバ〜slackboard〜を利用したメルカリのSlack活用法 App::Ikachan - 様々なサーバのバッチ処理の結果等を IRC のチャンネルに通知するサーバ  (IRCはHTTPで動いているわけではないし、大本の目的もコネクション維持だけど、認証も代理でやってくれる)   しかし、これらのサーバーはSlack専用だったりIRC専用だったりします。 Slackだけじゃなくって、GitHubにコメント登録したり、Mackerelのグラフアノテーションを投稿したり、 他のサービスとも連携したい！
最近はどんなAPIもHTTPで提供されるようになったので(IRCは・・・ウッ・・・そんなのなかった)、もっと汎用的に書けるのではとやってみました。
実装 APIトークンの保管場所として AWS Systems Manager Parameter Store を採用しました。 Parameter Store からAPIトークンを取り出す部分と、実際にAPIを叩く部分は AWS Lambda を使用します。 各サーバーに Forward Proxy デーモンを立てておき、APIを使いたいアプリケーションはこのProxyを経由するようにします。
この図ではEC2インスタンスを例にしていますが、IAM Roleを付与できるAWSのサービスであれば何でも (ECS, Lambda, CodeBuild, etc.) APIにアクセスすることができます。</description>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt の証明書取得を AWS Lambda でやってみた</title>
      <link>https://shogo82148.github.io/blog/2019/02/07/acme-cert-updater/</link>
      <pubDate>Thu, 07 Feb 2019 19:22:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/02/07/acme-cert-updater/</guid>
      <description>背景 ここ数年で暗号化されていないHTTPは減り、常時TLSが当たり前になってきました。 公開用のページはもちろん、開発段階のページでもTLSは必須です。 普段はAWS上で開発をしているので、AWS Certificate Managerを利用することが多いのですが、 ちょっとしたお遊びにELBやCloudFormationを使うのはオーバーキルです。 そこで EC2 にもインストールできて、無料で使える Let&amp;rsquo;s Encrypt を使って証明書を発行することを考えました。
Let&amp;rsquo;s Encrypt で発行できる証明書は期間が90日と短く、60日ごとの自動更新が推奨されています。 証明局とAPIとAPIクライアントの実装例は提供するから、あとの自動化部分は自前で頑張ってねという感じなので、自動化部分を頑張らないといけません。 今回は実行環境として AWS Labda、ACME(Automatic Certificate Management Environment)クライアントとして certbot、 認証方法に dns-01、認証に必要なDNSレコードの書き換えに AWS Route 53 を使用する、という構成にしました。
ソースコードをGitHubに挙げたのと、前回と同様に AWS Serverless Application Repository へ上げたので、ぜひご利用ください。
 shogo82148/acme-cert-updater shogo82148/acme-cert-updater on AWS Serverless Application Repository  関連手法 Amazon Linux 2 に certbot をインストールして使う Amazon Linux 2 のドキュメントに TLS 対応のウェブサーバーを立てる例が載っています。 Let&amp;rsquo;s Encrypt で証明書を取る方法も紹介されているので、まずはこれを利用することを考えました。
 付録: Amazon Linux 2 での Let&amp;rsquo;s Encrypt と Certbot の使用 - チュートリアル: Amazon Linux 2 で SSL/TLS を使用できるように Apache ウェブサーバーを設定する  この方法は以下の理由から見送りました。</description>
    </item>
    
    <item>
      <title>サーバーレスでCloudWatchメトリクスをMackerelに転送する</title>
      <link>https://shogo82148.github.io/blog/2019/01/31/mackerel-cloudwatch-transfer/</link>
      <pubDate>Thu, 31 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/31/mackerel-cloudwatch-transfer/</guid>
      <description>背景 サーバーの監視にMackerelを使っているのですが、 用意されているメトリクスでは足りずカスタムメトリクスを追加することが多々あります。 Mackerel Agent Pluginsを利用すればメトリクスを増やすこと自体は簡単なのですが、 Agentを設置するインスタンスが増えるので、サーバー保守の手間が増えてしまいます。
僕のユースケースでは監視対象はたいていAWSのマネージド・サービスなので、 AWS CloudWatch に投稿されたメトリクスが Mackerel で見れれば十分なことが多いです。
そこで、以下の記事を参考に AWS Lambda と CloudWatch Events を組み合わせて、Mackerelへメトリクスを転送するスクリプトを書いてみました。
 Amazon LambdaでCloudWatchのメトリクスをMackerelに監視させる  デプロイしてみる 今回はなんと！皆さんの AWSマネジメントコンソールから、クリックひとつでデプロイできるようにしてみました！
 mackerel-cloudwatch-forwarder  ・・・と、その前に下準備が必要です。 MackerelのダッシュボードからAPIキーをコピーしてきて、 AWS Systems Manager パラメータストアに Secure String として登録しておきます。 スクショでは Mackerel のものだと分かりやすいよう /development/api.mackerelio.com/headers/X-Api-Key という名前をつけました。 この名前を後で使うので覚えておきましょう。
次に AWS Lambda の画面を開き、「関数の作成」をクリックします。
「一から作る」「設計図」「AWS Serverless Application Repository」の3つの選択肢が表れるので、 「AWS Serverless Application Repository」 を選択します。 検索BOXに「Mackerel」と入れると、mackerel-cloudwatch-forwarderが 出てくるので、それを選択します。 なお、この選択肢はデフォルトでは表示ないので、「Show apps that create custom IAM roles or resource policies」にチェックを入れましょう。</description>
    </item>
    
    <item>
      <title>CloudFormationでECSタスクのドレインをやる</title>
      <link>https://shogo82148.github.io/blog/2019/01/30/drain-ecs-task-with-cloudformation/</link>
      <pubDate>Wed, 30 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/30/drain-ecs-task-with-cloudformation/</guid>
      <description>やってみたはいいものの、1年後には仕組みを忘れていそうなのでメモ。
背景 昔はサービス毎にポコポコEC2インスタンスを立てていたのですが、 幸か不幸かインスタンスのリソースが余り気味でした。 そこで、最近流行りのコンテナ技術に乗っかって Amazon ECS (Amazon Elastic Container Service) を使って、 ひとつのインスタンスに複数のサービスを載せようと目論みました。
ちょうどその頃、Spot Fleetというものを使うと、 スポットインスタンスをお手軽に借りられるという話を聞いたので、 Spot Fleet + ECS で格安クラスターを作ってみよう！と手を出してみました。
(・・・もちろん、Fargateが東京リージョンで使えるようになったことは知っているけれど、スポットインスタンスの価格に負けてしまった・・・)
 AWS Fargate 東京リージョン サービス開始のお知らせ AWS Fargate で最大 50% の値下げを発表  ECS最適化インスタンスの更新問題 クラスターを作るだけなら、そう難しくはなく、インスタンス起動時にAmazon ECS-Optimized Amazon Linux AMIを使うだけです。 問題はこのイメージは定期的に更新される、ということです。 更新情報を流しているSNSトピックがあるので、これをサブスクライブしておくと、時たま更新通知が来ます。
 Amazon ECS-Optimized Amazon Linux AMI の更新の通知のサブスクライブ  この更新には機能追加はもちろん、セキュリティーフィックスも含まれているので、 なるべく早く新しいイメージに移行する必要があります。 移行は大まかに以下の手順で進めます。
 新しいAMIイメージに更新した Spot Fleet を作成する 古いインスタンスに残っているタスクをいい感じに終了する(ドレイン)  突然殺すとユーザーにエラーが見えてしまうので、受付中のリクエストを捌き切ってから終了しないといけない ドレインが始まるとECSがタスク数を調整するために、新しいインスタンスにタスクをお引越ししてくれる  ドレインが終了したら、古いインスタンスをシャットダウンする  ここで問題になってくるのが「古いインスタンスに残っているタスクをいい感じに終了する(ドレイン)」の部分。 コンソールからポチポチするのも面倒なので、自動化したいところ。 しかし、いろいろとドキュメントをあさってみたのですが、「APIかawscliを叩く」「SNSとAWS Lambda をうまいこと組み合わせて頑張る」みたいな方法しか見当たらない・・・ しかもAWSの公式ブログ</description>
    </item>
    
    <item>
      <title>IAM認証でAWS RDSへ接続するMySQLドライバを作った</title>
      <link>https://shogo82148.github.io/blog/2019/01/13/rdsmysql/</link>
      <pubDate>Sun, 13 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/13/rdsmysql/</guid>
      <description>AWS RDS には IAM 認証を使って接続する機能があります。
 MySQL および PostgreSQL に対する IAM データベース認証 IAM 認証情報を使用して Amazon RDS への接続をユーザーに許可する方法を教えてください。  これを使って接続するGo言語のSQLドライバを書いてみました。
 https://github.com/shogo82148/rdsmysql  使い方 IAMデータベース認証はデフォルトで無効になっているので、まずはこれを有効化します。 次に AWSAuthenticationPlugin を認証方式に指定して、新しいユーザーを作りましょう。
 IAM データベース認証の有効化と無効化 データベースアカウントの作成  CREATE USER jane_doe IDENTIFIED WITH AWSAuthenticationPlugin AS &amp;#39;RDS&amp;#39;; 他のSQLドライバはimportするだけで使えるのですが、 rdsmysqlではAWSへの権限情報を設定しなければならない都合上、 sql.Register を自前で呼び出す必要があります。 とは言っても、AWS SDKがいい感じに設定ファイルとか環境変数とか読んでくれるので、 rdsmysql.Driver にAWSセッションを渡すだけです。
c := aws.NewConfig().WithRegion(&amp;#34;ap-northeast-1&amp;#34;) s := session.Must(session.NewSession(c)) d := &amp;amp;Driver{ Session: s, } sql.Register(&amp;#34;rdsmysql&amp;#34;, d) db, err := sql.Open(&amp;#34;rdsmysql&amp;#34;, &amp;#34;jane_doe:@tcp(db-foobar.ap-northeast-1.rds.amazonaws.com:3306)/&amp;#34;) if err !</description>
    </item>
    
    <item>
      <title>AWS LambdaでCGIを蘇らせる</title>
      <link>https://shogo82148.github.io/blog/2018/12/16/run-cgi-in-aws-lambda/</link>
      <pubDate>Sun, 16 Dec 2018 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/12/16/run-cgi-in-aws-lambda/</guid>
      <description>この記事は Perl Advent Calendar 2018の15日目の記事です。 (キリの良いところまでできたのと、記事が書かれていなかったので代打投稿)
Custom Runtime のリリースにより、AWS Lambda 上でPerlが動くようになりました。
 PerlをAWS Lambdaで動かす  次は AWS Lambda + CGI でサーバーレスだな&amp;hellip;
&amp;mdash; Ichinose Shogo (@shogo82148) 2018年12月8日 
ということで、やっていきましょう。
できたもの 動かすのはもちろん、 CGIアクセスカウンター 。 なんと嬉しいことに、最近になって WwwCounter の新バージョン(Ver3.16)がリリースされ、 Perl 5.26 に対応しました！
 2018-11-11 perl 5.26に対応。(Ver3.16)
 更新履歴によれば一つ前の Ver 3.15 のリリースは2003-03-23なので、なんと15年ぶりのアップデートです。 杜甫々さんの AWS Lambda で動かしてくれ！！ という声が聞こえてきそうですね・・・！！！
動いたーーーー！！！！
実装はこちら
 AWS::Lambda  ちなみにWwwCounterのアップデートはPerl 5.26で「@INCからカレントディレクトリが削除」された件への対応だと思います(コミットログがないので予想)。
 第46回　Perl 5.26で変わること（1） - Perl Hackers Hub  実装説明 「そもそもCGIってなんだ？」っていう人も多くなってきたと思うので、そこらへんの歴史の話にも軽く触れます。 この辺の歴史をリアルに体験したわけではないので、誤り等あればご指摘ください。</description>
    </item>
    
    <item>
      <title>PerlをAWS Lambdaで動かす</title>
      <link>https://shogo82148.github.io/blog/2018/11/30/perl-in-lambda/</link>
      <pubDate>Fri, 30 Nov 2018 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/11/30/perl-in-lambda/</guid>
      <description>AWS Lambda で Custom Runtime が発表されました！
 新機能 – AWS Lambda :あらゆるプログラム言語への対応と一般的なコンポーネントの共有 New for AWS Lambda – Use Any Programming Language and Share Common Components AWS Lambda Now Supports Custom Runtimes, and Enables Sharing Common Code Between Functions  Custom Runtime により好きなプログラミング言語でLambda関数を書くことができ、 いくつかの言語についてはAWSおよびパートナーから bootstrap が提供されます。
提供される言語にCOBOLが入って話題になっていますが、 当然ながら(？)Perlはありません。
Custom Runtimeは shell script でも書ける簡単なものなので、Perlでも書いてみました。
Perl in AWS Lambda 以下のスクリプトを bootstrap という名前で保存します。
#!/usr/bin/env perl use utf8; use warnings; use strict; use lib &amp;#34;$ENV{LAMBDA_TASK_ROOT}/local/lib/perl5&amp;#34;; use Furl; use JSON; my $furl = Furl-&amp;gt;new; my ($handler, $function) = split /\.</description>
    </item>
    
  </channel>
</rss>