<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>typescript on Shogo&#39;s Blog</title>
    <link>https://shogo82148.github.io/categories/typescript/</link>
    <description>Recent content in typescript on Shogo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 13 Aug 2024 00:33:00 +0900</lastBuildDate>
    <atom:link href="https://shogo82148.github.io/categories/typescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Structured Field Values のパーサーを書いた</title>
      <link>https://shogo82148.github.io/blog/2024/08/13/structured-field-values/</link>
      <pubDate>Tue, 13 Aug 2024 00:33:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/08/13/structured-field-values/</guid>
      <description>GoとTypeScriptで Structured Field Values のパーサーを書きました。
github.com/shogo82148/go-sfv: Go版実装 github.com/shogo82148/sfvjs: TypeScript版実装 背景 そもそも Structured Field Values (SFV) とはなにか、なぜ登場したのか、という背景はこちらの記事をどうぞ。
Structured Field Values による Header Field の構造化 HTTP APIを開発していると、アプリケーション独自のHTTPフィールドを定義することがあります。 そういうときに、標準にしたがっておいたほうが何かと楽だろう、ということでSFVを採用しました。
しかしいい感じのSFVのパーサーがなかなか見つからなかったので、自作することにした、というわけです。
Go実装 Go のモジュールとして公開されているので、いつものように go get してきましょう。
go get github.com/shogo82148/go-sfv GoでSFVをパースする DecodeItem、DecodeList、 DecodeDictionary を使います。
net/http.Header.Valuesの戻り値を直接受け取れるよう、 各関数は []string を受け取るようにしました。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/shogo82148/go-sfv&amp;#34; ) func main() { h := make(http.Header) h.Add(&amp;#34;Example&amp;#34;, `2; foourl=&amp;#34;https://foo.example.com/&amp;#34;`) item, err := sfv.DecodeItem(h.Values(&amp;#34;Example&amp;#34;)) if err != nil { panic(err) } fmt.</description>
    </item>
    <item>
      <title>denoland/dntがerror TS2304: Cannot find name &#39;ErrorOptions&#39;で失敗する</title>
      <link>https://shogo82148.github.io/blog/2024/08/13/denoland-dnt-cannot-find-error-options/</link>
      <pubDate>Tue, 13 Aug 2024 00:30:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/08/13/denoland-dnt-cannot-find-error-options/</guid>
      <description>先日npmへのパッケージ公開にチャレンジしてみました。
npmとjsrにパッケージを公開してみた (認証バッジ付) しかし2か月も経たないうちにビルドに失敗するようになってしまいました・・・。 何もしていないのに壊れた。
% deno run -A scripts/build_npm.ts [dnt] Transforming... [dnt] Running npm install... added 7 packages, and audited 8 packages in 4s found 0 vulnerabilities [dnt] Building project... [dnt] Type checking ESM... src/deps/jsr.io/@std/assert/1.0.2/assertion_error.ts:27:42 - error TS2304: Cannot find name &amp;#39;ErrorOptions&amp;#39;. 27 constructor(message: string, options?: ErrorOptions) { ~~~~~~~~~~~~ src/deps/jsr.io/@std/assert/1.0.2/assertion_error.ts:27:42 - error TS4063: Parameter &amp;#39;options&amp;#39; of constructor from exported class has or is using private name &amp;#39;ErrorOptions&amp;#39;. 27 constructor(message: string, options?</description>
    </item>
    <item>
      <title>npmとjsrにパッケージを公開してみた (認証バッジ付)</title>
      <link>https://shogo82148.github.io/blog/2024/06/23/2024-06-23-publish-to-npm-and-jsr/</link>
      <pubDate>Sun, 23 Jun 2024 16:12:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/06/23/2024-06-23-publish-to-npm-and-jsr/</guid>
      <description>先日、同時実行数を制限しながら並行実行する関数を書きました。
TypeScriptで同時実行数を制限しながら並行実行する 便利関数を作ったら他のプロジェクトから参照したいですよね。 そこでパッケージレジストリに登録してみました。
正直コピペで実装で十分なのでは？という分量ですが、パッケージ公開の練習です。
ソースコードを準備する まずは公開するソースコードを準備していきましょう。 ソースコードはGitHubで公開しました。
shogo82148/limit-concurrency - GitHub Denoの開発環境を整える TypeScriptの開発環境を整えたいのですが、Node+TypeScriptの組み合わせはプロジェクトの立ち上げは意外と面倒です。 そこで今回は Deno を使ってみることにしました。 DenoはTypeScriptの実行ランタイムとして開発されており、特別な設定なしでTypeScriptを実行できます。 Brewでインストールしました。
brew install deno 僕は最近エディターには VS Code を使っているので、Deno用の拡張機能をインストールしました。
denoland/vscode_deno インストールしただけでは有効化されません。 ワークスペースの設定ファイル .vscode/settings.json を編集して、明示的に有効化します。
{ &amp;#34;deno.enable&amp;#34;: true, &amp;#34;deno.lint&amp;#34;: true, &amp;#34;editor.formatOnSave&amp;#34;: true, &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;denoland.vscode-deno&amp;#34;, &amp;#34;[typescript]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;denoland.vscode-deno&amp;#34; }, } 開発環境が整ったらパッケージ本体のソースコードを書いていきます。
GitHub Actionsでテストを実行する パッケージとして公開するのであれば、テストを書いて、CIを回しておきたいですよね。 Deno公式がセットアップするためのアクションを公開しているので、これを利用します。
denoland/setup-deno あとは deno test コマンドを実行するだけです。
on: push: pull_request: jobs: deno: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: denoland/setup-deno@v1 with: deno-version: v1.</description>
    </item>
    <item>
      <title>TypeScriptで同時実行数を制限しながら並行実行する</title>
      <link>https://shogo82148.github.io/blog/2024/06/22/2024-06-22-limit-concurrency-in-typescript/</link>
      <pubDate>Sat, 22 Jun 2024 11:01:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/06/22/2024-06-22-limit-concurrency-in-typescript/</guid>
      <description>タスクがたくさんあって並行実行することを考えます。 何も考えずにすべてのタスクを並行実行すると負荷が高すぎるので、 同時実行数を制限したいことがありました。
ググってみるといくつか実装例が見つかりますが、その多くは配列を受け入れるものです。 AsyncIterator を受け入れるバージョンが欲しいなと思い、 他の人の記事を参考に実装してみました。
IteratorまたはIterableを受け入れる版 いきなりAsyncIterator版を実装するのは大変なので、Iterator版で練習してみました。 以下の関数 limitConcurrency は、タスクのIteratorまたはIterableを受け取って、並行実行します。
async function limitConcurrency&amp;lt;T&amp;gt;( iter: Iterator&amp;lt;() =&amp;gt; Promise&amp;lt;T&amp;gt;&amp;gt; | Iterable&amp;lt;() =&amp;gt; Promise&amp;lt;T&amp;gt;&amp;gt;, limit: number ) { const iterator = Symbol.iterator in iter ? iter[Symbol.iterator]() : iter; async function runNext(): Promise&amp;lt;void&amp;gt; { for (;;) { const { value: task, done } = iterator.next(); if (done) { return; } await task(); } } try { const initialTasks: Promise&amp;lt;void&amp;gt;[] = []; for (let i = 0; i &amp;lt; limit; i++) { initialTasks.</description>
    </item>
  </channel>
</rss>
