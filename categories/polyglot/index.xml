<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>polyglot on Shogo&#39;s Blog</title>
    <link>https://shogo82148.github.io/categories/polyglot/</link>
    <description>Recent content in polyglot on Shogo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 30 Dec 2021 21:12:00 +0900</lastBuildDate><atom:link href="https://shogo82148.github.io/categories/polyglot/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bash と PowerShell の Polyglot を作る</title>
      <link>https://shogo82148.github.io/blog/2021/12/30/polyglot-of-bash-and-powershell/</link>
      <pubDate>Thu, 30 Dec 2021 21:12:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2021/12/30/polyglot-of-bash-and-powershell/</guid>
      <description>以前 Bash と PowerShell の Polyglot を書いたことがあったんですが、 「そういえば、どこにもメモってないな〜」と思い出したので、記録として残しておきます。
背景・目的 GitHub Actions には run というステップがあります。 任意のシェルスクリプトをかける便利なステップなんですが、 マトリックスビルドでマルチプラットフォームなワークフローを書いていると罠があります。
例えば以下のワークフローは 「Hello GitHub Actions!」とログに表示するだけの簡単なものです。
on:push:pull_request:jobs:job:strategy:fail-fast:falsematrix:os:[ubuntu-latest, windows-latest, macos-latest]runs-on:${{ matrix.os }}steps:- name:Ubuntu, macOS, Windows で実行する# shell: bash # Ubuntu, macOS でのデフォルト# shell: pwsh # Windows でのデフォルトrun:|echo &amp;#34;Hello GitHub Actions!&amp;#34;コメントに書いたとおり Ubuntu, macOS では bash、Windows では PowerShell Core と デフォルトのシェルが環境によって異なります。 bash にも PowerShell にも echo コマンドが存在するので、この例はなぜか動いてしまうのですが、 もっと複雑な処理ではこうも行きません。
これを一般化すると なるほど！ Bash と PowerShell の Polyglot だ！ と気がついたので、やってみたというお話です。
最終案 気の短い人のための最終案。 試行錯誤の末たどり着いたのが以下のスクリプトです。</description>
    </item>
    
    <item>
      <title>改: PerlとGolangで実行できるPolyglot書いてみた</title>
      <link>https://shogo82148.github.io/blog/2021/02/23/improve-go-and-perl-polyglot/</link>
      <pubDate>Tue, 23 Feb 2021 18:00:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2021/02/23/improve-go-and-perl-polyglot/</guid>
      <description>仕事をしているときにふとひらめいた。
 Perl と Golang で実行できる Polyglot 書いてみた  文字列置換の s/// に使う記号はダブルクオーテーションでも行ける！
package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { s.Println(&amp;#34;Hello macotasu&amp;#34;) } package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { s.Println(&amp;#34;Hello macotasu&amp;#34;) } Go で dot import をしなければならない、という制限がなくなるので、自由度が上がりました。
package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) import &amp;#34;math&amp;#34; func main() { s.</description>
    </item>
    
    <item>
      <title>GoのバイナリをRubyスクリプトとしても扱う</title>
      <link>https://shogo82148.github.io/blog/2019/07/02/go-build-polyglot/</link>
      <pubDate>Tue, 02 Jul 2019 21:55:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/07/02/go-build-polyglot/</guid>
      <description>$ ruby --help Usage: ruby [switches] [--] [programfile] [arguments] (中略) -x[directory] strip off text before #!ruby line and perhaps cd to directory (後略) なんか Ruby にも -x あるらしいので。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; ) const script = ` #!ruby puts &amp;#34;Hello Ruby World!!\n&amp;#34; __END__ ` func init() { runtime.KeepAlive([]byte(script)) } func main() { fmt.Println(&amp;#34;This is Go world!!&amp;#34;) } はい。
$ go build -o main main.go $ ./main This is Go world!</description>
    </item>
    
    <item>
      <title>Rust vs Go の終戦へ向けてPolyglotを作ってみた</title>
      <link>https://shogo82148.github.io/blog/2017/02/25/rust-and-go-ploygolot/</link>
      <pubDate>Sat, 25 Feb 2017 16:58:27 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/02/25/rust-and-go-ploygolot/</guid>
      <description>「Golang Rust」とググると、関連項目は「Rust vs Go」のように GolangとRustが対立しているような項目ばかりです。 まあまあ、もっと仲良くやろうじゃないですか、ということで、 どうしたら仲良くなれるかを考えました。 Polyglotにして同じソースコードの中に閉じ込めてやれば、 そのうち仲良くなるのではないかと考え、 RustとGoのPloyglotを作ってみました。
結果 /*/*/ package main import &amp;#34;fmt&amp;#34; func main() { fmt.Print(&amp;#34;Hello Go!!&amp;#34;) _ = `*/*/fn main(){println!(&amp;#34;Hello Rust!!&amp;#34;);//` }/*/*/ package main import &amp;#34;fmt&amp;#34; func main() { fmt.Print(&amp;#34;Hello Go!!&amp;#34;) _ = `*/*/ fn main() { println!(&amp;#34;Hello Rust!!&amp;#34;); //` } 仕組み 一番のポイントは最初の行の /*/*/ です。 RustもGoも/* */形式の複数行コメントに対応していますが、 Rustはネストに対応しており、Goはネストはできないという違いがあります。 この違いにより、Rustは/*/*/を/* /* /のように「二重にネストしたコメントの開始部分」として扱いますが、 Goは/* / */のように「/をコメントアウトしたもの」と見なします。 これにより2行目package main以降はGoには普通のコードに見えますが、 Rustからは単なるコメントとして認識されます。
次はGoからRustへの切り替えです。 Goではバッククオートで複数行文字列を定義できるので、その中にRustのコードを書きます。 この中ではバッククオートさえ使わなければ自由にRustのコードを書くことが出来るので、 あとはGoのコードだけ上手くコメントアウトされるよう調整すれば完成です。
せっかくなのでリンクしてみた GoからRustのコードを呼び出すサンプルコードを見つけたので、 せっかくなのでリンクしてみました。
 medimatrix/rust-plus-golang  main.</description>
    </item>
    
    <item>
      <title>PerlでもGoでも実行できるQuine書いた</title>
      <link>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/</link>
      <pubDate>Wed, 06 Apr 2016 10:07:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/</guid>
      <description>昨日のPolyglotを元にPerlでもGoでも実行できるQuine書いた。
package main;import(&amp;quot;fmt&amp;quot;);var(q=`printf&#39;package main;import(&amp;quot;fmt&amp;quot;);var(q%c%c%s%c/*%c);sub import{}sub var{$_%cshift%c~s!%c(.*)%c/\*!$1!gr;eval}%c__END__%c&#39;,61,96,$_,96,61,61,61,96,96,10,10;print&amp;lt;DATA&amp;gt;`/*=);sub import{}sub var{$_=shift=~s!`(.*)`/\*!$1!gr;eval} __END__ */);func main(){s:=`package main;import(&amp;quot;fmt&amp;quot;);var(q=%c%s%c/*=);sub import{}sub var{$_=shift=~s!%c(.*)%c/\*!$1!gr;eval} __END__ */);func main(){s:=%c%s%c;fmt.Printf(s,96,q,96,96,96,96,s,96)} `;fmt.Printf(s,96,q,96,96,96,96,s,96)} Perlで実行してもGoで実行しても自分自身を出力します。</description>
    </item>
    
    <item>
      <title>PerlとGolangで実行できるPolyglot書いてみた</title>
      <link>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/</link>
      <pubDate>Tue, 05 Apr 2016 12:27:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/</guid>
      <description>Rubyの会社をPerlの会社に変えてしまおう計画。 Golangのフリをして忍び込ませれば行けるのではという話になったので、 GoでもPerlでも実行できるコードを書いてみた。
出来上がったのがこちら。
package main; import (&amp;#34;fmt&amp;#34;); var (s=0/*==); sub import {} sub var { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { fmt.Println(&amp;#34;Hello macotasu&amp;#34;) } 一番のポイントはvar (s=0/*==);の行ですね。 Perlで解釈すると正規表現置換s///として解釈され、/*が無視されます。 Goで解釈すると変数sへの代入として解釈され、/*がコメントとして扱われます。
あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。
 package main はGoでもPerlでも似たような意味で解釈されるのでそのまま Goの import, var はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする 省略可能なセミコロンをちゃんと書く  GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、 import だけGoでもPerlでも解釈されてしまうというという制限があります。 import するパッケージが一個だけなら問題ないんですが、 複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。 (Perlでは文字列結合として解釈される。Goではvarのあとにimportかけないっぽいので、ここに押し込むしかない。)
package main; import ( &amp;#34;fmt&amp;#34; . &amp;#34;math&amp;#34; ); var (s=0/*==); sub import {} sub var { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { fmt.</description>
    </item>
    
  </channel>
</rss>
