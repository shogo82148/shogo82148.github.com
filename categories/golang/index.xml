<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Shogo&#39;s Blog</title>
    <link>https://shogo82148.github.io/categories/golang/</link>
    <description>Recent content in golang on Shogo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 04 Aug 2023 23:22:00 +0900</lastBuildDate><atom:link href="https://shogo82148.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Contextに埋め込んだ値をログに出力してくれるログハンドラーを書いた</title>
      <link>https://shogo82148.github.io/blog/2023/08/04/2023-08-04-context-for-slog/</link>
      <pubDate>Fri, 04 Aug 2023 23:22:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2023/08/04/2023-08-04-context-for-slog/</guid>
      <description>Go言語にいよいよ構造化ログ用パッケージlog/slogが追加される、と各所で話題になってますね。
 Go 1.21連載始まります＆slogをどう使うべきか   しかし、どんなにドキュメントをみても、ロガーを出し入れする関数はありません。そういう使い方を議論する issue もありましたが　現状はハンドラーにそのまま渡しているだけです。 よくよく考えればトレーシングIDなどは、コンテキストに格納されているはずで、ロガーにも属性として持つと2重持ちになってしまいます。出力時だけハンドラ自身がそれを取り出して書き出せば良い、という思想に思えます。 そのためにはハンドラーを自分でつくることになります。 (強調は筆者によるもの)
 たしかにトレーシングIDを2重に持つのは効率が悪いかもしれない。 そうかもしれないけど・・・でもやっぱり毎回ハンドラーを書くのは面倒・・・もうちょっと汎用的にはならないものか・・・ と結局書いちゃいました。
 shogo82148/ctxslog  使い方 slogではログ関数がcontext.Contextを受け取るようになりました。 ここで渡したcontext.Contextはキャンセル処理には使用されず、値の受け渡しのみに使用されます。
このことを利用してctxslog.WithAttrsでコンテキストに値を埋め込むことができます。 ここで埋め込んだ値をctxslog.Newで作成したハンドラーが受け取って、ログに表示します。
import ( &amp;#34;context&amp;#34; &amp;#34;log/slog&amp;#34; ) func main() { // ログに出力するためにロガーをカスタマイズ  handler := slog.NewTextHandler(os.Stderr, nil) slog.SetDefault(slog.New(ctxslog.New(handler))) ctx := context.Background() // このコンテキスト内のログすべてに my_context=foo-bar を埋め込む  ctx = ctxslog.WithAttrs(ctx, slog.String(&amp;#34;my_context&amp;#34;, &amp;#34;foo-bar&amp;#34;)) slog.InfoContext(ctx, &amp;#34;hello&amp;#34;, &amp;#34;count&amp;#34;, 42) // ログ出力、ここで `ctx` を渡しているのがポイント  slog.InfoContext(ctx, &amp;#34;world&amp;#34;) // Output:  // time=2023-08-03T18:10:20.424+09:00 level=INFO msg=hello count=42 my_context=foo-bar  // time=2023-08-03T18:10:20.</description>
    </item>
    
    <item>
      <title>「ふっかつのじゅもん」みたいなBase64亜種「base64dq」を書いた</title>
      <link>https://shogo82148.github.io/blog/2023/07/26/2023-07-26-base64dq-base64-variant-inspired-by-dragon-quest/</link>
      <pubDate>Wed, 26 Jul 2023 21:48:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2023/07/26/2023-07-26-base64dq-base64-variant-inspired-by-dragon-quest/</guid>
      <description>ドラゴンクエストシリーズ第一作目に登場する「ふっかつのじゅもん」っぽいBase64亜種を書いてみました。
 shogo82148/base64dq  使い方 簡単に使えるようコマンドラインインターフェイスも用意しました。go installでインストール可能です。
$ go install github.com/shogo82148/base64dq/cmd/base64dq@latest base64dqコマンドが使えるようになります。 Coreutilsのbase64コマンドと同様に使えます。
$ echo &#39;こんにちは&#39; | base64dq づづきとづづさとづづきわづづきめづづきげうむ・・ $ echo &#39;づづきとづづさとづづきわづづきめづづきげうむ・・&#39; | base64dq --decode こんにちは ふっかつのじゅもん 「ふっかつのじゅもん」はドラゴンクエストシリーズ第一作目で採用されたゲームのセーブ方式です。 ゲームを中断するときには、再開したときに同じ状態からゲームを始められるよう、ゲームの状態を保存しておく必要があります。 しかしドラクエIが発売されたのは1986年5月。 当時ドラクエIはファミコン向けに発売されたのですが、ファミコンにはフラッシュROMのような贅沢なハードウェアはついていません。 電源を落とすと簡単にデーターは失われてしまいます。
そこでゲームの状態を20文字の「ふっかつのじゅもん」にエンコードし、 再開時には「ふっかつのじゅもん」をプレイヤーに入力してもらう、というセーブ方式が編み出されました。
プレイヤーはゲームを中断するたびに「ふっかつのじゅもん」を書き写す必要がありました。 当時は液晶ディスプレイなどあるはずもなく、一般の家庭にあるのはブラウン管のアナログディスプレイです。 解像度が荒く読み取るのが大変なため、「ふっかつのじゅもん」を間違え散っていったプレイヤーも多くいたと聞いています（筆者はまだ生まれていないのでよく知らない）。
ふっかつのじゅもんとBase64の関係 今では有志による解読も進みふっかつのじゅもんのジェネレーターも開発されています。
DQ1 復活の呪文解析日記によると、「ふっかつのじゅもん」は64種類のひらがなで構成されているそうです。 64。実に切りのいい数字です。 1文字で6ビットの情報を表し、合計で120ビットのセーブデータを表現しています。
このエンコード方法はBase64とまったく同じですね！ 「ふっかつのじゅもん」は、64種類のASCII文字の代わりに、64種類のひらがなを使ったBase64の亜種、と考えることができます。
ちなみにBase64がRFCに登場したのは1987年4月のRFC 989だそうです。 当時はBase64という言葉すらなく、printable encodingと呼ばれていたようです。 ドラクエIが発売されたのは1986年5月なので、Base64が一般に広まる前に「ふっかつのじゅもん」は世に公開されたわけですね。 すごい！
もちろん規格化されていないだけで「64種類の文字で情報をエンコードする」というアイディア自体はもっと昔からあったのでしょう。 でも似たようなものがゲームに使われていたのはおもしろいですね。
base64dq そういうわけで「ふっかつのじゅもん」の影響を受けて作ったのが shogo82148/base64dq です。 64種類のASCII文字の代わりに、以下の64種類のひらがなを使います。
あいうえお かきくけこ さしすせそ たちつてと なにぬねの はひふへほ まみむめも やゆよ らりるれろ わ がぎぐげご ざじずぜぞ だぢづでど ばびぶべぼ ・（パディング） 「ふっかつのじゅもん」にはパディングはないので、適当に「・」を選びました。</description>
    </item>
    
    <item>
      <title>GitHub Actions上でFuzzingを実行するアクションを書いた</title>
      <link>https://shogo82148.github.io/blog/2023/07/05/2023-07-05-actions-go-fuzz/</link>
      <pubDate>Wed, 05 Jul 2023 00:41:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2023/07/05/2023-07-05-actions-go-fuzz/</guid>
      <description>Go 1.18からGo Fuzzingの機能が追加されました。 僕もいくつかのパッケージに導入してみたのですが、予期していなかったテストパターンを見つけられて役にやっている気がします。 Fuzzテストが増えてきたので、毎回手元でFuzzテストを実行するのも大変になってきました。
簡単にFuzzテストを実行する環境を作れないかと、GitHub Actions上でFuzzテストを実行するActionを書いてみました。
 shogo82148/actions-go-fuzz  使い方 Fuzzingのチュートリアルのコードで試してみましょう。
テスト対象の関数を書く main.go に文字列を反転させるコードを書きます。
// main.go package main func Reverse(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &amp;lt; len(b)/2; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) } チュートリアルを進めていくとわかるのですが、このコードは「マルチバイト文字を正しく処理できない」というバグがあります。 このバグをFuzzingを使って見つけてもらいましょう。
Fuzzテストを書く Reverseを2回実行すると同じ文字列に戻るはずです。 このことを確認するテストを書きます。
さらに、入力がUTF-8としてValidであるなら、出力もValidであって欲しいです。 これもテストで確認します。
package main func FuzzReverse(f *testing.F) { testcases := []string{&amp;#34;Hello, world&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;!</description>
    </item>
    
    <item>
      <title>Go 1.22で導入されるforループ変数の変更</title>
      <link>https://shogo82148.github.io/blog/2023/06/22/2023-06-22-go-loopvar-experiment/</link>
      <pubDate>Thu, 22 Jun 2023 11:45:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2023/06/22/2023-06-22-go-loopvar-experiment/</guid>
      <description>Go 1.21 Release Candidateで、 forループ変数のセマンティクス変更の予定をしりました。 導入の背景や影響について、WikiのLoopvarExperimentで説明されています。
地味にインパクトが大きそうだったので、内容を理解するために和訳しました。 といっても訳の大半はChatGPT ChatGPT May 24 Versionのものです。便利。 多少僕の修正も入ってます。
以下LoopvarExperimentのリビジョンdce06fbの和訳です。
 Go 1.22では、Goチームはforループ変数のセマンティクスを変更し、繰り返し毎のクロージャやゴルーチンにおける意図しない共有を防止することを検討しています。 Go 1.21には、この変更の予備的な実装が含まれており、プログラムをビルドする際にGOEXPERIMENT=loopvarを設定することで有効になります。 変更の影響を理解するのに協力していただける方々には、GOEXPERIMENT=loopvarを使用して試してみていただき、遭遇した問題や成功した点についてご報告いただけると幸いです。
このページでは、変更に関するよくある質問にお答えします。
この変更を試すにはどうすればいいですか？ Go 1.21を使用して、以下のようにGOEXPERIMENT=loopvarを設定してプログラムをビルドします。
GOEXPERIMENT=loopvar go install my/program GOEXPERIMENT=loopvar go build my/program GOEXPERIMENT=loopvar go test my/program GOEXPERIMENT=loopvar go test my/program -bench=. ... この問題はどのようなものですか？ 以下のようなループを考えてみましょう：
func TestAllEvenBuggy(t *testing.T) { testCases := []int{1, 2, 4, 6} for _, v := range testCases { t.Run(&amp;#34;sub&amp;#34;, func(t *testing.T) { t.Parallel() if v&amp;amp;1 != 0 { t.</description>
    </item>
    
    <item>
      <title>GolangでQRコード、マイクロQRコード、rMQRコードのジェネレーターを作った</title>
      <link>https://shogo82148.github.io/blog/2023/01/01/2023-01-01-rmqr-generator-written-in-golang/</link>
      <pubDate>Sun, 01 Jan 2023 23:45:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2023/01/01/2023-01-01-rmqr-generator-written-in-golang/</guid>
      <description>GolangでQRコード、マイクロQRコード、rMQRコードのジェネレーターを作りました。
 shogo82148/qrcode  作った理由は、「QRコードの復元能力はどういうマジックなんだろう？」と昔から気になっていたからです。 エンコードの方法は分かったものの、なぜ復元できるのかはわからぬままですが・・・。
また、2022年5月に発表されたrMQRコードにも対応しています。
 デンソーウェーブ、細長く狭いスペースにも印字できる 長方形型の新しいQRコード「rMQRコード」を開発  使い方 qrcode.Encodeにバイト列を渡すと、 QRコードの画像をimage.Imageとして返します。 あと通常の画像と同じように扱えるので、image/pngなどで書き出してください。
package main import ( &amp;#34;bytes&amp;#34; &amp;#34;image/png&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/shogo82148/qrcode&amp;#34; ) func main() { img, err := qrcode.Encode([]byte(&amp;#34;Hello QR Code!&amp;#34;)) if err != nil { log.Fatal(err) } var buf bytes.Buffer if err := png.Encode(&amp;amp;buf, img); err != nil { log.Fatal(err) } if err := os.WriteFile(filename, buf.Bytes(), 0o644); err != nil { log.Fatal(err) } } QRコードは日本生まれの規格なので、漢字を効率的に格納するモードがあります。 JIS X 0208の範囲内にある文字は自動的に漢字モードになります。</description>
    </item>
    
    <item>
      <title>50音順(JIS X 4061)をGoで実装してみた</title>
      <link>https://shogo82148.github.io/blog/2022/11/20/2022-11-20-implement-jis-x-4061/</link>
      <pubDate>Sun, 20 Nov 2022 17:17:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2022/11/20/2022-11-20-implement-jis-x-4061/</guid>
      <description>今後Go言語でも50音順ソートしたくなるのでは、と虫の知らせがあったので作ってみました。
 shogo82148/jisx4061  50音順とは何者か 50音順は「あいうえおかきくけこ・・・」あたりまでなら簡単なので、すごく簡単に思えるじゃないですか。 しかしここに濁音・半濁音・拗音・片仮名・長音記号etc. が入ってくるとだいぶややこしくなります。
濁音を含んだソート たとえば濁点の扱いを見てみましょう。 「さどう」「さとうや」「サトー」「さと」「さど」「さとう」「さとおや」という7つの単語を並べ替えます。 普通にGo標準のソートを使うと以下のようになります。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func main() { list := []string{ &amp;#34;さどう&amp;#34;, &amp;#34;さとうや&amp;#34;, &amp;#34;サトー&amp;#34;, &amp;#34;さと&amp;#34;, &amp;#34;さど&amp;#34;, &amp;#34;さとう&amp;#34;, &amp;#34;さとおや&amp;#34;, } sort.Strings(list) fmt.Println(list) // Output:  // [さと さとう さとうや さとおや さど さどう サトー] } 一見良さそうですが・・・「さと」と「さど」が遠く離れてしまいました。 このふたつは音が似ているので近くに配置したいです。
jisx4061を使ったソート shogo82148/jisx4061を使うと解決します。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/shogo82148/jisx4061&amp;#34; ) func main() { list := []string{ &amp;#34;さどう&amp;#34;, &amp;#34;さとうや&amp;#34;, &amp;#34;サトー&amp;#34;, &amp;#34;さと&amp;#34;, &amp;#34;さど&amp;#34;, &amp;#34;さとう&amp;#34;, &amp;#34;さとおや&amp;#34;, } jisx4061.</description>
    </item>
    
    <item>
      <title>AWS SDK v2 for Goが壊れた、Googleお前もか</title>
      <link>https://shogo82148.github.io/blog/2022/09/20/2022-09-20-aws-sdk-v2-and-googleapi-break-my-code/</link>
      <pubDate>Tue, 20 Sep 2022 10:40:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2022/09/20/2022-09-20-aws-sdk-v2-and-googleapi-break-my-code/</guid>
      <description>何もしていないのに壊れました。（ライブラリのアップデートはした）
AWS SDK v2 for Goが壊れた 該当のプルリクエストはこちら:
 Bump github.com/aws/aws-sdk-go-v2/service/ssm from 1.27.13 to 1.28.0 in /lambda/metadata-updater shogo82148/private-rpm-repo#87  true を *bool 型に変換できないと怒られてしまいました。
./main.go:305:19: cannot use true (untyped bool constant) as *bool value in struct literal どうやらAWS SDK v2のこのコミットの影響でビルドが通らなくなったようです: aws/aws-sdk-go-v2@a13b7a4
diff --git a/service/ssm/api_op_GetParameter.go b/service/ssm/api_op_GetParameter.go index c7617dcfd0e..f58354b6528 100644 --- a/service/ssm/api_op_GetParameter.go +++ b/service/ssm/api_op_GetParameter.go @@ -39,7 +39,7 @@ type GetParameterInput struct {  // Return decrypted values for secure string parameters. This flag is ignored for // String and StringList parameter types.</description>
    </item>
    
    <item>
      <title>RFC9226 Bioctal: Hexadecimal 2.0 の Go 実装を書いてみた</title>
      <link>https://shogo82148.github.io/blog/2022/04/15/2022-04-15-implement-bioctal/</link>
      <pubDate>Fri, 15 Apr 2022 20:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2022/04/15/2022-04-15-implement-bioctal/</guid>
      <description>COVID-19 のワクチン接種3回目の副反応におびえているいっちーです。 摂取から5時間経ちましたが、まだ特に症状は表れていません。 翌朝が怖い。
さて、副反応への恐怖を少しでも紛らわせようと、 RFC9226 Bioctal: Hexadecimal 2.0 を実装してみた、というお話です。
 shogo82148/go-bioctal  RFC9226 Bioctal: Hexadecimal 2.0 4/1 に公開されていることから分かる通り、Joke RFC です。 実用性はありません・・・が、実装することは可能です。
今年のジョークRFC「16進数2.0」。16進数を表記するには0から9の数字にABCDEFを加えた物が一般的だが、01234567cjzwfsbvにする事で、数字かどうかで最上位bitがすぐ分かり、なんとなく形が似た文字から下3bitがすぐに連想できる為humanのbrain cyclesを抑えられるという内容https://t.co/BsmKFcqv4J
&amp;mdash; Fadis (@fadis_) April 2, 2022  一般的な16進数の変換に使われる文字を、下位3bit が同じもの同士が縦に並ぶよう配置すると、以下のようになります。
   0 1 2 3 4 5 6 7     8 9 A B C D E F    下の段はアルファベットが入るのに、8, 9 だけが数字で不自然ですね(？) というわけで、下段を英字だけにしたものが Bioctal です。
   0 1 2 3 4 5 6 7     c j z w f s b v    一般的に人間が一度に覚えられる物事の数は 7±2 と言われています。 16個も文字とそれに対応するbit列を覚えるのは大変です。</description>
    </item>
    
    <item>
      <title>Goの日時比較が覚えられない件</title>
      <link>https://shogo82148.github.io/blog/2022/02/23/2022-02-23-compare-time-in-golang/</link>
      <pubDate>Wed, 23 Feb 2022 22:49:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2022/02/23/2022-02-23-compare-time-in-golang/</guid>
      <description>Go言語の time.Time 型の比較は比較演算子が使えず、 Time.Before と Time.After を使う必要があります。 日本の Gopher あるあるだと思うんですが、これって覚えられないですよね・・・。 英語のネイティブスピーカーだと楽勝なんでしょうか。
よくわからなくって毎回ググっているので、対応表にまとめました。
対応表    大小関係  Go での記述     t == u ⇔ t.Equal(u)   t &amp;gt; u ⇔ t.After(u)   t &amp;lt; u ⇔ t.Before(u)   t &amp;gt;= u ⇔ !t.Before(u)   t &amp;lt;= u ⇔ !t.After(u)    以上
確認コード 日時の比較をわかりやすくする Bad Know-How として Time.UnixNano を使うという手があります。 Unix Timestamp は整数なのでおなじみの比較演算子を使えます。</description>
    </item>
    
    <item>
      <title>AWS ClockBound で遊んでみた</title>
      <link>https://shogo82148.github.io/blog/2021/12/11/aws-cloud-bound/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2021/12/11/aws-cloud-bound/</guid>
      <description>この記事は、フラー株式会社 Advent Calendar 2021 の11日目の記事です。 10日目は @nobux42 で「再読：リファクタリング・ウェットウェア」でした。
もう一ヶ月前になりますが、AWS から ClockBound という時間を扱うとても 地味な 有益なソフトウェアがリリースされました。
 Amazon Time Sync Service now makes it easier to generate and compare timestamps  地味過ぎてネタかぶりしなさそうなので 時間は現代の情報通信の基盤なので、しっかりと検証していきましょう！ 日本ではNICTの 時空標準研究室 が標準時を定めています。 名前からしてかっこいい。
ClockBound とは 一言でいうとGoogleの TrueTime のAWS版です。 TrueTime は Google が自社のサーバーセンターに設置している非常に正確な時計です。 Google が提供しているリレーショナルデータベースである Cloud Spanner は、 リージョンをまたいだ一貫性を保証するために TrueTime から生成されたタイムスタンプを利用しています。
ようするに ClockBound を使えば、 AWSのインフラ上に Google Cloud Spanner Clone を構築できる！(？)、というわけですね。 すごい！
ClockBoundD のインストール なんかすごそうなことがわかったので、とりあえず動かしてみましょう。
ClockBound はタイムスタンプを提供するデーモン「ClockBoundD」と、ClockBoundD からタイムスタンプを取得するためのライブラリ「ClockBoundC」に分かれています。 タイムスタンプの提供元がないと始まらないので、まずは ClockBoundD をインストールしていきましょう。</description>
    </item>
    
    <item>
      <title>ghq list が interrupted system call で死ぬ問題を直した</title>
      <link>https://shogo82148.github.io/blog/2021/02/28/fix-ghq-list-fails-with-interrupted-system-call/</link>
      <pubDate>Sun, 28 Feb 2021 23:42:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2021/02/28/fix-ghq-list-fails-with-interrupted-system-call/</guid>
      <description>常用している Mac Book Pro の OS を Big Sur に上げたんだけど、 ghq list が以下のエラーを吐くようになってしまった。
$ ghq list error failed to filter repos while walkLocalRepositories(repo): interrupted system call  ghq list sometimes fails with interrupted system call #311  結論からいうと Go 1.14 から入った以下の変更が原因だったんだけど、 実際に遭遇したのは初めてだったのでメモ。
 Go 1.14 でシステムコールが EINTR エラーを返すようになった  Go 1.14 でランタイムに入った変更 根本的な原因は Go 1.14 リリースノート のこの辺の変更です。
 A consequence of the implementation of preemption is that on Unix systems, including Linux and macOS systems, programs built with Go 1.</description>
    </item>
    
    <item>
      <title>改: PerlとGolangで実行できるPolyglot書いてみた</title>
      <link>https://shogo82148.github.io/blog/2021/02/23/improve-go-and-perl-polyglot/</link>
      <pubDate>Tue, 23 Feb 2021 18:00:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2021/02/23/improve-go-and-perl-polyglot/</guid>
      <description>仕事をしているときにふとひらめいた。
 Perl と Golang で実行できる Polyglot 書いてみた  文字列置換の s/// に使う記号はダブルクオーテーションでも行ける！
package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { s.Println(&amp;#34;Hello macotasu&amp;#34;) } package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { s.Println(&amp;#34;Hello macotasu&amp;#34;) } Go で dot import をしなければならない、という制限がなくなるので、自由度が上がりました。
package main; import (s&amp;#34;fmt&amp;#34;/*&amp;#34;); sub import { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) import &amp;#34;math&amp;#34; func main() { s.</description>
    </item>
    
    <item>
      <title>Yet Another AWS X-Ray Go SDK でログの関連付けをサポートした</title>
      <link>https://shogo82148.github.io/blog/2020/07/06/aws-xray-yasdk-go-supports-logs-correlation/</link>
      <pubDate>Mon, 06 Jul 2020 22:49:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2020/07/06/aws-xray-yasdk-go-supports-logs-correlation/</guid>
      <description>僕が管理しているサービスでは、ALB が発行する Trace ID を調査時の手がかりとして使えるようログに出力しています。 これのおかげで、Nginx, アプリケーション, その他AWSのマネージドサービス, etc. といった異なるコンポーネントであっても、関連するログを抽出ができ、 障害発生時の役に立っています。 しかし、肝心の抽出作業がマネージドコンソールぽちぽちなため、完全に職人芸になっているというのが現状でした。
解決のための良いツールがないかな、と目をつけたのが CloudWatch ServiceLens です。 CloudWatch メトリックとログ、AWS X-Ray からのトレースを結び付けて、直感なインターフェースで分析できるというもの。
 Amazon CloudWatch ServiceLens の発表  AWS X-Ray のトレース結果を送るのは、以前開発した Yet Another AWS X-Ray SDK for Go でできます。 CloudWatch Logs への出力方法は色々ありますが、僕は自作の cloudwatch-logs-agent-lite を使っています。
材料はそろった、さあ、ServiceLens で分析だ！と行きたいところですが、 ただ単にこれらの情報を送りつけるだけでは、得られる情報は X-Ray 単体、CloudWatch Logs 単体で使ったときと大差ありません。 X-Ray のトレース結果とログの関連付けが行われていないので、結局 Trace ID を使って CloudWatch Logs を検索する必要が出てきてしまいます。
ドキュメントを見る限り、2020-07-06現在 AWS X-Ray SDK for Java だけがログ関連付け機能に対応しているようです。 JavaにできてGoにできないわけがないだろう・・・ということで移植してきました。
使い方 aws-xray-yasdk-go の v1.1.1 移行で対応しているので、そのバージョンを落としてきます。</description>
    </item>
    
    <item>
      <title>Yet Another AWS X-Ray Go SDK を作った</title>
      <link>https://shogo82148.github.io/blog/2020/03/30/aws-xray-yasdk-go/</link>
      <pubDate>Mon, 30 Mar 2020 06:37:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2020/03/30/aws-xray-yasdk-go/</guid>
      <description>AWS X-Ray Go SDK の地雷処理をしている話 で投げたSQLのプルリクエスト も無事マージしてもらい、 その後もちょくちょくプルリクエストを投げて地雷処理をしていたんですが、我慢できずにやってしまいました・・・。
 Yet Another AWS X-Ray SDK for Go  そもそも AWS X-Ray ってなんだ、という方は以下のリンクから @fujiwara さんの記事へ飛べるのでどうぞ。
 AWS Lambda Perl Runtime で AWS X-Ray を使えるようになりました  使い方 だいたいオフィシャルSDKと一緒です。 ただし、パッケージ分割をしたので、呼び出す関数名等はちょっと変わってます。 他にも微妙に挙動が違う箇所があります。
環境変数の設定 AWS_XRAY_DAEMON_ADDRESS, AWS_XRAY_CONTEXT_MISSING 等の環境変数の設定項目は本家と合わせました。 ただし、以下の点が本家とは異なります。
 コード内の設定が優先されます。 環境変数はコード内で明示的に設定が行われなかった場合のフォールバックです。 AWS_XRAY_CONTEXT_MISSING のデフォルト値は LOG_ERROR です。  セグメントの作り方 オフィシャルSDKは seg.Close(err) のようにセグメントを閉じるときにエラーを渡します。 Go には defer という便利な機能があるので、セグメントを閉じるときもこれを使いたいところです。 だたエラーを正しく受け取るには、以下のように戻り値に名前をつけて、defer 部分を無名関数の呼び出しにする必要があります。
// オフィシャルSDKの場合 import &amp;#34;github.com/aws/aws-xray-sdk-go/xray&amp;#34; func DoSomethingWithSubsegment(ctx context.Context) (err error) { ctx, seg := xray.</description>
    </item>
    
    <item>
      <title>Goのバイナリに静的ファイルを埋め込むツール assets-life を書いた</title>
      <link>https://shogo82148.github.io/blog/2019/07/24/assets-life/</link>
      <pubDate>Wed, 24 Jul 2019 20:54:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/07/24/assets-life/</guid>
      <description>日本語の Go コミュニティだと go-bindata (なんか乗っ取り騒動とか色々あってメンテナンスされてない), go-assets (最近メンテナンス滞りがち) が有名(要出典)なやつです。 これらのライブラリに関してたくさん日本語記事が書かれて、今もたくさん検索に引っかかるのですが、残念ながら最近はメンテナンスが滞っています。
最近は statik の名前もよく見るようになりました。 その他は Resource Embedding - Awesome Go からどうぞ。
で、まあ、今回も完全に車輪の再発明なんですが、他の実装には色々と思うところがあり書いてみました。
 shogo82148/assets-life  USAGE なにはともあれ、まずは go get してきます。
$ go get github.com/shogo82148/assets-life assets-life というコマンドがインストールされるので、 バイナリに組み込みたいディレクトリと出力先を指定します。
$ assets-life /path/to/your/project/public public 出力先のディレクトリは Go のパッケージとしてインポートできるようになってます。 Root という変数のなかにファイルが埋め込まれており、http.FileSystem インターフェースを介してアクセスできます。
import ( &amp;#34;net/http&amp;#34; &amp;#34;example.com/your/project/public&amp;#34; ) func main() { http.Handle(&amp;#34;/&amp;#34;, http.FileServer(public.Root)) http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) } 特長 コードの再生成にコマンドのインストールが不要 これが一番の特長です。 バイナリにファイルを埋め込む都合上、静的ファイルを修正した場合にコードの再生成が必要です。 assets-life は go:generate ディレクティブを埋め込んだコードを出力するので、コードの再生成は go generate でできます。
# /path/to/your/project/public に修正を加える # コードの再生を行う $ go generate example.</description>
    </item>
    
    <item>
      <title>Goで指数的バックオフをやってくれるgo-retryを書いた</title>
      <link>https://shogo82148.github.io/blog/2019/07/22/go-retry/</link>
      <pubDate>Mon, 22 Jul 2019 07:33:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/07/22/go-retry/</guid>
      <description>完全に車輪の再発明なんですが、他の実装には色々と思うところがあり書いてみました。
 shogo82148/go-retry  MOTIVATION カッコいいインターフェースが欲しい インターフェースは lestrrat さんのこの資料を参考にしています。
  GoらしいAPIを求める旅路 (Go Conference 2018 Spring)  from lestrrat  「これ、Loop Condition だ」のあたりで、なるほど！と思ってインターフェースを真似てみました。 このインターフェースに沿って、lestrratさん自身が実装した lestrrat-go/backoff があります。 しかし、個人的にちょっと実装が複雑だなと感じたので、もうちょっとシンプルに書けないかとやってみました。
Context サポート 先行実装たちは Context がGoに取り込まれる前からあるので、 Contextに対応したインターフェースが後付だったり、 そもそもContextに対応していなかったりします。 Context未対応の Go 1.5 はすでにサポート対象外なので、もう Context が存在しない実行環境は考えなくてよいはずです。
SYNOPSIS Loop Condition Interface 使い方は lestrrat-go/backoff と大体一緒。 指数的バックオフに必要な各種パラメーターをポリシーとして与え、リトライのためのループを回します。
// 指数的バックオフの各種パラメーターをポリシーとして定義 var policy = retry.Policy{ // 初回待ち時間  MinDelay: 100 * time.Millisecond, // 最大待ち時間  MaxDelay: time.Second, // 最大試行回数  MaxCount: 10, } func DoSomethingWithRetry(ctx context.</description>
    </item>
    
    <item>
      <title>GoのバイナリをRubyスクリプトとしても扱う</title>
      <link>https://shogo82148.github.io/blog/2019/07/02/go-build-polyglot/</link>
      <pubDate>Tue, 02 Jul 2019 21:55:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/07/02/go-build-polyglot/</guid>
      <description>$ ruby --help Usage: ruby [switches] [--] [programfile] [arguments] (中略) -x[directory] strip off text before #!ruby line and perhaps cd to directory (後略) なんか Ruby にも -x あるらしいので。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; ) const script = ` #!ruby puts &amp;#34;Hello Ruby World!!\n&amp;#34; __END__ ` func init() { runtime.KeepAlive([]byte(script)) } func main() { fmt.Println(&amp;#34;This is Go world!!&amp;#34;) } はい。
$ go build -o main main.go $ ./main This is Go world!</description>
    </item>
    
    <item>
      <title>サーバーの時刻を伝える time wellknown uri を実装してみた</title>
      <link>https://shogo82148.github.io/blog/2019/05/27/time-over-https/</link>
      <pubDate>Mon, 27 May 2019 12:10:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/05/27/time-over-https/</guid>
      <description>インターネットをさまよっていたら、 /.well-known/time の存在を知ったので、雑に実装してみました。
使い方 うまいこと共存できそうだったので、HTTP/WebSocketで時刻同期するWebNTPを書いた で作成した WebNTP の一部として実装してあります。
 shogo82148/go-webntp  $ go get github.com/shogo82148/go-webntp/cmd/webntp $ webntp -serve :8080 $ curl -I localhost:8080/.well-known/time HTTP/1.1 204 No Content X-Httpstime: 1558915632.285965 Date: Mon, 27 May 2019 00:07:12 GMT 仕様 HTTPには「予約済みのURI」というものが定義されています。(RFC5785)。
 Well-Known URIs  Let&amp;rsquo;s Encrypt でドメインの所有権確認に使用される ACMEプロトコル(RFC8555) や、 Mastodon のユーザーディスカバリーに使用する WebFinger(RFC7033)等々、 近年話題になったサービスの裏方で使われています。
 /.well-known/acme-challenge ACMEプロトコル(RFC8555) /.well-known/webfinger WebFinger(RFC7033)  Time over HTTPS も Well-Known URIs を利用するプロトコルのひとつです。
 /.well-known/time Time over HTTPS specification  仕様としては非常に単純で、サーバー側は HTTP の HEAD に対して、 Date ヘッダーをつけたリクエストを返すだけ。 より高精度な時刻を得るために X-HTTPSTIME ヘッダーに秒未満の情報を入れた Unix タイムスタンプ を返すこともできます。</description>
    </item>
    
    <item>
      <title>CloudFormationのMackerel用インテグレーションを作ってる話</title>
      <link>https://shogo82148.github.io/blog/2019/04/17/cfn-mackerel-macro/</link>
      <pubDate>Wed, 17 Apr 2019 18:26:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/04/17/cfn-mackerel-macro/</guid>
      <description>Mackerel は mkr コマンドを用いて cli から操作ができます。 mkr コマンドを用いると 監視ルールを GitHub で管理 したり、 カスタムダッシュボードを管理したり、といったことができます。 しかし、個人的に以下のような不満があります。
 サービス、ロール、ホスト、新ダッシュボード等々、監視設定以外のリソースに対応していない  旧ダッシュボードは対応しているんだけど、新ダッシュボード対応がまだ 新ダッシュボードのUIは使いやすくてすごくいいんだけど、コピペや一斉置換ができないので、テキストで管理したい   出力がJSONなのつらい  JSON手で書くの難しくないですか？   メトリックスの送信設定と監視設定の管理が別になってしまう  カスタムメトリックス送っているのに監視設定を忘れた、みたいなことが起こる    メトリックスの送信設定については、以前 サーバーレスでCloudWatchメトリクスをMackerelに転送する で CloudFormation上での管理を実現しました。 ここにさらに Mackerel の監視設定を追加できれば、最強なのでは？とやってみました。
例 あれこれ説明する前に例を見てもらったほうがわかりやすいと思うので、こんなことができますよ、という設定例から。
例1: レスポンスタイムの99%パーセンタイルを監視する Mackerel の AWSインテグレーション は ALB に対応していますが、 レスポンスタイムのメトリックスは平均レスポンスタイムだけです。 「平均」は代表的な統計値ですが、全体としては速いんだけど一部のリクエストだけ遅い、という状況を見逃してしまいます。 レスポンスタイムの大まかな分布をパーセンタイルで把握したい、ということはよくありますよね？ (K社でZabbixを使って監視していたときによくお世話になった)
今回作ったインテグレーションを使えば、以下のように「Mackerelのサービス定義」「メトリックスの転送設定」「監視設定」が CloudFormation のテンプレートとして表現できます。
AWSTemplateFormatVersion:2010-09-09# Type: Mackerel::* を使うためのおまじないTransform:- AWS::Serverless-2016-10-31- Mackerel- JSONStringResources:MackerelService:Type:Mackerel::ServiceProperties:Name:&amp;#34;awesome-service&amp;#34;# メトリックスを転送する Lambda 関数MetricsForwarder:Type:AWS::Serverless::ApplicationProperties:Location:ApplicationId:arn:aws:serverlessrepo:us-east-1:445285296882:applications/mackerel-cloudwatch-forwarderSemanticVersion:0.0.9Parameters:ParameterName:&amp;#34;/api-keys/api.mackerelio.com/headers/X-Api-Key&amp;#34;ForwardSettings:!GetAtt MetricsForwarderSettings.Query# CloudWatch から99%パーセンタイルを取得するMetricsForwarderSettings:Type:JSON::StringProperties:Query:- service:!GetAtt MackerelService.</description>
    </item>
    
    <item>
      <title>外部サービスでもIAM Roleで認証がしたい！</title>
      <link>https://shogo82148.github.io/blog/2019/02/12/ssm-sign-proxy/</link>
      <pubDate>Tue, 12 Feb 2019 12:46:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/02/12/ssm-sign-proxy/</guid>
      <description>背景 外部サービスのAPIやWebHookを叩くときには、多くの場合 API トークンが必要になります。 もちろん API トークン無しでも叩けるサービスはありますが、GitHub APIのようにトークン無しではリクエスト数が大きく制限されたり、 一部機能が制限されてしまう場合があります。
外部連携サービスが増えてくると、このAPIトークンをどうやって管理するかが問題になってきます。 プロダクションに投入されているサービスは普通複数のサーバーから構成されており、各サーバーにAPIトークンを配布するのはちょっと面倒です。 この問題に対して、以下のようなことが行われて来ました。
 プライベートネットワークからのアクセスに限定した Proxy を立てる APIトークンの管理は Proxy に任せる  DevOpsが注目され、Slackの利用が広まったころに、このような目的で書かれたProxyサーバーがよく登場しました。
 社内IRCをSlackに移行した時にやったこと  この記事で紹介されている kayac/nopaste   Slackboard〜Slackプロキシサーバ in Go〜 Slackプロキシサーバ〜slackboard〜を利用したメルカリのSlack活用法 App::Ikachan - 様々なサーバのバッチ処理の結果等を IRC のチャンネルに通知するサーバ  (IRCはHTTPで動いているわけではないし、大本の目的もコネクション維持だけど、認証も代理でやってくれる)    しかし、これらのサーバーはSlack専用だったりIRC専用だったりします。 Slackだけじゃなくって、GitHubにコメント登録したり、Mackerelのグラフアノテーションを投稿したり、 他のサービスとも連携したい！
最近はどんなAPIもHTTPで提供されるようになったので(IRCは・・・ウッ・・・そんなのなかった)、もっと汎用的に書けるのではとやってみました。
実装 APIトークンの保管場所として AWS Systems Manager Parameter Store を採用しました。 Parameter Store からAPIトークンを取り出す部分と、実際にAPIを叩く部分は AWS Lambda を使用します。 各サーバーに Forward Proxy デーモンを立てておき、APIを使いたいアプリケーションはこのProxyを経由するようにします。
この図ではEC2インスタンスを例にしていますが、IAM Roleを付与できるAWSのサービスであれば何でも (ECS, Lambda, CodeBuild, etc.) APIにアクセスすることができます。</description>
    </item>
    
    <item>
      <title>サーバーレスでCloudWatchメトリクスをMackerelに転送する</title>
      <link>https://shogo82148.github.io/blog/2019/01/31/mackerel-cloudwatch-transfer/</link>
      <pubDate>Thu, 31 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/31/mackerel-cloudwatch-transfer/</guid>
      <description>背景 サーバーの監視にMackerelを使っているのですが、 用意されているメトリクスでは足りずカスタムメトリクスを追加することが多々あります。 Mackerel Agent Pluginsを利用すればメトリクスを増やすこと自体は簡単なのですが、 Agentを設置するインスタンスが増えるので、サーバー保守の手間が増えてしまいます。
僕のユースケースでは監視対象はたいていAWSのマネージド・サービスなので、 AWS CloudWatch に投稿されたメトリクスが Mackerel で見れれば十分なことが多いです。
そこで、以下の記事を参考に AWS Lambda と CloudWatch Events を組み合わせて、Mackerelへメトリクスを転送するスクリプトを書いてみました。
 Amazon LambdaでCloudWatchのメトリクスをMackerelに監視させる  デプロイしてみる 今回はなんと！皆さんの AWSマネジメントコンソールから、クリックひとつでデプロイできるようにしてみました！
 mackerel-cloudwatch-forwarder  ・・・と、その前に下準備が必要です。 MackerelのダッシュボードからAPIキーをコピーしてきて、 AWS Systems Manager パラメータストアに Secure String として登録しておきます。 スクショでは Mackerel のものだと分かりやすいよう /development/api.mackerelio.com/headers/X-Api-Key という名前をつけました。 この名前を後で使うので覚えておきましょう。
次に AWS Lambda の画面を開き、「関数の作成」をクリックします。
「一から作る」「設計図」「AWS Serverless Application Repository」の3つの選択肢が表れるので、 「AWS Serverless Application Repository」 を選択します。 検索BOXに「Mackerel」と入れると、mackerel-cloudwatch-forwarderが 出てくるので、それを選択します。 なお、この選択肢はデフォルトでは表示ないので、「Show apps that create custom IAM roles or resource policies」にチェックを入れましょう。</description>
    </item>
    
    <item>
      <title>CloudFormationでECSタスクのドレインをやる</title>
      <link>https://shogo82148.github.io/blog/2019/01/30/drain-ecs-task-with-cloudformation/</link>
      <pubDate>Wed, 30 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/30/drain-ecs-task-with-cloudformation/</guid>
      <description>やってみたはいいものの、1年後には仕組みを忘れていそうなのでメモ。
背景 昔はサービス毎にポコポコEC2インスタンスを立てていたのですが、 幸か不幸かインスタンスのリソースが余り気味でした。 そこで、最近流行りのコンテナ技術に乗っかって Amazon ECS (Amazon Elastic Container Service) を使って、 ひとつのインスタンスに複数のサービスを載せようと目論みました。
ちょうどその頃、Spot Fleetというものを使うと、 スポットインスタンスをお手軽に借りられるという話を聞いたので、 Spot Fleet + ECS で格安クラスターを作ってみよう！と手を出してみました。
 (・・・もちろん、Fargateが東京リージョンで使えるようになったことは知っているけれど、スポットインスタンスの価格に負けてしまった・・・)
 AWS Fargate 東京リージョン サービス開始のお知らせ AWS Fargate で最大 50% の値下げを発表  ECS最適化インスタンスの更新問題 クラスターを作るだけなら、そう難しくはなく、インスタンス起動時にAmazon ECS-Optimized Amazon Linux AMIを使うだけです。 問題はこのイメージは定期的に更新される、ということです。 更新情報を流しているSNSトピックがあるので、これをサブスクライブしておくと、時たま更新通知が来ます。
 Amazon ECS-Optimized Amazon Linux AMI の更新の通知のサブスクライブ  この更新には機能追加はもちろん、セキュリティーフィックスも含まれているので、 なるべく早く新しいイメージに移行する必要があります。 移行は大まかに以下の手順で進めます。
 新しいAMIイメージに更新した Spot Fleet を作成する 古いインスタンスに残っているタスクをいい感じに終了する(ドレイン)   突然殺すとユーザーにエラーが見えてしまうので、受付中のリクエストを捌き切ってから終了しないといけない ドレインが始まるとECSがタスク数を調整するために、新しいインスタンスにタスクをお引越ししてくれる  ドレインが終了したら、古いインスタンスをシャットダウンする  ここで問題になってくるのが「古いインスタンスに残っているタスクをいい感じに終了する(ドレイン)」の部分。 コンソールからポチポチするのも面倒なので、自動化したいところ。 しかし、いろいろとドキュメントをあさってみたのですが、「APIかawscliを叩く」「SNSとAWS Lambda をうまいこと組み合わせて頑張る」みたいな方法しか見当たらない・・・ しかもAWSの公式ブログ</description>
    </item>
    
    <item>
      <title>IAM認証でAWS RDSへ接続するMySQLドライバを作った</title>
      <link>https://shogo82148.github.io/blog/2019/01/13/rdsmysql/</link>
      <pubDate>Sun, 13 Jan 2019 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2019/01/13/rdsmysql/</guid>
      <description>AWS RDS には IAM 認証を使って接続する機能があります。
 MySQL および PostgreSQL に対する IAM データベース認証 IAM 認証情報を使用して Amazon RDS への接続をユーザーに許可する方法を教えてください。  これを使って接続するGo言語のSQLドライバを書いてみました。
 https://github.com/shogo82148/rdsmysql  使い方 IAMデータベース認証はデフォルトで無効になっているので、まずはこれを有効化します。 次に AWSAuthenticationPlugin を認証方式に指定して、新しいユーザーを作りましょう。
 IAM データベース認証の有効化と無効化 データベースアカウントの作成  CREATEUSERjane_doeIDENTIFIEDWITHAWSAuthenticationPluginAS&amp;#39;RDS&amp;#39;;他のSQLドライバはimportするだけで使えるのですが、 rdsmysqlではAWSへの権限情報を設定しなければならない都合上、 sql.Register を自前で呼び出す必要があります。 とは言っても、AWS SDKがいい感じに設定ファイルとか環境変数とか読んでくれるので、 rdsmysql.Driver にAWSセッションを渡すだけです。
c := aws.NewConfig().WithRegion(&amp;#34;ap-northeast-1&amp;#34;) s := session.Must(session.NewSession(c)) d := &amp;amp;Driver{ Session: s, } sql.Register(&amp;#34;rdsmysql&amp;#34;, d) db, err := sql.Open(&amp;#34;rdsmysql&amp;#34;, &amp;#34;jane_doe:@tcp(db-foobar.ap-northeast-1.rds.amazonaws.com:3306)/&amp;#34;) if err != nil { log.Fatal(err) } defer db.Close() あとは通常のMySQLドライバとして呼び出すだけです。 go-sql-driver/mysql のラッパーになっているので、 DNS等の書き方はこれに準じます。 認証部分は rdsmysql がやってくれるので、パスワードは空でOKです。 パスワードの管理から開放されて楽ですね！</description>
    </item>
    
    <item>
      <title>Goのnil,true,falseは変数名に使えるという話</title>
      <link>https://shogo82148.github.io/blog/2018/11/22/go-nil/</link>
      <pubDate>Thu, 22 Nov 2018 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/11/22/go-nil/</guid>
      <description>@Linda_pp さんのツイートをみて
Go 言語の nil って NilLit じゃなくて Ident &amp;quot;nil&amp;quot; としてパースされるのか．それで気付いたけど nil := 42 みたいに普通に変数宣言できる（unused でエラーになるけど）
&amp;mdash; ドッグ (@Linda_pp) 2018年11月22日  なるほど、これは面白い。 と少し遊んでみたメモ。
 言語仕様にある通り、Goのキーワードは以下の25個です(Go1.11.2)。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var この一覧に nil や true, false は入っていません。 これらは builtinという扱いになっており、識別子として利用可能です。
そのため、変数名等に利用可能というわけですね。面白い。
package main import ( &amp;#34;fmt&amp;#34; ) func main() { nil := 42 fmt.</description>
    </item>
    
    <item>
      <title>PHPer向けGoのJSONデコーダーを作った</title>
      <link>https://shogo82148.github.io/blog/2018/09/24/go-phper-json/</link>
      <pubDate>Mon, 24 Sep 2018 17:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/09/24/go-phper-json/</guid>
      <description>必要に迫られて作りました。 PHPでエンコードしたJSONをいい感じにデコードしてくれるGoのパッケージです。
 shogo82148/go-phper-json  背景 さて、PHPerの方々には当たり前のことかもしれませんが、PHPの言語仕様について少しおさらいです。 それがどうしてGoで問題になるか見ていきます。
PHPのarray問題 PHPはとても便利なプログラミング言語なので、配列を扱うことができます。 ここでPHPの配列のマニュアルを読んでみましょう。
 http://php.net/manual/ja/language.types.array.php
PHP の配列は、実際には順番付けられたマップです。マップは型の一種で、 値をキーに関連付けます。 この型は、さまざまな使い道にあわせて最適化されます。 配列としてだけでなく、リスト (ベクター)、 ハッシュテーブル (マップの実装の一つ)、辞書、コレクション、スタック、 キュー等として使用することが可能です。 PHP の配列には他の PHP 配列を値として保持することができるため、 非常に簡単にツリー構造を表現することが可能です。 (強調部分は筆者によるもの)
 重要なことなのでもう一度。
 配列としてだけでなく、リスト (ベクター)、 ハッシュテーブル (マップの実装の一つ)、辞書、コレクション、スタック、 キュー等として使用することが可能です。
 他の言語でリスト、ハッシュテーブル、辞書等と呼ばれているものは、PHPにおいてはいずれも配列です。 PHPにとっては、整数を添字にしているか、文字列を添字にしているかの違いでしかありません。 (PHP7.xから整数が添字の場合に最適化が入るようになったらしいけど、大きな挙動の変更はないはず)
そのため、以下のスクリプトは true を返します。
&amp;lt;?php $a = array(&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;); $b = array(0 =&amp;gt; &amp;#34;apple&amp;#34;, 1 =&amp;gt; &amp;#34;banana&amp;#34;); var_dump($a == $b); // bool(true) この仕様のため、JSONにエンコードすると最初は配列だったのに、 処理を進めていくうちにうっかり文字列のキーを作ってしまって、 JSONのオブジェクトに変わってました、ということが起こりえます。 Goにおいて両者は全く違う型なので、デコードの際に非常に困ります。
&amp;lt;?php $a = array(1, 2, 3); print json_encode($a); // [1,2,3]  $a[&amp;#34;foo&amp;#34;] = &amp;#34;bar&amp;#34;; print json_encode($a); // {&amp;#34;0&amp;#34;:1,&amp;#34;1&amp;#34;:2,&amp;#34;2&amp;#34;:3,&amp;#34;foo&amp;#34;:&amp;#34;bar&amp;#34;} このような悲劇を防ぐために、 JSON_FORCE_OBJECT というオプションがあるのですが、 オプションの名前通りに全部JSONのオブジェクトになってしまいます。 この要素だけJSONの配列にして欲しい！といった細かな操作はできません。</description>
    </item>
    
    <item>
      <title>GoAst ViewerをWebAssemblyへビルドしてみた</title>
      <link>https://shogo82148.github.io/blog/2018/08/19/goast-viewer-using-wasm/</link>
      <pubDate>Sun, 19 Aug 2018 07:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/08/19/goast-viewer-using-wasm/</guid>
      <description>もうすぐリリースのGo1.11ではWebAssemblyのサポートが予定されています。 (2018/08/19現在の最新版はGo1.11rc1)
 Go言語がWebAssemblyをサポートへ。GOARCHは「wasm」、GOOSは「js」に  正式リリース前に少し遊んでみようということで、@yuroyoroさんのGoAst ViewerをWebAssemblyへビルドしてみました。
 GoAst Viewer WebAssembly Version shogo82148/goast-viewer  JavaScriptの連携方法 コードをASTに変換し、JSONとしてエンコードする部分(ast.go)に関しては、一切変更しなくても動きました。素晴らしい。
ただし、さすがにブラウザ上でHTTPサーバーは動かない(そういえば試してないけど、動かないよね？？)ので、JavaScriptとの連携部分を実装してあげる必要があります。 syscall/jsパッケージはまだ実験段階というステータスで機能が限られているので、 連携には少し工夫が必要です。
JavaScriptからGoの関数を呼ぶ JavaScriptからGoの関数を呼ぶには window にコールバック関数として必要な関数を登録します。
// GoASTParse 関数を定義(Go言語) js.Global().Set(&amp;#34;GoASTParse&amp;#34;, js.NewCallback(func(args []js.Value) { source := args[0].String() // ...ASTへの変換処理... })) 戻り値をGoからJavaScriptへ返す js.NewCallback なのですが、もともとは addEventListener にわたすコールバック関数なので、 関数の戻り値を受けわたす方法がありません。 回避方法はいろいろあるでしょうが、今回はコールバック関数の引数にコールバック関数指定してもらうことにしました。
// GoASTParse 関数を定義(Go言語) js.Global().Set(&amp;#34;GoASTParse&amp;#34;, js.NewCallback(func(args []js.Value) { source := args[0].String() // ...ASTへの変換処理...  args[1].Invoke(string(body)) })) // GoASTParseを呼び出す(JavaScript) GoASTParse(&amp;#34;package main; func main() {}&amp;#34;, function(body) { // ASTの表示処理 }) まとめ Goのバイナリ全般に言えることですが、WASMになってもやっぱりサイズが大きい(3.</description>
    </item>
    
    <item>
      <title>S3からファイルを落とすだけのツールを作った</title>
      <link>https://shogo82148.github.io/blog/2018/06/20/s3cli-mini/</link>
      <pubDate>Wed, 20 Jun 2018 07:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/06/20/s3cli-mini/</guid>
      <description>S3からファイルを落とすだけのツールを作りました。
 s3cli-mini  目的 流行りのCD(継続的デリバリー)を実践するために、専用のデプロイツールをダウンロードする目的で作りました。
主なデプロイ先はAWSなので、デプロイ操作には awscli が必要です。 しかしCDに使用しているCircleCIが公式に提供しているコンテナイメージにはawscliがインストールされていません。 もちろん apt-get install awscli であとからインストールすることは可能ですが、そのぶんジョブの実行時間が長くなってしまいます。 また、インストールされる awscli のバージョンが古く、ローカル環境ではうまく動くけど、 CircleCI上では最新の機能が使えず失敗するということがありました。
そこでもう awscli を使うことは諦めて、Goで AWS API を叩いてデプロイするバイナリを作ってしまうことを考えました。 Goであればシングルバイナリでインストール可能で、CI/CD環境とローカルでバージョンが一致せず悩まされることはありません。 また並行処理が得意なので、デプロイの時間短縮も図れます。
しかし、このデプロイ用のバイナリをどこに置くか・・・プロジェクト固有の処理が入っているので外部には公開したくない。 かといってプライベートなS3バケットに置くと、ダウンロードに awscli が必要になってしまう・・・。 awscli を使うのは諦めたはずでは・・・という、いわゆる「鶏が先か、卵が先か」問題に陥ってしまいました。
そこでS3からのダウンロードの処理に特化したミニawscliが欲しくなって作成したのが s3cli-mini です。
使い方 現状v0.0.1でサポートしているのは cp コマンドのみです。 S3バケットからファイルをダウンロードしたり、S3バケットへファイルをアップロードしたり、 別のS3バケットへファイルを転送することができます。
# download from a S3 bucket s3cli-mini cp s3://your-bucket/foobar.zip . # upload to a S3 bucket s3cli-mini cp foobar.zip s3://your-bucket/ # copy the file from a S3 bucket to another S3 bucket.</description>
    </item>
    
    <item>
      <title>GoでHTTPとS3を透過的に扱う</title>
      <link>https://shogo82148.github.io/blog/2018/06/09/go-s3-protocol/</link>
      <pubDate>Sat, 09 Jun 2018 07:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/06/09/go-s3-protocol/</guid>
      <description>Goの http.Transport には RegisterProtocol というメソッドが生えていて これを使うと、 HTTP以外のプロトコルを透過的に扱うことができます。 代表的なのは http.NewFileTransport で、これを使うと、file://path/to/file.txt みたいなURLでファイルにアクセスすることができます。 (Goオフィシャルの例) この仕組を使って、S3へのアクセスも透過的にできるようにしてみたので、メモ。
新しいプロトコルを作成するのは非常に簡単です。 http.RoundTripperインターフェースを実装し、リクエストに応答するレスポンスを作ってあげればいいだけです。 S3の場合以下のようになります。(エラー時の扱いが雑だけど・・・)
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/aws/aws-sdk-go/aws&amp;#34; &amp;#34;github.com/aws/aws-sdk-go/aws/session&amp;#34; &amp;#34;github.com/aws/aws-sdk-go/service/s3&amp;#34; ) type s3RoundTripper struct { s3 *s3.S3 } func newS3RoundTripper(session *session.Session) http.RoundTripper { return &amp;amp;s3RoundTripper{ s3: s3.New(session), } } func (rt *s3RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) { host := req.Host if host == &amp;#34;&amp;#34; { host = req.URL.Host } path := req.URL.Path ctx := req.Context() out, err := rt.</description>
    </item>
    
    <item>
      <title>Goの構造体のコピーを防止する方法</title>
      <link>https://shogo82148.github.io/blog/2018/05/16/macopy-is-struct/</link>
      <pubDate>Wed, 16 May 2018 07:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/05/16/macopy-is-struct/</guid>
      <description>去年仕込んだネタが見つかってしまったので、macopy 構造体について一応解説。
https://t.co/mHq6oWY3rj
macopyさん構造体だったのか・・・
&amp;mdash; serinuntius (@_serinuntius) 2018年5月14日  2021-05-25 追記
今はこの方法では動かないというツイートを見かけました。
これで出てくる &amp;quot;Goの文法を使った構造体のコピーを防ぐ方法&amp;quot; が動かなかった話ですが https://t.co/FpEnspIfmN このへんに書いてありました.重要なことはその型がstructであること,Lock だけでなく Unlockも実装されていることでした.https://t.co/zQc6T058Ip このように変更すると検知されました
&amp;mdash; おりさの (@orisano) May 25, 2021  どうやら Go 1.11 から判定基準が 「sync.Locker を実装しているか」に変わっていたようです。 (修正コミット: c2eba53, Issue: #26165)
というわけで、 macopy 構造体を以下のように変更する必要があります。
type macopy struct{} func (*macopy) Lock() {} func (*macopy) Unlock() {} 追記ここまで
目的 深淵な理由で Go の構造体のコピーを禁止したい場合があると思います。 kuiperbelt のケースでは、sync/atomic パッケージを使ってフィールドを更新しているので、 フィールドへの読み書きは必ず sync/atomic パッケージを使わなければなりません。 sync/atomic パッケージを使わずに構造体をコピーするとレースコンディションが発生してしまうので、コピーを禁止する必要がありました。
// https://github.com/kuiperbelt/kuiperbelt/blob/e3c1432ed798716c8e88183518f9126951c227f3/stats.go#L20-L28 type Stats struct { connections int64 totalConnections int64 totalMessages int64 connectErrors int64 messageErrors int64 closingConnections int64 noCopy macopy } // atomic.</description>
    </item>
    
    <item>
      <title>OctopressからHugoに乗り換えた</title>
      <link>https://shogo82148.github.io/blog/2018/04/10/migrate-to-hugo/</link>
      <pubDate>Tue, 10 Apr 2018 07:49:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2018/04/10/migrate-to-hugo/</guid>
      <description>OctopressからHugoに乗り換えました。 以下のような理由からです。
 Rubyの環境をメンテナンスし続けるのが面倒 最近Octopress自体の更新が滞っている ビルド時間が長い  一番最初の理由が大きくて、いつもビルドしていた環境を壊してしまって修復が面倒になってしまいました。 そこでようやく重い腰を上げて移行したというわけです。
移行手順 OctopressからHugoへの移行は先人たちがたくさんいるので、それを参考にします。
# 記事のコピー cp octopress-site/source/_posts/* hugo-site/content/post/ # 画像のコピー cp -r octopress-site/source/images/* hugo-site/static/images/ # 記事のタイムスタンプの形式を変える # Hugoでは、&amp;#34;2016-09-25T15:09:57&amp;#34;のような形式のタイムスタンプでないとパースに失敗します find . -type f -exec sed -i &amp;#34;&amp;#34; -e &amp;#39;s/date: \([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\) \([0-9]\{2\}:[0-9]\{2\}\)$/date: \1T\2:00+09:00/g&amp;#39; {} \; パーマネントリンクを維持するために OctopressからHugoへ移行する方法 のRubyスクリプトを利用させていただきました。
dir = &amp;#39;content/post/&amp;#39; Dir::foreach(dir) do |filename| if filename =~ /\.markdown$/ slug = filename.gsub(/\d{4}-\d{2}-\d{2}-/, &amp;#39;&amp;#39;).sub(&amp;#39;.markdown&amp;#39;, &amp;#39;&amp;#39;) puts &amp;#34;#{filename}: #{slug}&amp;#34; lines = [] File::open(dir + filename) do |f| f.</description>
    </item>
    
    <item>
      <title>Go言語の浮動小数点数のお話</title>
      <link>https://shogo82148.github.io/blog/2017/10/28/golang-floating-point-number/</link>
      <pubDate>Sat, 28 Oct 2017 20:12:48 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/10/28/golang-floating-point-number/</guid>
      <description>元ネタ:
[JavaScriptの問題]
var a = 0.3 - 0.2;
var b = 0.2 - 0.1;
var c = a==b;
cの中身はどれ？
&amp;mdash; RAO(らお)@けもケP-31 (@RIORAO) 2017年10月24日  正確な実数計算をやらされるJavaScriptくん #擬竜戯画 pic.twitter.com/ipE56C2YbV
&amp;mdash; RAO(らお)@けもケP-31 (@RIORAO) 2017年10月26日  コンピューターで浮動小数点数を扱ったことのある人なら一度は経験する、 数学上の計算とコンピューター上の計算が合わない計算の一例ですね。
この件に関して、Go言語では正しく(=数学的な結果と同じように)計算できるとの情報が。
おそらくGoはコンパイラがa=0.1とb=0.1に変換していると思われます。
添付した画像のコードだとtrueになりますが、constをvarに変更するとfalseになります。constはコンパイル時に計算されますが、varは実行時に計算されるためです。 pic.twitter.com/LpKZF2kOjH
&amp;mdash; morikuni (@inukirom) 2017年10月27日  しかしながら、inukiromさんのこの推察、半分はあってますが、半分は間違っていると思います。 なぜGo言語でこのような結果になったのか、検証してみました。
Goの数値定数の型について 以前Go言語でコンパイル時フィボナッチ数列計算で紹介した Better C - Go言語と整数 #golangにもあるように、 Goの定数には「型がない(場合がある)」「任意の精度で計算してくれる」という特徴があります。
このため、普通はどう考えてもオーバーフローしそうなこんな演算も・・・
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var i uint64 = 31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 % 1000000007 fmt.</description>
    </item>
    
    <item>
      <title>ACMのドメイン検証をシミュレートするやつ書いた</title>
      <link>https://shogo82148.github.io/blog/2017/10/22/aws-certification-manager-validation/</link>
      <pubDate>Sun, 22 Oct 2017 15:45:02 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/10/22/aws-certification-manager-validation/</guid>
      <description>始まりは一件のメールから。
 Title: Action Required - Your certificate renewal
Greetings from Amazon Web Services,
You have an AWS Certificate Manager (ACM) provided SSL/TLS certificate in your AWS account that expires on Nov 04, 2017 at 12:00:00 UTC. That certificate has the following domains: example.com, *.example.com
AWS account ID: xxxxxx AWS Region name: us-east-1 Certificate identifier: arn:aws:acm:us-east-1:xxxxxx:certificate/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Therefore, ACM has initiated the process to renew this certificate. You must take the action below before Nov 04, 2017 at 12:00:00 UTC to avoid certificate expiration, which might cause your website to become unreachable.</description>
    </item>
    
    <item>
      <title>Go1.9から使える Monotonic Clocks を試してみた</title>
      <link>https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock/</link>
      <pubDate>Mon, 26 Jun 2017 09:21:42 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock/</guid>
      <description>先日Go1.9beta1がリリースされました。
Go 1.9 Beta 1 is released!
Announcement:https://t.co/lV5nvXwOoR
Get it!https://t.co/2LhlOo2EtX#golang pic.twitter.com/zm09DwX93q
&amp;mdash; Go (@golang) 2017年6月14日   Go 1.9 Release Notes  型エイリアスのサポート、math/bitsパッケージ、 sync.Map型など、 今回のアップデートでも便利そうな機能が追加されます。 詳しくはtenntennさんのGopher Fest 2017参加レポートをどうぞ。
今回のリリースノートを見て、個人的に注目しているのはMonotonic Clocksのサポートです。 他の機能追加はTwitterとかで見かけるけど、 Monotonic Clocksはなぜかあまり見ない・・・。 beta1がでて手軽に試せるようになったので、試してみました。
Monotonic Clocks Go1.8以前で取得していた時刻は「wall clock」といい、現在の正しい時刻を知るために使います。 一方「monotonic clock」は、時間を計るために使うものです。 Go1.9からはtime.Nowで取得できる時刻に「wall clock」と「monotonic clock」が含まれるようになります。
timeパッケージのドキュメントから コード片を引用します。
t := time.Now() ... operation that takes 20 milliseconds ... u := time.Now() elapsed := t.Sub(u) 上のコードで elapsed は 20ms となるはずですが、 実際はそうはならないケースがあります。 具体的には以下のようなケースです。
 ntpdなどによってOSの時刻が変更された場合 うるう秒が挿入・削除された場合  Go1.</description>
    </item>
    
    <item>
      <title>ぼくのかんがえたさいきょうのcontext対応版go-mysql-driverをマージしてもらった</title>
      <link>https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context/</link>
      <pubDate>Fri, 16 Jun 2017 07:11:15 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context/</guid>
      <description>go-sql-driverにcontext.Context対応するプルリクエスト go-sql-driver/mysql#608 を送って取り込んでもらいました！！ 現時点ではまだ正式リリースされていませんが、次のリリース(version 1.4)から使えるようにはずです。 masterブランチではすでに使えるようになっているので、引き続き人柱募集中です。
コネクションプーリングを実装していて、自分も「context.Contextサポートしたい！」というかたのために、 実装の概要をメモとして残しておきます。
おおまかな仕組み  「contextの監視のみを行うgoroutine(以下、watcher goroutine)」をあらかじめ起動しておく 「やりたい処理を実際に実行するgoroutine(以下、executor goritune)」とchannelを経由してcontext.Contextをやり取りする  watcher goroutineがこの実装で一番重要な部分です。
watcher goroutine の実装 一番重要な watcher goroutine の実装例から見てみましょう (実際には細かい最適化などが入るため、マージされたコードとは異なります)。
func (mc *mysqlConn) startWatcher() { // executor goritune と `context.Context` のやり取りをするための channel 	watcher := make(chan context.Context, 1) mc.watcher = watcher // executor goritune で処理が完了したことを知るための channel 	finished := make(chan struct{}) mc.finished = finished // コネクションがCloseされたことを知らせるための channel 	mc.closech = make(chan struct{}) // ここから watcher goroutine 本体 	go func() { for { // executor goritune から `context.</description>
    </item>
    
    <item>
      <title>Re: GoとPythonとGrumpyの速度ベンチマーク</title>
      <link>https://shogo82148.github.io/blog/2017/05/30/grumpy/</link>
      <pubDate>Tue, 30 May 2017 17:53:32 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/05/30/grumpy/</guid>
      <description>GoとPythonとGrumpyの速度ベンチマーク ～Googleのトランスパイラはどれくらい速い？～という記事を拝読したのですが、 もう一歩踏み込んで検証して欲しい・・・。
 並列処理性能が優れているほか、PythonコードからGoのパッケージをPythonモジュールのように呼び出して利用することもできるという特徴がある。
 とGoogle、すごくスケールするPython実行環境をGoで開発から引用しているのに、 この件に全く触れていないんですよね。 Twitterに呟いたってどうせ誰もやってくれない気がするので、自分で試してみました。
環境 この記事を書いている2017年5月30日現在の最新バージョンで検証しました。
 go version go1.8.3 darwin/amd64 CPython 2.7.13 Grumpy d8d01899f5  Grumpyのインストール方法はREADMEにある通り。
make export GOPATH=$PWD/build export PYTHONPATH=$PWD/build/lib/python2.7/site-packages ただ個人的な環境問題としてPythonのバージョン管理に利用しているpyenvとの相性が悪いらしく、 pyenvが管理しているPythonへのパスを直接通す必要がありました。 (これがないとPythonスクリプトがなぜかbashに処理される。なんかこの問題最近Twitterで見たような・・・)
export PATH=$HOME/.pyenv/versions/2.7.13/bin:$PATH モンテカルロ法を並列実行してみる まず、並列処理性能について検証してみましょう。 モンテカルロ法の各試行は独立しているので、並列実行にするのは容易です。 Python2のthreadingモジュールを使って並列実行してみましょう。
コード #coding:utf-8 # モンテカルロ法 Pure Python 並列版 import threading import random import sys class MyThread(threading.Thread): def __init__(self): super(MyThread, self).__init__() self.c = 0 def run(self): r = random.Random() c = 0 for _ in xrange(num): x = r.</description>
    </item>
    
    <item>
      <title>String::RandomのGo移植を書いてみた</title>
      <link>https://shogo82148.github.io/blog/2017/05/04/go-rerand/</link>
      <pubDate>Thu, 04 May 2017 10:57:37 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/05/04/go-rerand/</guid>
      <description>golangkyotoでString::RandomのGo移植についての発表があったと聞き、 これに対抗して以前途中まで書いていたString::RandomのGo移植をちょっといじって公開しました。
 shogo82148/go-rerand  背景 ナイーブな実装の問題点 実はgolangkyoto以前にもGoの正規表現エンジンを使ってランダムな文字列を生成する試みはあって、 たしかにこれは面白そうだと記事を読んでいました。
 「Goの正規表現エンジンを使ってファジング用ツールを書いてみる」  しかし、gocha同様、この実装では文字列の長さが幾何分布に従うため、短い文字が多めにでてしまいます。
% gocha -n 100000 &amp;#39;a*&amp;#39; | sort | uniq -c 50054 24894 a 12633 aa 6278 aaa 2994 aaaa 1517 aaaaa 809 aaaaaa 400 aaaaaaa 206 aaaaaaaa 109 aaaaaaaaa 54 aaaaaaaaaa 22 aaaaaaaaaaa 15 aaaaaaaaaaaa 7 aaaaaaaaaaaaa 4 aaaaaaaaaaaaaa 3 aaaaaaaaaaaaaaa 1 aaaaaaaaaaaaaaaa 正規表現のパターンを数え上げとその問題点 この問題を解決するために 「この先何パターンあるかを調べておけば、正規表現が表す文字列の集合からランダムに文字列を取り出せるのでは？」 と考え、golangkyoto以前からちょこちょこ実装を進め、不完全ながらも一応動作するところまでは書いていたのです。 有向グラフの経路数えあげ問題なので、メモ化再帰を使って頑張れば解けます。 少々面倒ですが、おねえさんの問題と比べれば簡単です。
パターンを数え上げる都合上、組み合わせが無限にある a* ような正規表現は扱えません。 a{1,10} のように明示的に範囲を指定する必要があります。 たとえば a{1,10} は10パターン組み合わせがあるので、20万個ランダムに生成すると、それぞれのパターンがおおよそ2万個ずつ生成されます。 (-d オプションについては後述)</description>
    </item>
    
    <item>
      <title>Go言語のヒープに確保するデータの初期化コストについて調べてみた(Go1.8.1版)</title>
      <link>https://shogo82148.github.io/blog/2017/04/13/go1-8-allocation/</link>
      <pubDate>Thu, 13 Apr 2017 08:23:08 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/04/13/go1-8-allocation/</guid>
      <description>golangで
p := new(Type)
と
p := &amp;amp;Type{}
の使い分けってどうするべきだろう?
&amp;mdash; MURAOKA Taro (@kaoriya) 2017年4月12日  こちらのツイートに対して、以下のベンチ結果が紹介されていました。
 Go言語のヒープに確保するデータの初期化コストについて調べてみた  しかしhnakamur2さんも言及しているように、 これはGo1.2.2時の結果。 その後、GoのコンパイラがGo実装になったり、SSAが導入されたりと、 今のコンパイラの実装は当時とは全く違うものになっています。
というわけで、現時点での最新のバージョン(Go1.8.1)で、同様の検証をおこなってみました。
検証コード 検証に使用したコードはGo1.2.2のときと全く同じものです。
// alloc_overhead.go  package main type container struct { v [64]byte } func MakeContainer() *container { c := container{} return &amp;amp;c } func MakeContainerOneLine() *container { return &amp;amp;container{} } func MakeContainerNew() *container { return new(container) } func main() { _ = MakeContainer() _ = MakeContainerOneLine() _ = MakeContainerNew() } // alloc_overhead_test.</description>
    </item>
    
    <item>
      <title>Go言語のchanはいったいいくつ付けられるのか試してみた</title>
      <link>https://shogo82148.github.io/blog/2017/03/17/how-many-chan-can-i-write-in-golang/</link>
      <pubDate>Fri, 17 Mar 2017 21:10:25 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/03/17/how-many-chan-can-i-write-in-golang/</guid>
      <description>pecoに入った修正をみて、果たしてchanはいくつまで付けられるのか気になったので、 雑に試してみました。 先に断っておきますが、全く有用ではないですよ。
背景 pecoに入った修正はこちら(一部抜粋)。
 Make Resume a blocking operation #411  diff --git a/interface.go b/interface.go index 3d4472f..fff446c 100644 --- a/interface.go +++ b/interface.go @@ -162,8 +162,8 @@ type Screen interface {  // Termbox just hands out the processing to the termbox library type Termbox struct { mutex sync.Mutex -	resumeCh chan (struct{}) -	suspendCh chan (struct{}) +	resumeCh chan chan struct{} +	suspendCh chan struct{}  } // View handles the drawing/updating the screen diff --git a/screen.</description>
    </item>
    
    <item>
      <title>HTTP/WebSocketで時刻同期するWebNTPを書いた</title>
      <link>https://shogo82148.github.io/blog/2017/03/11/go-webntp/</link>
      <pubDate>Sat, 11 Mar 2017 18:48:09 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/03/11/go-webntp/</guid>
      <description>Go1.8からhttp/httpgtraceが追加され、 HTTP通信にフックを差し込めるようになりました。 以前触った時はパフォーマンス測定に利用しましたが、 他に面白い活用法はないかとWebNTPというのを作ってみました。
 webntp  HTTP/HTTPS/Websocket上でNTP(Network Time Protocol)っぽいことをするプログラムです。
HTTP/HTTPSで時刻同期 日本標準時はNICTの管理する原子時計が基準になっており、 NICTでは原子時計に直結したNTPサーバー(ntp.nict.jp)の提供を行っています。 それに加えて、https/httpサービスも提供しており、 ブラウザを使って現在時刻を取得できます。
APIは簡単でミリ秒単位のtimestampを返してくれるだけです。 その情報からサーバーとクライアント間の時間のズレを算出するわけですが、 HTTP通信では、DNSの名前解決、TCPハンドシェイク、TLSハンドシェイク等々の時間が入ってしまうため、 正確なズレを求めることは困難です。
そこでhttp/httpgtraceを使って、ハンドシェイクを除いたリクエストの送信時刻、レスポンスを最初に受信した時刻から、 より正確なズレを知ることができるのではと作ったのがWebNTPです。 NICTのJSON形式のAPIに対応しており、 以下のように時刻を取得できます。
$ go get github.com/shogo82148/go-webntp/cmd/webntp $ webntp https://ntp-a1.nict.go.jp/cgi-bin/json server https://ntp-a1.nict.go.jp/cgi-bin/json, offset -0.006376, delay 0.024411 2017-03-11 16:08:06.150393313 +0900 JST, server https://ntp-a1.nict.go.jp/cgi-bin/json, offset -0.006376 WebNTPはNICTのAPIと同様の内容を返すサーバーにもなれます。 本家のフォーマットにしたがい、しっかりとうるう秒の情報も返すようになっているので、 ntpdのSLEWモードを切った状態でお試しください。
$ webntp -serve :8080 $ curl -s http://localhost:8080/ | jq . { &amp;#34;id&amp;#34;: &amp;#34;localhost:8080&amp;#34;, &amp;#34;it&amp;#34;: 0, &amp;#34;st&amp;#34;: 1489217288.328757, &amp;#34;time&amp;#34;: 1489217288.328757, &amp;#34;leap&amp;#34;: 36, &amp;#34;next&amp;#34;: 1483228800, // 今年の1/1にあったうるう秒の情報 &amp;#34;step&amp;#34;: 1 } ところで、URLにcgi-binが入っているのは、過去との互換性を保つためにそうなっているのか、 今もCGIで動いているのか、気になる・・・ (少なくとも初期実装はPerlのCGIだったみたいですね)。</description>
    </item>
    
    <item>
      <title>go-JSONStoreの高速化と機能追加</title>
      <link>https://shogo82148.github.io/blog/2017/03/05/tune-up-go-jsonstore/</link>
      <pubDate>Sun, 05 Mar 2017 16:19:25 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/03/05/tune-up-go-jsonstore/</guid>
      <description>以前mattnさんが紹介していたschollz/jsonstore。 時間が経ってしまいましたが「ここは高速化できそうだなー」といじってみたので、 やってみたことをメモ。
本来は上流にフィードバックしたほうがよいのですが、 本家のほうも修正が入ってコンフリクトして面倒になったので、 フォーク版をそのまま置いておきます。
 shogo82148/jsonstore  高速化 まだまだ高速化できそうなところがあったので、いじってみた部分です。
ロックの範囲を最小にする ロックの範囲を小さくすることで、並列処理時の性能が上がります。 例えば、jsonstoreに値を入れるSetメソッドは、 以下のようにSet全体がロックの対象になっていました。
func (s *JSONStore) Set(key string, value interface{}) error { // Set の中全体がロックの対象になっている 	s.Lock() defer s.Unlock() b, err := json.Marshal(value) if err != nil { return err } if s.data == nil { s.data = make(map[string]*json.RawMessage) } s.data[key] = (*json.RawMessage)(&amp;amp;b) return nil } jsonのエンコード処理はjsonstoreの中身を触らないので並列実行可能です。 次のように s.data だけをロックの対象にすれば十分です。
func (s *JSONStore) Set(key string, value interface{}) error { // json.</description>
    </item>
    
    <item>
      <title>Redisを使ってユニークなIDを配布する</title>
      <link>https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis/</link>
      <pubDate>Sun, 26 Feb 2017 19:37:45 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis/</guid>
      <description>スケーラブルにIDを生成する方法として Twitterのsnowflakeが有名です。 1024台までスケールすることが出来ますが、各snowflakeのサーバにユニークなWoker IDを割り振る必要があります。 IDを振るためのサーバにIDを振るのが問題になるとは難しいですね。
各snowflakeサーバにIDを振る親玉Worker ID配布サーバを作るというアイデアはあったのですが、 Worker IDサーバの可用性を考えるのが大変で手を付けていませんでした。 最近になってWorker IDサーバとしてRedisを使い、ソート済みセット型で管理すれば楽できるのでは？ と思いついたので、やってみたというお話です。
概要 レポジトリはこちらです。
 shogo82148/yaraus  他のsnowflake-likeなID発番サーバの実装として katsubushiや sonyflakeなんていうのもあります。 これらのID発番サーバにRedisを使ってWorker IDを割り振るコマンドです。 Redis3.2以上推奨です。
使い方 Go製なのでgo getでインストールできます。
go get github.com/shogo82148/yaraus/cmd/yaraus # 1から1023までのIDが使えるようにRedisを初期化 $ yaraus init -min 1 -max 1023 # ユニークなIDが必要な処理を実行する $ yaraus run -- echo {} 2017/02/25 17:19:16 getting new id... 2017/02/25 17:19:16 client id: YourHostName-1488010756.738-1, id: 1 2017/02/25 17:19:16 sleep 2s for making sure that other generates which has same id expire.</description>
    </item>
    
    <item>
      <title>Rust vs Go の終戦へ向けてPolyglotを作ってみた</title>
      <link>https://shogo82148.github.io/blog/2017/02/25/rust-and-go-ploygolot/</link>
      <pubDate>Sat, 25 Feb 2017 16:58:27 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/02/25/rust-and-go-ploygolot/</guid>
      <description>「Golang Rust」とググると、関連項目は「Rust vs Go」のように GolangとRustが対立しているような項目ばかりです。 まあまあ、もっと仲良くやろうじゃないですか、ということで、 どうしたら仲良くなれるかを考えました。 Polyglotにして同じソースコードの中に閉じ込めてやれば、 そのうち仲良くなるのではないかと考え、 RustとGoのPloyglotを作ってみました。
結果 /*/*/ package main import &amp;#34;fmt&amp;#34; func main() { fmt.Print(&amp;#34;Hello Go!!&amp;#34;) _ = `*/*/fn main(){println!(&amp;#34;Hello Rust!!&amp;#34;);//` }/*/*/ package main import &amp;#34;fmt&amp;#34; func main() { fmt.Print(&amp;#34;Hello Go!!&amp;#34;) _ = `*/*/ fn main() { println!(&amp;#34;Hello Rust!!&amp;#34;); //` } 仕組み 一番のポイントは最初の行の /*/*/ です。 RustもGoも/* */形式の複数行コメントに対応していますが、 Rustはネストに対応しており、Goはネストはできないという違いがあります。 この違いにより、Rustは/*/*/を/* /* /のように「二重にネストしたコメントの開始部分」として扱いますが、 Goは/* / */のように「/をコメントアウトしたもの」と見なします。 これにより2行目package main以降はGoには普通のコードに見えますが、 Rustからは単なるコメントとして認識されます。
次はGoからRustへの切り替えです。 Goではバッククオートで複数行文字列を定義できるので、その中にRustのコードを書きます。 この中ではバッククオートさえ使わなければ自由にRustのコードを書くことが出来るので、 あとはGoのコードだけ上手くコメントアウトされるよう調整すれば完成です。
せっかくなのでリンクしてみた GoからRustのコードを呼び出すサンプルコードを見つけたので、 せっかくなのでリンクしてみました。
 medimatrix/rust-plus-golang  main.</description>
    </item>
    
    <item>
      <title>Go言語でコンパイル時フィボナッチ数列計算</title>
      <link>https://shogo82148.github.io/blog/2017/02/19/golang-compile-time-fib/</link>
      <pubDate>Sun, 19 Feb 2017 09:06:05 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/02/19/golang-compile-time-fib/</guid>
      <description>整数の公式でフィボナッチ数列を求めるという記事を読んで、 「これコンパイル時ならGoでも簡単に計算できるのでは？」と思いやってみたメモ。
背景 みんな大好きフィボナッチ数列(要出典)。 漸化式で定義されているため、再帰やループを使って書くことが多いと思いますが、 閉じた式で書くことが知られています。 ただし、この一般式には無理数の演算が入るので、コンピュータで厳密に扱うことはできません。 ところが、さきほど紹介した記事で紹介された方法を使うと、整数の演算のみで実現できるそうです。
原理などはネタ元の記事を参照してもらうとして、 Python3では以下のように書けるらしいです。
def fib(n): return (4 &amp;lt;&amp;lt; n*(3+n)) // ((4 &amp;lt;&amp;lt; 2*n) - (2 &amp;lt;&amp;lt; n) - 1) &amp;amp; ((2 &amp;lt;&amp;lt; n) - 1) ある程度大きなフィボナッチ数を求める場合、 計算途中の値が非常に大きくなるため、多倍長整数が必要となります。 Python3は多倍長整数に組み込みで対応していますが、 Goではmath/bigパッケージを利用する必要があります。
なんか面倒だなGolangと思っていたのですが、 Better C - Go言語と整数 #golangを読んで、 「Goの定数には型がない(場合がある)」「任意の精度で計算してくれる」ということを知り、 「つまりコンパイル時に定数として計算すれば楽にいけるのでは！！」と考えたわけです。
結果 ちょっと複雑な式ですが、個々の演算自体はPython3もGoも変わらないので、 翻訳は簡単ですね。
package main import &amp;#34;fmt&amp;#34; const Fib0 = 1 // 0だけはうまくいかない  const ( _ = (4 &amp;lt;&amp;lt; (iota * (3 + iota))) / ((4 &amp;lt;&amp;lt; (2 * iota)) - (2 &amp;lt;&amp;lt; iota) - 1) &amp;amp; ((2 &amp;lt;&amp;lt; iota) - 1) Fib1 Fib2 Fib3 Fib4 Fib5 Fib6 Fib7 Fib8 Fib9 Fib10 Fib11 Fib12 Fib13 Fib14 Fib15 Fib16 Fib17 Fib18 Fib19 Fib20 Fib21 ) func main() { fibs := []int{ Fib0, Fib1, Fib2, Fib3, Fib4, Fib5, Fib6, Fib7, Fib8, Fib9, Fib10, Fib11, Fib12, Fib13, Fib14, Fib15, Fib16, Fib17, Fib18, Fib19, Fib20, Fib21, } for i, fib := range fibs { fmt.</description>
    </item>
    
    <item>
      <title>go-sql-proxyがcontextに対応しました</title>
      <link>https://shogo82148.github.io/blog/2017/02/16/go-sql-proxy-in-go18/</link>
      <pubDate>Thu, 16 Feb 2017 07:16:44 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/02/16/go-sql-proxy-in-go18/</guid>
      <description>Go1.8ではdatabase/sqlのcontextサポートが入ります。 (きっと今日のGo 1.8 Release Partyで詳しく説明があるはず、たぶん) それにともないGo言語でSQLのトレースをするで紹介した shogo82148/go-sql-proxyでもcontextを扱えるようにしました。
Go1.8新機能のサポート Golang 1.8 でやってくる database/sql の変更点で mattnさんが紹介しているように、Go1.8ではdatabase/sqlにいくつか新機能が追加されます。 (mattnさんの対応が早すぎて、メソッド名とか微妙に変更が入っているので注意)
特に大きなのがcontextのサポートでしょう。以下のようなコードでクエリのキャンセルが可能になります。
ctx, cancel := context.WithCancel(context.Background()) go func() { // 1秒待ってからキャンセル  time.Sleep(1 * time.Second) cancel() }() rows, err := db.QueryContext(ctx, &amp;#34;SELECT name FROM test where id = ?&amp;#34;, id) if err != nil { log.Fatal(err) } go-sql-proxyでもcontext対応を行ったので、 proxyを経由した場合でも、キャンセルが可能になります。 (もちろん、originとなるドライバの対応も必要です)
Go1.8ではcontextサポート以外にもいくつか新機能が追加される予定です。 これらについても、originとなるドライバが対応していれば、go-sql-proxy経由でも全く同じように扱えます。
contextとHookの関連付け contextにHookを関連付けて、一部のクエリにだけHookを付けることができるようになりました。 例えば以下のようなコードでctxに関連したクエリだけログを出力できます。
package main import ( &amp;#34;context&amp;#34; &amp;#34;database/sql&amp;#34; &amp;#34;github.com/shogo82148/go-sql-proxy&amp;#34; ) var tracer = proxy.</description>
    </item>
    
    <item>
      <title>Go1.8のGraceful Shutdownとgo-gracedownの対応</title>
      <link>https://shogo82148.github.io/blog/2017/01/21/golang-1-dot-8-graceful-shutdown/</link>
      <pubDate>Sat, 21 Jan 2017 12:44:32 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/01/21/golang-1-dot-8-graceful-shutdown/</guid>
      <description>Go1.8beta1が出た時に、Go1.8で追加される予定のGraceful Shutdownについて書く！ とTwitterに書き込んで早1ヶ月。 この前の金曜日にGo1.8rc2がリリースされ、正式リリースも間近になってきて、 さすがに書かねばという気持ちになって来たので、がんばって検証してみます。
公式サポートで増える予定の機能 以前Go言語でGraceful Restartをするときに取りこぼしを少なくするで 紹介したようにshogo82148/go-gracedownというものを書きました。 あれから時は経ち、ついにGo1.8からはGraceful Shudownがbuild-inの機能として提供される予定です。 公式サポートが入ることによって、以下のような機能を使えるようになります。
HTTP/2のGraceful Shutdownができる HTTP/2ではGOAWAYフレームという接続を切ることを通知する機能があります。 Go1.8からはシャットダウン時にこのGOAWAYフレームを送ってくれるようになります。 GOAWAYフレームはサーバ側から任意のタイミングで送ることができ、 どこまで正常に処理できたかをクライアントに伝えられるという利点があります。
余談ですが、この機能はx/net/http2を利用している場合は動かないらしいです。 importしたときには動かないけどbundleしたときにだけ動く黒魔術が使われているためです。 覚えておいても今後絶対使うことはなさそう。というか使いたくない・・・。
contextが使える go-gracedownを作った頃は、contextはまだ標準パッケージに取り込まれていなかったので対応していませんでした。 (1.7のリリース時に対応を怠っていただけとも言える) net/httpのシャットダウンはもちろんcontextに対応しています。 これにより、Graceful Shutdownを中断して強制終了する、 ということが簡単にできるようになります。
公式サポートで変更になる予定の挙動 Keep-Aliveでのリクエストの挙動が少し変わります。 1.7以前のgo-gracedownでは、クライアントにKeep-Aliveが無効になったのを伝え、 クライアント側から接続を切るのを待つように実装してしました。 多少接続時間が延びたとしてもクライアント側でよくわからないエラーになるよりはマシだろ、との考えからです。
1.8からはシャットダウン時にIdle状態(TCP接続は有効だけど、リクエストは処理していない状態)な接続は切断されます。 内部で使っているServer.SetKeepAlivesEnabledの 挙動が変更になったためです。
Goの中の人的には「この挙動が原因で万が一トラブルになっても、クライアントがリトライしてくれるから大丈夫でしょ」とのことのようです。 サーバシャットダウン以外にもネットワークトラブル等でも接続は切れるので、 クライアント側で頑張ってというのは正論ですが、 どの程度エラーが増えるのかは気になるところです。
go-gracedownの対応 go-gracedownはGo1.8でコンパイルされたときはbuild-inの機能を直接使うようになります。 中身はほとんどがインターフェースの互換性を保つためのコードなので、 機能的なメリットは完全になくなってしまいました・・・。 HTTP/2サポートも問題なく動くはずです。 逆にパッケージの依存が増えること以外はデメリットはないともいえます。
Go1.7以下では今までの方法にフォールバックしてくれます。 というわけで、以下のような人には有用です。
 深淵な理由でGo1.7以下しか使えない人 Go1.8とGo1.7以下のサポートがどうしても必要な人 Go1.8にアップグレードしたけど、graceful shutdownの処理を書き換えるのがめんどくさい人  ところで、環境が悪いときに性能を落としたり機能を制限することをフォールバック(fall back)というわけですが、 逆に環境が良いときに性能を上げたり機能を拡張することはなんていうんですかね？ モデムでは通信環境が良いときに高速な通信方式に切り変えることを「フォールフォワード(fall forward)」というらしいです。 「Go1.8ではbild-inのGraceful Shutdownにフォールフォワードする」で使い方あってます？
使い方 Server.Shutdownを使う Go(その3) Advent Calendarの 最終日の記事でも扱ってますが改めて。
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Re:golang の http.Client を速くする</title>
      <link>https://shogo82148.github.io/blog/2017/01/14/re-golang-dns-cache/</link>
      <pubDate>Sat, 14 Jan 2017 17:02:12 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2017/01/14/re-golang-dns-cache/</guid>
      <description>先日mattnさんの記事を読みました。
 golang の http.Client を速くする  nettというパッケージを使って 名前解決の結果をキャッシュすることで、http.Clientを早くするというものです。 この記事に関して、ちょっと疑問に思ったことがあったので、検証してみました。
疑問 疑問に思ったのは以下の点です。
名前解決遅すぎでは？ ベンチマークの結果を見ると5億ns(=500ms)ほど速度が改善しています。 3つのURLに対してリクエストを投げているので、初回を除く2回DNSのキャッシュがヒットし、 名前解決2回分の速度改善になるはずです。 と、いうことは、名前解決1回あたり250msかかっている計算になります。 googleのsearchは302でリダイレクトがかかるので、Client.Getの呼び出し1回あたり2回リクエストが飛ぶ、 ということを計算に入れても100msほどかかる計算です。
Google先生の謎テクノロジーによってかなりの最適化がされているはずですし、 ネットワークプロバイダのDNSキャッシュにヒットする可能性も高いでしょう。 名前解決程度にこんなに時間がかかっていたらスプラトゥーンが出来ない！ (mattnさんがスプラトゥーンをプレイしているかは知らない)
2017/01/16追記: mattnさんはスプラトゥーンをプレイしていないそうです。残念。
あとスプラトゥーンしてません。。。
&amp;mdash; mattn (@mattn_jp) 2017年1月14日  もちろん、ネットワークが混雑していたり、 モバイルネットワークを利用していたり、という可能性もありますが、 ちょっと不自然な印象を受けました。
Keep-Aliveされてるのでは？ スキーマがhttpsになっているので、Google先生相手ならHTTP2で通信していてもおかしくありません。 HTTP2は基本的にドメイン毎にコネクションを1つだけ張って、それを使いまわします。 もし仮にHTTP1.1で通信していたとしても、http.ClientはデフォルトでKeep-Aliveが有効になっているので、 普通に使うとコネクションを再利用してくれます。
そういうわけで、名前解決以前にそもそもTCPのコネクション確立もスキップされている可能性が高いのでは？ と思ったわけです。 この予想が正しければ、名前解決は初回リクエストでしか行われないので、ベンチマークに差はでないはずです。
HTTPリクエストの様子をトレースしてみる これらの疑問を解消するために、HTTPリクエストの様子をさらに詳細に解析してみることにしました。
DNSキャッシュなし版をトレースする Go1.7からnet/http/httptraceというパッケージが追加され、 名前解決やコネクション確立etcのタイミングにフックを仕込めるようになりました。 これを利用すれば各段階でどの程度時間がかかっているかが具体的に分かるはずです。
頑張って自前でフックを差し込んでもよいのですが、 deeeetさんのgo-httpstatという便利パッケージがあるので、 これをありがたく利用させていただきます。 go-httpstatを使うと時間計測を行うコードを簡単に差し込むことができます。
package main import ( &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/tcnksm/go-httpstat&amp;#34; ) var ( urls = []string{ &amp;#34;https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/&amp;#34;, &amp;#34;https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/&amp;#34;, &amp;#34;https://shogo82148.</description>
    </item>
    
    <item>
      <title>net/httpで安全に静的ファイルを返す</title>
      <link>https://shogo82148.github.io/blog/2016/04/13/serving-static-files-in-golang/</link>
      <pubDate>Wed, 13 Apr 2016 02:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/04/13/serving-static-files-in-golang/</guid>
      <description>net/httpで静的ファイルを返すで、 http.ServeFileを使っていてアレ？と思ったのでちょっと詳しく調べてみました。 (http.FileServerを使うものだと思ってたため)
結論だけ先に書いておくと
 やはり、特に理由がなければhttp.FileServerを使ったほうが良さそう どうしてもhttp.ServeFileを使う場合は定数でパス指定をする 「自作パスルータを使っている」かつ「Go 1.6.1 未満を使っている」場合はとくに要注意  ディレクトリトラバーサル脆弱性 紹介されているのは以下のコードです。
http.HandleFunc(&amp;#34;/static/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) }) しかし、参照先の「Go Golang to serve a specific html file」には Actually, do not do that. (やっちゃいけない)とコメントされています。 ディレクトリトラバーサルにより 脆弱性の原因となってしまう可能性があるためです。
脆弱性再現のために、以下の様なコードを書いてGo1.5でコンパイルして実行してみました。
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;strings&amp;#34; ) func main() { http.ListenAndServe(&amp;#34;:3000&amp;#34;, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if strings.HasPrefix(r.URL.Path, &amp;#34;/static/&amp;#34;) { http.ServeFile(w, r, r.URL.Path[1:]) } else { http.NotFound(w, r) } })) } .</description>
    </item>
    
    <item>
      <title>PerlでもGoでも実行できるQuine書いた</title>
      <link>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/</link>
      <pubDate>Wed, 06 Apr 2016 10:07:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/</guid>
      <description>昨日のPolyglotを元にPerlでもGoでも実行できるQuine書いた。
package main;import(&amp;quot;fmt&amp;quot;);var(q=`printf&#39;package main;import(&amp;quot;fmt&amp;quot;);var(q%c%c%s%c/*%c);sub import{}sub var{$_%cshift%c~s!%c(.*)%c/\*!$1!gr;eval}%c__END__%c&#39;,61,96,$_,96,61,61,61,96,96,10,10;print&amp;lt;DATA&amp;gt;`/*=);sub import{}sub var{$_=shift=~s!`(.*)`/\*!$1!gr;eval} __END__ */);func main(){s:=`package main;import(&amp;quot;fmt&amp;quot;);var(q=%c%s%c/*=);sub import{}sub var{$_=shift=~s!%c(.*)%c/\*!$1!gr;eval} __END__ */);func main(){s:=%c%s%c;fmt.Printf(s,96,q,96,96,96,96,s,96)} `;fmt.Printf(s,96,q,96,96,96,96,s,96)} Perlで実行してもGoで実行しても自分自身を出力します。</description>
    </item>
    
    <item>
      <title>PerlとGolangで実行できるPolyglot書いてみた</title>
      <link>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/</link>
      <pubDate>Tue, 05 Apr 2016 12:27:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/</guid>
      <description>Rubyの会社をPerlの会社に変えてしまおう計画。 Golangのフリをして忍び込ませれば行けるのではという話になったので、 GoでもPerlでも実行できるコードを書いてみた。
出来上がったのがこちら。
package main; import (&amp;#34;fmt&amp;#34;); var (s=0/*==); sub import {} sub var { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { fmt.Println(&amp;#34;Hello macotasu&amp;#34;) } 一番のポイントはvar (s=0/*==);の行ですね。 Perlで解釈すると正規表現置換s///として解釈され、/*が無視されます。 Goで解釈すると変数sへの代入として解釈され、/*がコメントとして扱われます。
あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。
 package main はGoでもPerlでも似たような意味で解釈されるのでそのまま Goの import, var はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする 省略可能なセミコロンをちゃんと書く  GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、 import だけGoでもPerlでも解釈されてしまうというという制限があります。 import するパッケージが一個だけなら問題ないんですが、 複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。 (Perlでは文字列結合として解釈される。Goではvarのあとにimportかけないっぽいので、ここに押し込むしかない。)
package main; import ( &amp;#34;fmt&amp;#34; . &amp;#34;math&amp;#34; ); var (s=0/*==); sub import {} sub var { print &amp;#34;Hello macotasu&amp;#34;; } __END__ */) func main() { fmt.</description>
    </item>
    
    <item>
      <title>数値と文字列がごちゃ混ぜになっているJSONをよしなにParseするやつ作った</title>
      <link>https://shogo82148.github.io/blog/2016/03/23/go-weaktyping/</link>
      <pubDate>Wed, 23 Mar 2016 20:44:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/03/23/go-weaktyping/</guid>
      <description>Goは数値と文字列を厳格に区別しますが、他の言語もそうとは限りません。 例えばPerlは数値と文字列を自動変換してくれるので、気をつけていないといつの間にか数値が文字列になっていたりします。 その言語の中に閉じていいれば問題ないのですが、Goとやり取りしようとすると困ります。 そんなときに使えるライブラリを書いてみました。
 shogo82148/go-weaktyping  背景 map[string][]*stringを返してくるライブラリがあって、 そのままだと扱いにくいのでなんとか構造体にできないかと頭を悩ませていました。 JSONに一旦変換すれば楽かなーとも思ったのですが、一部フィールドを数値に変換する必要がありました。 JSONの数値と文字列を区別するため、JSONの文字列をGoの数値型に変換するのは厄介です。 タグにjson:&amp;quot;,string&amp;quot;と指定すると変換可能になりますが、逆にJSONの数値を受け付けなくなりますし、 JSONに変換すると文字列になってしまいます。 変換先の構造体は普通のJSONの操作にも使いたかったので、これでは困ります。 「数値も文字列もUnmarshalできて、Marshalするときには数値になる」ようなJSONライブラリが必要でした。
&amp;quot;encoding/json&amp;quot;に代わる新しいJSONライブラリを・・・とも考えたのですが、 よく考えるとUnmarshal時の挙動は&amp;quot;encoding/json&amp;quot;.Unmarshalerインターフェースを実装することでカスタマイズ可能です。 こうして作ったのが go-weaktyping です。
使い方 builtinの型の先頭を大文字にしたものを用意しているので、 適当にUnmarshalして欲しいところでbuiltinの型の代わりに指定するだけです。 以下は整数型をUnmarshalする例です。
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;github.com/shogo82148/go-weaktyping&amp;#34; ) func main() { ptr := &amp;amp;struct { Foo weaktyping.Int `json:&amp;#34;foo&amp;#34;` }{} if err := json.Unmarshal([]byte(`{&amp;#34;foo&amp;#34;:123}`), ptr); err != nil { log.Fatal(err) } fmt.Println(&amp;#34;Foo:&amp;#34;, ptr.Foo) if err := json.Unmarshal([]byte(`{&amp;#34;foo&amp;#34;:&amp;#34;456&amp;#34;}`), ptr); err != nil { log.Fatal(err) } fmt.Println(&amp;#34;Foo:&amp;#34;, ptr.</description>
    </item>
    
    <item>
      <title>ngrokみたいなHTTPプロキシを書いてみた</title>
      <link>https://shogo82148.github.io/blog/2016/03/14/http2-over-websocket/</link>
      <pubDate>Mon, 14 Mar 2016 22:59:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/03/14/http2-over-websocket/</guid>
      <description>開発中のWebアプリをみんなに試してほしいけど、 サーバなんてなくて開発環境がローカルにしか無くて公開できないということは、 開発初期段階だとよくあることだと思います。 もちろん本格的にやるならテスト用にサーバを建てるべきですが、 小さなものならngrokを使うと簡単です。 ngrokの公開サーバへのHTTPリクエストをローカルにリレーして、 ローカルのサーバをお手がるに公開できるサービスです。
びっくりするほど簡単に公開できて便利ですが、 一応oAuthで制限とかかけたいなーとかカスタマイズしてみたくなってきたので、 似たようなものを自作できないかといろいろ遊んでみました。
その結果、HTTP2 over Websocketみたいな謎なものが出来上がってしまったというお話です。
HTTP2 over Websocketというアイデア ngrokっぽいものを実現するためには、 サーバが受け取ったHTTPリクエストをローカルの環境に転送する必要があります。 ご存知のとおり通常のHTTPではサーバ側からのプッシュ配信が難しいので、Websocketを使うのが良さそうです。 しかし、複数のコネクションで並列にやってくるHTTPリクエストを、一本のWebsocketに束ねる必要があり、 上手く制御するのは大変そうです。
さて、HTTP2は一つのTCPコネクションで複数のリクエストを並行処理する仕様があります。 「複数のリクエストを一本に束ねる」という点ではなんか似ているので、なんだか流用できそうな気がしてきました。 Golangならきっと上手いことinterfaceを実装すれば、なんとかできるのではとやってみました。
実装 HTTP2は暗号化や複雑なフロー制御を行っていますが、 外から見ればnet.Connインターフェースに読み書きしている何かに過ぎません。 そして、websocket.Connもnet.Connを実装しているので、そのままHTTP2のライブラリに渡せるはずです。
そうしてできたのが以下のサーバです。
package main import ( &amp;#34;errors&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/http/httputil&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;golang.org/x/net/http2&amp;#34; &amp;#34;golang.org/x/net/websocket&amp;#34; ) type transport struct { m sync.Mutex t http.RoundTripper closed chan struct{} } var t *transport func main() { t = &amp;amp;transport{} s := websocket.Server{Handler: websocket.Handler(Handler)} http.Handle(&amp;#34;/&amp;#34;, s) go http.ListenAndServe(&amp;#34;:3000&amp;#34;, nil) http.</description>
    </item>
    
    <item>
      <title>nginx-omniauth-adapterのGolangポート作った</title>
      <link>https://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter/</link>
      <pubDate>Thu, 10 Mar 2016 12:51:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter/</guid>
      <description>「nginx で omniauth を利用してアクセス制御を行う」という記事で、 ngx_http_auth_request_moduleの存在を知ったので、 Golangでnginx_omniauth_adapterと似たようなものを作ってみました。
 shogo82148/go-nginx-oauth2-adapter  背景 typester/gateは単体でも動くようになっていますが、 例えばIP制限などちょっと高度なことをしたい場合には結局nginxを前段に置く必要があります。 nginxとgateの設定を同時にいじる必要があって煩雑だと感じていました。
そんな中「nginx で omniauth を利用してアクセス制御を行う」という記事で、 ngx_http_auth_request_moduleの存在を知りました。 gateが認証＋Proxyをやってしまうのに対して、認証だけRubyのomniauthモジュールで行いProxyはnginxに任せるという方法です。
以前から記事の存在は知っていたのですが、Rubyの実行環境をそろえるのが億劫で手を出せずにいました。 小さなアプリなので自分の慣れた言語で実装しても大したことないのではと思い、Goで実装してみることにしました。
使い方 go getで落として来れます。 最低限client_idとclient_secretの指定が必要です。 nginx_omniauth_adapterと同じ環境変数名で設定できるほか、YAML形式の設定ファイルを読みこませることができます。 YAMLの形式はREADMEを参照してください。
$ go get github.com/shogo82148/go-nginx-oauth2-adapter/cli/go-nginx-oauth2-adapter $ export NGX_OMNIAUTH_GOOGLE_KEY=YOUR_CLIENT_ID $ export NGX_OMNIAUTH_GOOGLE_SECRET=YOUR_CLIENT_SECRET $ go-nginx-oauth2-adapter $ go-nginx-oauth2-adapter -c conf.yaml # 設定ファイルでの指定も可能 PerlでHTTPサーバ書いているひとにはおなじみのServer::Starterにも対応しているので、 それ経由で立ち上げておくと設定の更新・プログラム自身の更新等が楽になると思います。
start_server --port 18081 -- go-nginx-oauth2-adapter -c conf.yaml nginx側の設定はexamplesディレクトリを参照してください。 ヘッダ名・パス名等を合わせてあるので、nginx_omniauth_adapterと同じ設定で動くはずです。
また、h2oの設定はプログラマブルだからh2oでもちゃんと設定ファイルを書けば動くのではと考え、 h2oの設定も書いてみました。 mrubyからproxyに渡るリクエストを書き換える方法がない(？)っぽいので、アプリ側で認証情報をとることはできないですが、一応制限はできます。 basic認証の実装を見る限りremote-userヘッダだけは渡せるようなので、これを使えばなんとかなるかもしれないですが、未確認です。 (Ruby慣れてないからってGoで実装したけど、結局Rubyを書いていて面白い)
nginx_omniauth_adapterとの違い 厳密に同じ挙動を実装するのが面倒だったため、挙動に若干の違いがあります。 一番大きなものは認証後のリダイレクト先です。
nginx_omniauth_adapterは認証後、一度adapterのURLにリダイレクトしてから、アプリサーバの/_auth/callbackにリダイレクトします。 それに対してgo-nginx-oauth2-adapterは認証後、アプリサーバの/_auth/callbackに直接リダイレクトします。 この違いのため、Google Developers Consoleの「承認済みのリダイレクト URI」に設定するべきURIが異なることに注意してください。 nginx_omniauth_adapterはadapter自身のURI、go-nginx-oauth2-adapterはアプリサーバの/_auth/callbakを指定します。</description>
    </item>
    
    <item>
      <title>MeCabのGolangバインディングを書いてみた</title>
      <link>https://shogo82148.github.io/blog/2016/02/11/golang-mecab-binding/</link>
      <pubDate>Thu, 11 Feb 2016 19:32:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2016/02/11/golang-mecab-binding/</guid>
      <description>GolangからMeCabを呼び出すライブラリ探せばあるにはあるのですが、 なんだかどれもメモリ管理がちょっと怪しいんですよね・・・。
 GolangでMeCabを使う。  yukihir0/mecab-go   Go言語から mecab を使う - Qiita  rerofumi/mecab   Go で Mecab を使ってみた  メモリ管理はbluele/mecab-golangが一番しっかりしているっぽいですが、 libmecabの一番高機能だけど面倒な使い方しか対応していなくて、ちょっとカジュアルに遊ぶにはつらい。
というわけで、カジュアルな用途から高度な使い方まで対応したWrapperを書いてみました。
 shogo82148/go-mecab  使い方 READMEとgodocのexamplesからのコピペになってしまいますが、 簡単に使い方の紹介です。
インストール go getで取ってくることはできますが、事前にlibmecabとリンクするための設定が必要です。
$ export CGO_LDFLAGS=&amp;#34;-L/path/to/lib -lmecab -lstdc++&amp;#34; $ export CGO_CFLAGS=&amp;#34;-I/path/to/include&amp;#34; $ go get github.com/shogo82148/go-mecab mecabコマンドと一緒にmecab-configがインストールされているはずなので、 それを使うのが楽でしょう。
$ export CGO_LDFLAGS=&amp;#34;`mecab-config --libs`&amp;#34; $ export CGO_FLAGS=&amp;#34;`mecab-config --inc-dir`&amp;#34; $ go get github.com/shogo82148/go-mecab MeCabはデフォルトで/usr/local/以下に入るので、他の実装では決め打ちしている例が多いですが、 100%とは言い切れないので面倒ですが都度指定にしてあります。 cgoはpkg-configに対応しているで、MeCab側が対応してくれると環境変数の設定が不要になってもっと楽なんですけどね。
カジュアルに使う Parseを使うとmecabコマンドと同等の結果を文字列として受け取れます。
tagger, err := mecab.New(map[string]string{}) if err !</description>
    </item>
    
    <item>
      <title>Goでデプロイ神社書いてみた</title>
      <link>https://shogo82148.github.io/blog/2015/12/13/go-deploy-shrine/</link>
      <pubDate>Sun, 13 Dec 2015 10:51:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/12/13/go-deploy-shrine/</guid>
      <description>Go その2 Advent Calendar 2015の13日目の記事です。
 その1 その2 その3  六曜を知ることができる便利コマンドを作ってみたお話です。
Deploy神社とは Maco_Tasuが作ったいつdeployしたら安全かを教えてくれる便利APIです。 詳しくは作者ブログ記事をどうぞ。(Deploy神社APIを作った- 眠すぎて明日が見えない)
便利APIなのですが、依存している外部APIが利用できなくなってしまったため、Deploy神社自体が利用できなくなっています。
作ってみた デプロイする時間が分からないと不便なので、Go実装を作ってみました。
 shogo82148/go-deploy-shrine  go getしてきてお祈りを捧げればデプロイするべき時間を教えてくれます。
$ go get github.com/shogo82148/go-deploy-shrine/cli/pray $ pray 今日は旧暦の11月3日(先勝)です。deployは午前中に済ませましょう。 先勝 - Weblio
 六曜の一。急用や訴訟などによいとされ，早く事を行うのがよく，午前は吉，午後は凶という日。先勝日。せんかち。さきがち。
 今日12月13日は先勝で午前中にデプロイするのが良いようです。便利ですね。
六曜とは むかしのカレンダーには暦注と呼ばれる「今日の運勢」みたいなものが記載されていたらしいです。 六曜はその暦注のひとつで、現在のカレンダーにも記載されることの多い影響力の大きなものです。
詳しくはWikipediaで。
 六曜 - Wikipedia  旧暦の(月＋日)を6で割った余りから簡単に求めることができます。
 0: 大安 1: 赤口 2: 先勝 3: 友引 4: 先負 5: 仏滅  旧暦とは 旧暦の月日を求めることができれば六曜は簡単に出せるのですが、 日本における旧暦である天保暦は月の満ち欠けと太陽の動きを元にした暦法であり、 月と太陽の動きを正確に予測する必要があります。
Go版デプロイ神社では「日の出・日の入りの計算―天体の出没時刻の求め方」で紹介されていた計算式を用いています
 2033年旧暦閏月問題 天保暦をそのまま当てはめると2033年に月を決定できない問題が知られています。 日本カレンダー暦文化振興協会というところが「閏11月を推奨する」との見解を2015年8月に出しています。</description>
    </item>
    
    <item>
      <title>Go言語でGraceful Restartをするときに取りこぼしを少なくする</title>
      <link>https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd/</link>
      <pubDate>Mon, 23 Nov 2015 20:51:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd/</guid>
      <description>少し前にStarletにGraceful Restartが時たま上手く動かない問題を修正するpullreqを投げました。 原因は割り込みハンドラ内でexitを呼んでいたからでした。 「割り込みハンドラ内ではフラグを建てるだけ」 「メインのプログラム内でそのフラグを見て分岐する」という原則があるのですが、それを守るのは難しいということですね。 (しかし新たな問題を産んでしまいrevertされてしまいましたが・・・ まあ修正後のコードも考え方は一緒です。割り込みホント難しい・・・)
このpullreqを取り込んでもらうときに再現実験をやってみたのですが、 Goでもちゃんと動くのかな？と気になったので Go言語でGraceful Restartをするで紹介した プログラムに同じテストをやってみました。
2017-01-22追記: Go1.8以降でGraceful Shutdownがbuild-inになるので、この記事で紹介したライブラリは不要となりました。 詳しくはGo1.8のGraceful Shutdownとgo-gracedownの対応を参照。
mannersでテストしてみる 前回の記事ではmannersとgo-server-starterの 組み合わせが良さそうとの結論になったので、この組み合わせでテストしてみます。 以下テストに使用したコードです。 (今回の内容とは直接関係は無いですが、go-server-starterに変更が入ってFallbackのやり方が前回から少し変わってます)
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; &amp;#34;time&amp;#34; &amp;#34;github.com/braintree/manners&amp;#34; &amp;#34;github.com/lestrrat/go-server-starter/listener&amp;#34; ) var now = time.Now() func main() { log.Printf(&amp;#34;start pid %d\n&amp;#34;, os.Getpid()) signal_chan := make(chan os.Signal) signal.Notify(signal_chan, syscall.SIGTERM) go func() { for { s := &amp;lt;-signal_chan if s == syscall.SIGTERM { log.Printf(&amp;#34;SIGTERM!!!!\n&amp;#34;) manners.Close() } } }() listeners, err := listener.</description>
    </item>
    
    <item>
      <title>Goオールスターズで登壇してきました</title>
      <link>https://shogo82148.github.io/blog/2015/10/14/go-all-stars/</link>
      <pubDate>Wed, 14 Oct 2015 08:11:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/10/14/go-all-stars/</guid>
      <description>先週の日曜日に登壇してきました。
  過去に自作したGoプロダクトの紹介 - Goオールスターズ  from Shogo Ichinose   過去に自作したGoプロダクトの紹介 - Goオールスタース  発表の10日くらい前にsongmuさんがKAYACのIRCに現われオールスターを募集に来てくださったものの、 弊社スターの都合がつかないため僕が代わりに発表してきました。
KAYACではGoプロダクトたくさん動いていますが説明は作者にお任せしたほうがいいかなと思い、 自作のGoプロダクトをメインに発表してきました。
 go-rgba4444 androidbinary - Androidのバイナリファイルを解析するgoのライブラリ go-sql-proxy - Go言語でSQLのトレースをする go-dithering - Go言語で画像の減色を行う go-prove/go-tap - Go言語でPerlのテストを早くする go-webtail/go-webtail - Go-webtailってのを書いた  go-prove、CPANに上げればいいんじゃない？w #eventdots
&amp;mdash; songmu (@songmu) 2015年10月11日  Perl Archive Network とはいったい・・・
KAYACではいろんなGoプロダクトが動いているのでこちらもどうぞ。
 go-katsubushi snowﬂake-likeなIDジェネレータ stretcher Consul/Surfと連携したデプロイツール rin AWS-S3に出力されたログをRedshiftへインポートするツール mirage Dockerを使ったテスト用環境構築 alphawing Android/iOSアプリの社内配信ツール  スライドにちょこちょこ修正いれててGopherくん人形もらうの忘れてたけどもらっておけばよかった。
他の人の発表はこちら。
 Goオールスターズ GoオールスターズToggetterまとめ Goオールスターズで登壇してきました - おそらくはそれさえも平凡な日々 Goオールスターズでpackage managementについて話してきました - YAMAGUCHI::weblog Goだけでモバイルアプリを作ろう Goオールスターズ - 考える人、コードを書く人  </description>
    </item>
    
    <item>
      <title>AnySan::Provider::Slackとape-slackを書いた</title>
      <link>https://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack/</link>
      <pubDate>Mon, 28 Sep 2015 22:11:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack/</guid>
      <description>先週、今のプロジェクトでのメインのコミュニケーションツールをIRCからSlack切り替えました。 それにともないIRCに済んでいたボットたちもお引越しする必要があったので、 ボットとSlackをつなぐためのライブラリを書きました。
 AnySan::Provider::Slack ape-slack  Perlとgoのボットが住んでいるのでそれぞれの言語で実装してあります。
AnySan::Provider::Slack PerlのAnySan用のモジュールです。
use AnySan; use AnySan::Provider::Slack; my $slack = slack token =&amp;gt; &amp;#39;YOUR SLACK API TOKEN&amp;#39;, channels =&amp;gt; { &amp;#39;general&amp;#39; =&amp;gt; {}, }; $slack-&amp;gt;send_message(&amp;#39;slack message&amp;#39;, channel =&amp;gt; &amp;#39;C024BE91L&amp;#39;); AnySan-&amp;gt;run; AnySanを使うだけでも便利なんですが、 今のプロジェクトではAnySanを対話形式で使いやすくするようにUnazuSanを使っています。 UnazuSanはIRC前提で書かれていて、AnySan::Provider::Slackをインストールしてもそのままは使えません。
UnazuSanを置き換えるもの面倒なので、イベントの名前を書き換えて投げ直すことで、 SlackのメッセージをIRCに見せかける方法をとっています。 またSlackのOutgoing Webhookで@つきのmentionを捕まえるにもあるように、 Slackのメンションは &amp;lt;@U08DGJVJ7&amp;gt;のような形式になってしまい、UnazuSanは自分へのメッセージとして扱ってくれません。 これをUnazuSanが解釈できる形式に置き換えるのがポイントです。
use 5.010; use warnings; use utf8; use Encode qw/encode_utf8/; use UnazuSan; use AnySan; use AnySan::Provider::Slack; my $unazu_san = UnazuSan-&amp;gt;new( host =&amp;gt; &amp;#39;example.com&amp;#39;, password =&amp;gt; &amp;#39;xxxxxxxxxxx&amp;#39;, enable_ssl =&amp;gt; 1, join_channels =&amp;gt; [qw/arcade/], respond_all =&amp;gt; 1, ); my $slack = slack( token =&amp;gt; &amp;#39;YOUR SLACK TOKEN&amp;#39;, channels =&amp;gt; {}, as_user =&amp;gt; 1, ); AnySan-&amp;gt;register_listener( slack =&amp;gt; { event =&amp;gt; &amp;#39;message&amp;#39;, cb =&amp;gt; sub { my $receive = shift; # fake irc privmsg $receive-&amp;gt;{event} = &amp;#39;privmsg&amp;#39;; $receive-&amp;gt;{message} =~ s/&amp;lt;\@xxxxx&amp;gt;:/unazusan:/; AnySan-&amp;gt;broadcast_message($receive); }, } ); $unazu_san-&amp;gt;on_command( help =&amp;gt; sub { my ($receive, @args) = @_; $receive-&amp;gt;reply(&amp;#39;help &amp;#39;.</description>
    </item>
    
    <item>
      <title>Go言語でPerlのテストを早くする</title>
      <link>https://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang/</link>
      <pubDate>Sat, 19 Sep 2015 21:49:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang/</guid>
      <description>Test::mysqld::Multiというモジュールを書いてみたみたいな涙ぐましい努力により5分で終わるようになったテストですが、 プロジェクトのコードも増えて人も増えた影響で、 テスト時間が約7分まで伸び、テストのキューに10個近く並んで順番待ちさせられるという状況になってしまいした。
この状況を解決すべく go-prove というものを書いてみたので、そのご紹介です。
proveが遅い理由 proveがテストの結果を読むところがブロッキングI/Oになっているらしく、そのせいで遅くなっているらしいです。
 Perl-Toolchain-Gang/Test-Harness#30  実際に結果読んでいるところはこの辺ですかね。 selectとか使っていてなるべくブロッキングしないような作りにはなっていそうですが、どこかでブロッキングしてしまっているようです。 今のプロジェクトだと32コアのCPUで32並列で動かしてもCPUを100%使い切ることができませんでした。
Shunme ググるとShunmeというプロジェクトでproveの問題を解決しようという試みが行われているようです。
 Shunmeというperl用のテストハーネスモジュールを書き始めました magnolia-k/p5-Shunme  しかし残念ながらproveのプラグイン機構はサポートしておらず、Formatterの指定オプションもないようです。 今のプロジェクトではプラグインでMySQLを立てたり、JUnitでテスト結果をフォーマットしたりということをしているので、そのままは使えなさそう。 ちょっと改造するにはソースコードの理解が大変そうなので断念。 「(逆に遅くなるときも有ります)」というところも気になりますね・・・。
go-prove いろいろテストの実行方法を調べてはみましたが、どの方法も並行処理に苦労している模様。 テストファイル自体はただのPerlのスクリプトなので、実行して集計する部分は別にPerlにこだわる必要ないのでは？ 並行処理といえば今ならGolangでしょ！ってことでproveのGo実装を書いてみました。
 go-prove  例えば以下のようなテストをかいて、
use Test::More; ok &amp;#34;macopy&amp;#34;; done_testing; go-proveコマンドと実行すると、JUnit形式でテスト結果が出力されます。
$ go-prove 2015/09/19 21:45:44 start t/macopy.t 2015/09/19 21:45:44 finish t/macopy.t &amp;lt;testsuites&amp;gt; &amp;lt;testsuite tests=&amp;quot;1&amp;quot; failures=&amp;quot;0&amp;quot; time=&amp;quot;0.225&amp;quot; name=&amp;quot;t_macopy_t&amp;quot;&amp;gt; &amp;lt;properties&amp;gt;&amp;lt;/properties&amp;gt; &amp;lt;testcase classname=&amp;quot;t_macopy_t&amp;quot; name=&amp;quot;&amp;quot; time=&amp;quot;0.225&amp;quot;&amp;gt;&amp;lt;/testcase&amp;gt; &amp;lt;/testsuite&amp;gt; &amp;lt;/testsuites&amp;gt; go-prove -j 32とするとgoroutineを32個生成して、32並列でテストを実行してくれます。 I/Oの処理をGolangのランタイムがよしなにやってくれるので、楽ちんです。
また、今のプロジェクトではApp::Prove::Plugin::MySQLPoolを使っているので、それ相当の機能をgo-prove -plugin mysqldで使えるようにしました。 プラグインを有効にするとMySQLサーバを立ち上げて、その接続先情報をGO_PROVE_MYSQLD環境変数に設定してくれます。
実際にプロジェクトのコードで試してみたところ7分かかっていたテストが4分を切るようになりました。 CPUの使用率も100%近くになって、有効活用できているようです。</description>
    </item>
    
    <item>
      <title>PerlからGolangを呼び出す</title>
      <link>https://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter/</link>
      <pubDate>Sun, 30 Aug 2015 22:52:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter/</guid>
      <description>GoのコードをPerlから呼び出せるようにするgo2xsを書いてみました。
使い方 Perlから使いたい関数に以下のようにgo2xsで始まるコメントを付けておきます。
package main //go2xs hello func hello(str string) string { return &amp;#34;Hello &amp;#34; + str } go2xsをgo getして、xsのグルーコードを作成。 その後通常のPerlモジュールと同じ手順でコンパイルします。 Go 1.5から入ったShared Libraryの機能を使っているのでGo 1.5が必要です。
go get https://github.com/shogo82148/go2xs/cli/go2xs go2xs -name hoge hoge.go perl Makefile.PL make あとは普通に呼び出すだけ。
perl -Mblib -Mhoge -e &#39;print hoge::hello(&amp;quot;World&amp;quot;)&#39; Hello World 制限事項 今はまだ、整数・浮動小数点型・文字列しか扱えません。
あとGoのShared Libraryを複数回読み込むことができないっぽい？ (ref. https://github.com/golang/go/issues/11100 ) ので、go2xsを使ったコードを二つ以上useすると死にます。
FFI::Rawを使う方法 go2xsはGoをShared Libraryとしてコンパイルしているだけなので、go2xsを使わなくても頑張れば呼び出すことができます。 Golang で Shared Library を出力する。で紹介されているこちらのコードで試してみます。
package main import ( &amp;#34;C&amp;#34; &amp;#34;log&amp;#34; ) //export fib func fib(n int) int { if (n &amp;lt; 2) { return n } return fib(n - 2) + fib(n - 1) } func init() { log.</description>
    </item>
    
    <item>
      <title>go-webtailってのを書いた</title>
      <link>https://shogo82148.github.io/blog/2015/06/21/go-webtail/</link>
      <pubDate>Sun, 21 Jun 2015 23:28:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/06/21/go-webtail/</guid>
      <description>Rubyで書かれたwebtailのGo移植を書いてみました。
 go-webtail  オリジナルのwebtailはRubyなので、Rubyistではない僕が使おうとするとまずRubyの実行環境からそろえないといけなくてつらい。 ワンバイナリでダウンロードするだけで使えるやつが欲しいなあと常々思っていたのでGolangです。 htmlやjavasctiptの部分もバイナリに含まれているので、インストールも簡単です。
引数無しで実行すると8080ポートで待ち受けて、標準入力から読み込んだ結果をWebsocketで読めるようにしてくれます。
go get github.com/shogo82148/go-webtail/cmd/webtail # インストール echo hogehoge | webtail ファイルもtailできます。
webtail hoge.log fuga.log それぞれ、http://localhost:8080/hoge.logとhttp://localhost:8080/fuga.logで見れるようになります。
mirageと一緒につかう mirageは待ち受けポートを複数設定できます。 (SEE ALSO Dockerで非エンジニアでも開発環境を上げ下げできる、mirageというツールを作りました) その一つをwebtailに割り当てて以下のようにDockerfileに書いておけば、非(サーバサイド)エンジニアでも開発環境のログが見れるようになります。 (見れても理解できるのか？って疑問もあるけど、まあ、全く見れないよりは・・・)
ADD webtail / CMD ./docker_run.sh 2&amp;gt;&amp;amp;1 | /webtail --prefix webtail # ブラウザで見れる代わりにdocker logsで見れなくなるのでこっちのほうがいいかも CMD ./docker_run.sh 2&amp;gt;&amp;amp;1 | tee hoge.log | /webtail --prefix webtail 残念ながらwebsocket対応はしていないので、websoket対応にしたmirageが必要です。 httputil.NewSingleHostReverseProxy互換のrproxyってのを使ったら簡単にwebsocket対応ができて素晴らしいですね。 (mirage自身に手を加える必要があるなら、mirageにこういう機能をつけるべきだったのでは説はある)</description>
    </item>
    
    <item>
      <title>Go言語でSQLのトレースをする</title>
      <link>https://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy/</link>
      <pubDate>Wed, 13 May 2015 01:22:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy/</guid>
      <description>ぴっぴ先輩が「Go言語で発行したクエリを確認したい」って言ってて、 「MySQL使っているならGeneral Logを吐けばよいのでは？」と返したんだけども、 もっと汎用的な方法はないものかと考えてみました。
Golangの database/sql はどんなDBでも対応できるよう、ドライバを自由に入れ替えることができます。 ドライバは単にdatabase/sql/driverにあるインターフェースを満たしている何かなので、 ユーザが自由に作ることができるし、interfaceを経由して直接呼び出すことも可能です。 この仕組を使って、別のドライバにそのまま渡すプロキシを作れば、ログを吐けるのでは？ということでやってみました。
 go-sql-proxy  使い方 まず最初にgo-sql-proxyをドライバとして登録します。
hooks := &amp;amp;proxy.Hooks{ // Hook functions here(Open, Exec, Query, etc.) } sql.Register(&amp;#34;new-proxy-name&amp;#34;, proxy.NewProxy(&amp;amp;another.Driver{}, hooks)) あとは登録したドライバと使って新しいDBハンドラを開くだけです。
db, err := sql.Open(&amp;#34;new-proxy-name&amp;#34;, dataSourceName) このハンドラを使ってクエリ実行を行うと、Hooksで登録した関数が呼び出されます。 元のドライバを直接使った場合と同じように振る舞うので、既存のコードを一切変えること無くHookを差し込めて便利！
トレーサの例 簡単なトレーサを書いてみるとこんな感じ。 発行したSQLのクエリをログに吐き出します。
package proxy import ( &amp;#34;database/sql&amp;#34; &amp;#34;database/sql/driver&amp;#34; &amp;#34;log&amp;#34; &amp;#34;github.com/mattn/go-sqlite3&amp;#34; &amp;#34;github.com/shogo82148/txmanager&amp;#34; ) func main() { sql.Register(&amp;#34;sqlite3-proxy&amp;#34;, NewProxy(&amp;amp;sqlite3.SQLiteDriver{}, &amp;amp;Hooks{ Open: func(conn *Conn) error { log.Println(&amp;#34;Open&amp;#34;) return nil }, Exec: func(stmt *Stmt, args []driver.Value, result driver.</description>
    </item>
    
    <item>
      <title>Goのトランザクションマネージャ作った</title>
      <link>https://shogo82148.github.io/blog/2015/05/09/go-txmanager/</link>
      <pubDate>Sat, 09 May 2015 15:17:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/05/09/go-txmanager/</guid>
      <description>Golangのdatabase/sqlはBeginとCommitでトランザクションの制御を行うことができます。 クエリの実行が確実に成功するのであれば難しくは無いのですが、 トランザクション内でエラーが発生場合、確実にトランザクションを終了させるのは少し面倒です。 また、ネストができないので、「トランザクションの中から呼び出しても外から呼び出しても、関数の中はトランザクション内」みたいなことができません。 PerlにはDBIx-TransactionManagerというものがあるのですが、 このGolang版が欲しくなったので作ってみました。
 txmanager  簡単な使い方 sql.DB をラップした txmanager.DB を使います。 Begin, Commit する代わりに TxBegin, TxCommit を使ってトランザクションを開始・終了すると txmanagerの管理下になります。 確実にトランザクションが終了させるために、トランザクションを開始したらdefer tx.TxFinish()を忘れないように。
import ( &amp;#34;database/sql&amp;#34; &amp;#34;github.com/shogo82148/txmanager&amp;#34; ) func Example(db *sql.DB) { dbm := txmanager.NewDB(db) // トランザクション開始 	tx, _ := dbm.TxBegin() defer tx.TxFinish() // INSERTはトランザクションの中で実行される 	_, err := tx.Exec(&amp;#34;INSERT INTO t1 (id) VALUES(1)&amp;#34;) if err != nil { tx.TxRollback() } tx.TxCommit() } 実際にはこれに加えてエラー処理も必要です。 txmanager.Do を使うと、トランザクションの開始処理・終了をtxmangerがやってくれるので少し楽になります。
import ( &amp;#34;database/sql&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Go言語でGraceful Restartをする</title>
      <link>https://shogo82148.github.io/blog/2015/05/03/golang-graceful-restart/</link>
      <pubDate>Sun, 03 May 2015 12:10:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/05/03/golang-graceful-restart/</guid>
      <description>とあるHTTPサーバをGolangで立てようって話になったんだけど、 止まると困るので無停止でサーバ再起動をしたい。 PerlにはServer::Starterという有名モジュールがあるんだけど、 Golangはどうなってるの？ってことで調べてみました。
2017-01-22追記: Go1.8以降でGraceful Shutdownがbuild-inになるので、この記事で紹介したライブラリは不要となりました。 詳しくはGo1.8のGraceful Shutdownとgo-gracedownの対応を参照。
gracefulじゃないバージョン Golangの標準ライブラリを使ってHTTPサーバを立ててみる例。 レスポンスが一瞬で終わってしまうとよくわからないので、sleepするhandlerを追加しておきます。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; ) var now = time.Now() func main() { log.Printf(&amp;#34;start pid %d\n&amp;#34;, os.Getpid()) s := &amp;amp;http.Server{Addr: &amp;#34;:8080&amp;#34;, Handler: newHandler()} s.ListenAndServe() } // https://github.com/facebookgo/grace/blob/master/gracedemo/demo.go から一部拝借 func newHandler() http.Handler { mux := http.NewServeMux() mux.HandleFunc(&amp;#34;/sleep/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { duration, err := time.ParseDuration(r.FormValue(&amp;#34;duration&amp;#34;)) if err != nil { http.Error(w, err.Error(), 400) return } time.</description>
    </item>
    
    <item>
      <title>Go言語で画像の減色を行う</title>
      <link>https://shogo82148.github.io/blog/2015/04/25/quantize-image-in-golang/</link>
      <pubDate>Sat, 25 Apr 2015 21:49:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/04/25/quantize-image-in-golang/</guid>
      <description>ちょっとGIFアニメを作りたくなって、最近Go触ってるしGoでやってみよう！とやってみたメモ。 ImageMagikでいいじゃん説もあるけど、最終的にツールとして配布したいなってことでGoです。
主に減色まわりについて。
2021-12-07修正
昨今のアレコレ(LOSING LENA)の関係で記事中の Lenna さんの画像をマンドリルに置き換えました。
何はともあれ実装してみる 以前、「ターミナル操作の記録(ttyrec)からGIFアニメを生成するツールを作った」という記事を見たので、 これを参考に実装してみる。
package main import ( &amp;#34;image&amp;#34; &amp;#34;image/color/palette&amp;#34; &amp;#34;image/gif&amp;#34; _ &amp;#34;image/png&amp;#34; &amp;#34;os&amp;#34; ) func main() { reader, err := os.Open(&amp;#34;Mandrill.png&amp;#34;) if err != nil { return } defer reader.Close() img, _, err := image.Decode(reader) if err != nil { return } paletted := image.NewPaletted(img.Bounds(), palette.WebSafe) for y := img.Bounds().Min.Y; y &amp;lt; img.Bounds().Max.Y; y++ { for x := img.Bounds().Min.X; x &amp;lt; img.Bounds().Max.X; x++ { paletted.</description>
    </item>
    
    <item>
      <title>Go言語でshuffleする話</title>
      <link>https://shogo82148.github.io/blog/2015/04/25/shuffle-in-golang/</link>
      <pubDate>Sat, 25 Apr 2015 18:07:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/04/25/shuffle-in-golang/</guid>
      <description>Fisher-Yates shuffleを使ってシャッフルライブラリ作ってみました。
 https://github.com/shogo82148/go-shuffle  標準ライブラリのsortと似たような感じで使えます。 デフォルトでintとfloat64とstringのシャッフルに対応していて、 他の型をシャッフルしたい場合はインターフェースを実装してね、って感じです。 実装が簡単なので、インターフェース定義する手間とシャッフルのアルゴリズム自前で書く手間ほとんど一緒ではという気もするけど、 まあライブラリ作成の練習ってことで。
で、ここからが本題。 Fisher-Yates shuffleの名前は以前から知ってたけど、 この前某プロジェクトで以下のようなshuffleの実装を発見。
package main import &amp;#34;math/rand&amp;#34; func shuffle(a []int) { for i := range a { j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i] } } Fisher-Yates shuffleと似ているけど、なにかが違う。 ちゃんとシャッフルされているのか気になったので検証してみました。
検証 n個の数列をシャッフルすることを考えます。 シャッフルの後i番目の要素がj番目に移動する確率を $P_n(i, j)$ と定義します(golangのコードにあわせて0-originで考えます)。
完全にランダムにシャッフルされていれば、 元の数列のどの要素も0からn-1の範囲に一様分布するはずです。 つまり、以下の式がなりたてば「シャッフルされている」と言えそうです。
$$ P_n(i, j) = \frac{1}{n}　(i, j = 0, \dots, n - 1) $$
n=1の場合 n=1の場合は、必ず0番目と0番目の入れ替え(つまり順番変わらない)になります。 上で定義した確率を計算すると$P_1(0, 0) = 1/1$となるので、シャッフルされていると言えます。</description>
    </item>
    
    <item>
      <title>map[string]Hoge or map[string]*Hoge ?</title>
      <link>https://shogo82148.github.io/blog/2015/02/22/should-i-use-a-pointer-in-go/</link>
      <pubDate>Sun, 22 Feb 2015 02:14:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2015/02/22/should-i-use-a-pointer-in-go/</guid>
      <description>Go言語でポインタを使うべきか使わないべきか問題。 「ケース・バイ・ケースなので、状況に応じて使い分けましょう！」という結論が出るのは目に見えているので、 具体例について検証してみた結果を書いておきます。
背景 他の人のコードレビューを見ていたら、 レビュアーが「コピーをしないで済むのでstructの受け渡しにはポインタ使ったほうがいいと思います！」とコメントしていて、 そうなのか？と思ったのですがあんまり自信がなかったので検証してみました。 コメントがついていたのは以下のようなコード。
package hoge import ( &amp;#34;strconv&amp;#34; ) type Hoge struct { A int B int C int } func NewHogeMapStruct() map[string]Hoge { m := make(map[string]Hoge) for i := 0; i &amp;lt; 10000; i++ { m[strconv.Itoa(i)] = Hoge{i, i, i} } return m } ポイントは以下の点です。
 受け渡すstructはintが3つ程度の小さなもの mapに入れて返す  benchmarkを使って検証する ポインタを使わない版と使う版を両方作ってベンチマークをとってみます。
package hoge import ( &amp;#34;strconv&amp;#34; ) type Hoge struct { A int B int C int } // ポインタ使わない版 func NewHogeMapStruct() map[string]Hoge { m := make(map[string]Hoge) for i := 0; i &amp;lt; 10000; i++ { m[strconv.</description>
    </item>
    
    <item>
      <title>Androidのバイナリファイルを解析するgoのライブラリ</title>
      <link>https://shogo82148.github.io/blog/2014/05/07/androidbinary/</link>
      <pubDate>Wed, 07 May 2014 13:29:00 +0900</pubDate>
      
      <guid>https://shogo82148.github.io/blog/2014/05/07/androidbinary/</guid>
      <description>Androidのアプリの実態はzipファイルなのでunzipすれば簡単に中身を見ることができるわけですが、 開いてもバイナリファイルが入っているだけでよくわかりません。 AndroidSDKに付属しているaaptというツールを使えば読めるんだけどインストールが大変で苦しんでいる人がいたので、 お手軽に解析できるgolangのライブラリを書いてみました。
使い方 go getしてくる githubのレポジトリ からダウンロードしてきます。
go get github.com/shogo82148/androidbinary AndroidManifest.xmlを解析する io.ReaderAtインターフェースを満たすオブジェクトをandroidbinary.NewXMLFileに渡すと解析してくれます。
f, _ := os.Open(&amp;#34;AndroidManifest.xml&amp;#34;) xmlFile, _ := androidbinary.NewXMLFile(f) reader := xmlFile.Reader() // reader を読むと普通のXMLファイルとして読める resources.arscを解析する アプリ名などの設定はAndroidManifest.xmlには直接書かれておらず、 リソースファイルに書いてあることがほとんどです(開発者がよほどものぐさでなければ)。 リソースの情報はapk内のresources.arscに書かれているので、 このファイルを読む機能もついてます。
f, _ := os.Open(&amp;#34;resources.arsc&amp;#34;) tableFile, _ := androidbinary.NewTableFile(f) // ID 0x7F040000 に対応するリソースを読む config := &amp;amp;androidbinary.ResTableConfig{} val, _ := tableFile.GetResource(androidbinary.ResId(0x7f040000), config) アプリ名はロケールによって変わったりするので、 configで設定できます。 例えば日本語の名前を取得したい場合はこんな感じ。
// ID 0x7F040000 に対応するリソース(日本語)を読む config := &amp;amp;androidbinary.ResTableConfig{} config.Language[0] = &amp;#39;j&amp;#39; config.Language[1] = &amp;#39;a&amp;#39; val, _ := tableFile.</description>
    </item>
    
  </channel>
</rss>
