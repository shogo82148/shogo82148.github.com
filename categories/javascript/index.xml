<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on Shogo&#39;s Blog</title>
    <link>https://shogo82148.github.io/categories/javascript/</link>
    <description>Recent content in javascript on Shogo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 13 Aug 2024 00:33:00 +0900</lastBuildDate>
    <atom:link href="https://shogo82148.github.io/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Structured Field Values のパーサーを書いた</title>
      <link>https://shogo82148.github.io/blog/2024/08/13/structured-field-values/</link>
      <pubDate>Tue, 13 Aug 2024 00:33:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/08/13/structured-field-values/</guid>
      <description>GoとTypeScriptで Structured Field Values のパーサーを書きました。
github.com/shogo82148/go-sfv: Go版実装 github.com/shogo82148/sfvjs: TypeScript版実装 背景 そもそも Structured Field Values (SFV) とはなにか、なぜ登場したのか、という背景はこちらの記事をどうぞ。
Structured Field Values による Header Field の構造化 HTTP APIを開発していると、アプリケーション独自のHTTPフィールドを定義することがあります。 そういうときに、標準にしたがっておいたほうが何かと楽だろう、ということでSFVを採用しました。
しかしいい感じのSFVのパーサーがなかなか見つからなかったので、自作することにした、というわけです。
Go実装 Go のモジュールとして公開されているので、いつものように go get してきましょう。
go get github.com/shogo82148/go-sfv GoでSFVをパースする DecodeItem、DecodeList、 DecodeDictionary を使います。
net/http.Header.Valuesの戻り値を直接受け取れるよう、 各関数は []string を受け取るようにしました。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/shogo82148/go-sfv&amp;#34; ) func main() { h := make(http.Header) h.Add(&amp;#34;Example&amp;#34;, `2; foourl=&amp;#34;https://foo.example.com/&amp;#34;`) item, err := sfv.DecodeItem(h.Values(&amp;#34;Example&amp;#34;)) if err != nil { panic(err) } fmt.</description>
    </item>
    <item>
      <title>denoland/dntがerror TS2304: Cannot find name &#39;ErrorOptions&#39;で失敗する</title>
      <link>https://shogo82148.github.io/blog/2024/08/13/denoland-dnt-cannot-find-error-options/</link>
      <pubDate>Tue, 13 Aug 2024 00:30:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2024/08/13/denoland-dnt-cannot-find-error-options/</guid>
      <description>先日npmへのパッケージ公開にチャレンジしてみました。
npmとjsrにパッケージを公開してみた (認証バッジ付) しかし2か月も経たないうちにビルドに失敗するようになってしまいました・・・。 何もしていないのに壊れた。
% deno run -A scripts/build_npm.ts [dnt] Transforming... [dnt] Running npm install... added 7 packages, and audited 8 packages in 4s found 0 vulnerabilities [dnt] Building project... [dnt] Type checking ESM... src/deps/jsr.io/@std/assert/1.0.2/assertion_error.ts:27:42 - error TS2304: Cannot find name &amp;#39;ErrorOptions&amp;#39;. 27 constructor(message: string, options?: ErrorOptions) { ~~~~~~~~~~~~ src/deps/jsr.io/@std/assert/1.0.2/assertion_error.ts:27:42 - error TS4063: Parameter &amp;#39;options&amp;#39; of constructor from exported class has or is using private name &amp;#39;ErrorOptions&amp;#39;. 27 constructor(message: string, options?</description>
    </item>
    <item>
      <title>〜夏休みの自由研究〜 電波時計のサマータイム対応状況を調べてみた</title>
      <link>https://shogo82148.github.io/blog/2018/08/20/summer-time-homework/</link>
      <pubDate>Mon, 20 Aug 2018 09:29:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2018/08/20/summer-time-homework/</guid>
      <description>僕は知っています。
ぜひ、みなさんもお手元の電波時計で試してみてください！
と書いても、試してくれる人なんていないことを。
僕は知っています。
説明書や仕様書に書いてあったとしても、書いてあるとおりに動作する機械なんて、ほんの一握りだということを。
というわけで、楽しい夏休みの自由研究です。 秋葉原で適当に買った1000円から3000円くらいの電波時計に、サマータイムのフラグを有効にした電波を受信させてみて、どういう挙動になるか調査してみました。
TL;DR 10機種(SEIKO, CITIZEN, CASIO, MAG, ELECOM, その他)に対して、サマータイムフラグを有効にした状態で Web JJY の電波を送信しました。
今回の調査範囲では、夏時間の時刻(1時間 or 2時間ズレた時刻)を表示する時計は見つからなかった 夏時間実施中(DST)と表示 する時計は実在する 室内で使うならCASIOの電波時計はクオーツ時計だと思ったほうがいい 電波受信の様子をYouTubeにあげておいたので興味のある方はどうぞ。
背景 2018年、日本は記録的な猛暑に見舞われ、 観測史上最高の気温41.1度を記録し、 熱中症とみられる症状で90人以上が亡くなるという甚大な被害を被った。
今週の天気　記録的な猛暑　底知れぬ暑い夏 日本で猛暑　気温41.1度で観測史上最高 気象庁「災害と認識」熱中症死の疑い６日で９０人超 この記録的猛暑を受け、政府・与党によって2020年の東京五輪・パラリンピックの酷暑対策として、夏の期間だけ時間を2時間繰り上げる「サマータイム(夏時間)」の導入が検討されている。
酷暑対策でサマータイム導入へ　秋の臨時国会で議員立法　３１、３２年限定 これに対して、「電波時計が狂うのではないか」「日本中の電波時計がゴミになる」等、電波時計が正しい時刻を示さなくなるとの指摘が相次いでいる。
サマータイム導入で「電波時計が狂う」？　メーカーに聞いた サマータイムで日本中の電波時計がゴミになる(かも)という話 電波時計は、NICT(情報通信研究機構)が提供している標準電波(JJY)を受信し、時刻の同期を行っている。 この標準電波には、時、分、通算日、年、曜日といったタイムコード情報に加え、 将来の拡張性のための「予備ビット」が設けられている。 この予備ビットに関して、「標準電波の出し方について」には、夏時間情報として意味を持たせる場合の例が記載されているが、これはあくまでも例であり、告示などで正式に決まっているものではない。 しかし、現実に市販されている電波時計のなかにも、仕様上予備ビットの状態を認識する機種がする。
標準電波の送信周波数40kHzを提供する「おおたかどや山標準電波送信所」は1999年6月運用開始、送信周波数60kHzを提供する「はがね山標準電波送信所」は2001年10月運用開始である。 日本でサマータイムが導入されたのは1948年から1951年の期間だけなので、 今後サマータイムが導入されることとなれば、標準電波の運用が始まってから初のサマータイム導入となる。
夏時刻法 - Wikipedia 長波帯標準電波施設 パンフレット(PDF) そのため、仕様上はサマータイムへ対応している電波時計であっても、初のサマータイム実施によって未知の挙動を示すことが十分に想定される。 そこで、本記事では、実際にサマータイム実施中の電波を電波時計に受信させ、 どのような挙動を示すのかを明らかにする。
目的 2018年8月現在日本で市販されている電波時計が、サマータイムの情報を含んだ標準電波(JJY)を受信した場合の挙動を調査し、 仮に、2019年、2020年にサマータイムが導入された場合の影響を明らかにする。
実験方法 秋葉原で購入した以下の電波時計に対して、標準電波と同様の電波を送信し、時刻の同期を行う。
CITIZEN 8RZ152 CITIZEN 4RL432-019 SEIKO SQ698S SEIKO KR331W MAG T-694 SM-Z ELECOM CLK-DD001RD 京都大和 171038 (製造元不明) 31756 CASIO DQD-710J-8JF CASIO TTM-160NJ-8JF 電波の送信には、Samsung Galaxy Note8 SC-01K を用いて、JJYシミュレータWeb版を実行する。</description>
    </item>
    <item>
      <title>Web JJY が夏時間に対応しました</title>
      <link>https://shogo82148.github.io/blog/2018/08/11/web-jjy-summer-time-support/</link>
      <pubDate>Sat, 11 Aug 2018 07:29:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2018/08/11/web-jjy-summer-time-support/</guid>
      <description>サマータイムなんて日本人には関係ないと思っていた時期が僕にもありました。 ところが何やら日本にもサマータイムがやってくる動きがあるようです。
酷暑対策でサマータイム導入へ　秋の臨時国会で議員立法　３１、３２年限定 さて、長波JJY(市販の電波時計のための電波)には夏時間の情報が含まれています。 「将来の拡張性のための予備ビット」という扱いなので、対応している時計なんてないだろう、と思っていたら、 なんと対応している時計が存在しているらしいということを知りました。
その事実を確かめるため、Webブラウザを使って電波を出してみたで紹介した JJYシミュレータWeb版に夏時間を有効にするチェックボックスを追加しました。
CITIZEN 8RZ152 の動作例 夏時間への同期、完了しました 😂😂😂 pic.twitter.com/3tMcCYdXpP
&amp;mdash; Ichinose Shogo (@shogo82148) 2018年8月9日 念の為書いておきますが、今は午前8時です
&amp;mdash; Ichinose Shogo (@shogo82148) 2018年8月9日 DST(Daylight Saving Time)の表示が出て、夏時間に切り替わったことがわかりますが、なぜか6時間もズレています・・・。
もう、こんな時間だ……そろそろ寝よう……
？？？お前24時間表記だっただろ？どうしたんだ？？？
(今は20時です) pic.twitter.com/8PViLOaj85
&amp;mdash; Ichinose Shogo (@shogo82148) 2018年8月10日 悲報 11日を迎えることができず pic.twitter.com/pw0k0Qo8RY
&amp;mdash; Ichinose Shogo (@shogo82148) 2018年8月10日 もはや数字ではないものが出てきた。
まとめ 夏時間に対応した電波時計の存在は事実でした。 しかし、機種によっては挙動がおかしくなるようです(N=1)。
ぜひ、みなさんもお手元の電波時計で試してみてください！
JJYシミュレータWeb版 ※ 利用の結果生じた損害について、一切責任を負いません。
参考 標準電波の出し方について 酷暑対策でサマータイム導入へ　秋の臨時国会で議員立法　３１、３２年限定 Webブラウザを使って電波を出してみた サマータイムで日本中の電波時計がゴミになる(かも)という話 サマータイム導入で「電波時計が狂う」？　メーカーに聞いた 「サマータイム導入はコンピュータシステム的に難あり」は本当か サマータイム実施は不可能である from UEHARA, Tetsutaro 僕もサマータイム実施は不可能だと思います・・・。</description>
    </item>
    <item>
      <title>Webブラウザを使って電波を出してみた</title>
      <link>https://shogo82148.github.io/blog/2016/03/29/web-jjy/</link>
      <pubDate>Tue, 29 Mar 2016 12:19:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2016/03/29/web-jjy/</guid>
      <description>読者の持っている至って普通のコンピューターは、実は電波時計の時刻合わせを行うために必要な標準電波の発信装置が備わっている。
コードは以下から入手できる。
shogo82148/web-jjy JJYシミュレータWeb版 動かし方 パソコンのイヤホンジャックにアンテナ(普通のイヤホンで十分です)を接続し、電波時計の近くに置きます。 音量を最大にし、「Start」ボタンを押すと信号が送信されます。 電波時計を強制受信モードにし、時刻が設定されるのを待ちましょう。
パソコンの時間を基準にするので、あらかじめntpとかで時刻設定をしておくといいと思います。
原理 標準電波JJYは日本標準時のタイムコードを送信する電波で、 東日本では40kHz、西日本では60kHzの周波数で発信されています。 電波時計はこの信号を使って時刻合わせをしています。
この信号をオーディオデバイスから出力する電波時計用JJYシミュレータというものがあるのを知り、 「今のWebブラウザならjavascriptだけで実装できるのでは？」と思いやってみました。 一般的なオーディオデバイスは、20kHz以上の周波数の再生には適していないため、そのままでは40kHz/60kHzの信号は出せません。 そこで、電波時計用JJYシミュレータは、歪んだ波形に含まれる高調波を利用しています。 ボリュームを大きくして音が割れた状態になると、音声信号は矩形波に近いかたちになります。 矩形波には3倍、5倍、7倍&amp;hellip;の奇数倍の周波数成分が含まれているため、 (世はまさに大フーリエ時代とか見ると楽しい) 13.333kHzの矩形波を出力することで、39.999kHzの信号を出せるというわけです。
元のソフトウェアはWindowsのバイナリ形式でしたが、 WebAudioの登場によりWebブラウザからも同様のことが行えるようになりました。
最後に 少し前にCPUから出るノイズを使ってAMラジオの電波を発信するという記事が話題になりましたね。
普通のコンピューターからAMラジオを鳴らそう CPUやオーディオデバイスも電気で動いている以上、電波が出ているのは当たり前のことなのですが、 こうやって改めて確認できると面白いですね。
パソコンから出る程度の電波強度では、電波法に抵触することはないと思いますが、 うっかり強力な電波を発信しないよう気をつけてください。</description>
    </item>
    <item>
      <title>キレイになったコトバとハートを元に戻すツール作った</title>
      <link>https://shogo82148.github.io/blog/2014/06/01/anti-sizukatter/</link>
      <pubDate>Sun, 01 Jun 2014 00:24:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2014/06/01/anti-sizukatter/</guid>
      <description>現実世界にご満足の方消えてなくなってほしいの！！！
しずかったーを使うと個性あふれるコトバを使ってもキレイにしてくれるので とっても便利ですね！ でも、本当は何を言っているのか真意を知りたい・・・。
そんな人のために、キレイになったコトバとハートを元に戻す アンチしずかったー を作りました。
仕組み しずかったーは単純な文字列置換で動いているみたいなので、 対応表を頑張って作りました。 それをMeCab用の辞書に変換し、 Igoを使ってバイナリ辞書に変換、 igo-javascriptでブラ失礼しちゃう上で解析できるようにしました。
既知の問題点 しずかったー前後の文脈関係なく変換しちゃうので、 同音異義語は元に戻らないことがあります。 特にひらがな・カタカナは失敗することが多いです。(「（お昼寝したい）ふわふわ」だとか「ブラ失礼しちゃう」だとか)
あと、マシュマロ的な内緒の言葉はさすがのしずかちゃんでも代替表現が思いつかなかったらしく、 全部ハートになってしまいます。 元に戻せと言う方が頑張ればなんとかできそうなので期待しないでく時代が変わればかっこいい。
まとめ またおもしろいものを作ってしまいましたが、 igo-javascriptのバグを発見できたりしたので、いいのです。
自宅警備員でお時間ある方の皆様、天才だと思ったらぜひおしゃべり広場や「いいね！」広場で共有をお願いします。</description>
    </item>
    <item>
      <title>JavaScript版WaveZutaZuta作ってみた</title>
      <link>https://shogo82148.github.io/blog/2012/12/24/wavezutazutajs/</link>
      <pubDate>Mon, 24 Dec 2012 13:51:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2012/12/24/wavezutazutajs/</guid>
      <description>「WaveZutaZutaというおもちゃを書いている話」 という記事を見ていたら，誰かがツイッターで 「いっちーがJavaScriptに移植してくれる」と発言．
あ，はい．やってみましょう．
どんな感じのものなの？ 音声ファイルをテキトーに切り貼りできるライブラリです． WaveZutaZutaJSにブラウザで実行出来るサンプルを置いたので 実際試してみるのが一番わかりやすいと思います． 適当な音声ファイルをドラッグ＆ドロップして，playボタンを押すと音が流れるので，いろいろ遊んでみてください．
テキストボックスには楽譜が書かれています． 楽譜の書き方は「WaveZutaZutaというおもちゃを書いている話」 と同じです．
ちなみに、楽譜ファイルの読み方、書き方ですが、aからzまでの文字それぞれにずたずたにされたwaveファイルの&amp;quot;破片&amp;quot;がアサインされていて、-は音をのばす(タイ)を意味し、0は休符を意味します。*を指定すると、a-zのうちどれかをランダムで鳴らします。1文字が64分音符ひとつ分の長さです。空白文字は無視されます。
使い方 リポジトリの WaveZutaZutaJS.js がライブラリの本体です． 次のように使います．
var data = new ArrayBuffer(); // ずたずたにしたい音声データを入れておく var context = new AudioContext(); var zuta = new WaveZutaZuta(context); zuta.onSuccess = function(self, source) { // 元の音声の先頭5秒から3秒間流す zuta.setNote(&amp;#39;a&amp;#39;, 5); var node = zuta.getAudioNode([{sound: &amp;#39;a&amp;#39;: length: 3}]); node.connect(context.destination); }; zuta.loadAudio(data); data には入力音声のバイナリデータを入れておきます． 形式はブラウザが対応していれば何でもOKです． Chromeなら wav, mp3, mp4 など，メジャーな形式はたいてい読めると思います．
getAudioNodeで返ってくるのは AudioNode なので，WaveZutzZutaJS の出力にさらにエフェクトをかけることができます． 例えば，次のコードで周波数フィルタを通すことができます．
var data = new ArrayBuffer(); // ずたずたにしたい音声データを入れておく var context = new AudioContext(); var zuta = new WaveZutaZuta(context); zuta.</description>
    </item>
    <item>
      <title>JavascriptでIME</title>
      <link>https://shogo82148.github.io/blog/2012/03/28/igoime/</link>
      <pubDate>Wed, 28 Mar 2012 22:00:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2012/03/28/igoime/</guid>
      <description>この前いじったChrome17対応版AjaxIMEは 実際の変換を行うのに本家AjaxIMEが提供している変換サーバをそのまま使用しています。 そのため、すべての入力内容は本家サーバに送信されてしまいます。 どんな入力をしたのか作者さんにバレバレです。 この送信内容、暗号化すらされていないので、作者以外の人に見られる可能性もあります。 自分の書いた文章が勝手にインターネットに送信されているっていうのはあんまり嬉しくないですね。 ローカルのみで完結するのが理想です。
本家サーバはどうやらmecab-skkservと同じエンジンを使っているようです。 このバックエンドで動いているのは実はMeCab。 ということは、MeCabと互換性のあるigo-javascriptでも同じことができるはず・・・！ これはならブラウザ上ですべてが完結する！
はい、そういうことで作ってみました。
IgoIME 使い方は本家と一緒です。Alt-o (Ctrl-9)でモード切替。 ローマ字で日本語を入力することができます。
日本語入力をするためには変換候補をいくつか出力する必要がありますが、 本来Igoにはその機能はありません。 そのため、複数候補を出す部分だけ独自実装してあります。 しかし、まだなんか変換候補が怪しいですね・・・。 長い文章を入力したのに一文字しか結果が帰ってこないことがあります。 なんでだろう・・・・
まだまだ改良が必要なようです。</description>
    </item>
    <item>
      <title>Javascriptでの関数宣言</title>
      <link>https://shogo82148.github.io/blog/2012/03/23/javascript-function/</link>
      <pubDate>Fri, 23 Mar 2012 18:22:00 +0900</pubDate>
      <guid>https://shogo82148.github.io/blog/2012/03/23/javascript-function/</guid>
      <description>Chrome17対応版AjaxIME Ajaxを使ってIMEを実現したAjaxIMEがFireFoxでは動くのに最新版のChromeで動かない。 動くように少しいじってみた。
Chrome17対応版AjaxIME 原因 Chromeで動かなかった原因はここ。
if(typeof getComputedStyle == &amp;#39;undefined&amp;#39;) { function getComputedStyle() { //中身は省略 } } FireFoxやChromeには getComputedStyle という関数が定義されているけど、 IEには定義されていない。 if文で有無を判定して、無い場合は動作をエミュレートする関数を定義している。
実行の様子をデバッガで追って見ると、Chromeではエミュレートする必要が無いのになぜか自前で定義した関数が呼び出されていた。 どうやら、Chromeでは 自作 getComputedStyle 関数が if文の中にあったとしてもコード読み込み時に作成されてしまうみたい。 FireFox だと if文の中が実行されない場合には作成されない。
結果だけ書くと、次のように書きなおしたら動いた。
if(typeof getComputedStyle == &amp;#39;undefined&amp;#39;) { getComputedStyle = function() { //中身は省略 } } あと Chrome だと、Input要素にフォーカスがあたった時に余計な装飾がついてしまうので、CSS上書きして抑制。 IE8でTextRangeが使えない問題は「IE8でのTextRange.moveToPoint()」を参考にして解決。 IE7のエミュレートモードにしているだけで、根本的な解決にはなってないけど、まあIEだしいいでしょ。
どっちが正しいの？ とりあえず問題は解決したんだけど、FireFoxとChromeで動作が違うけど、どちらの動作が正しいの？ 気になったので調べてみた。
「mixi Engineers&amp;rsquo; Blog &amp;raquo; 詳細 ECMA-262-3 第5章 関数」に関数の定義法についてわかりやすい解説が載っていた。 結論からいうと、一番初めの書き方は「誤り」で実際の動作は実装依存、つまり FireFox の動作も Chrome の動作も正しいとのこと。
関数定義と関数式 関数の定義法は大きく分けて、次のような関数定義と関数式に分かれている。 関数式は更に名前なしと名前付きがある。
//関数定義 function foo() { } //名前なしの関数式 var foo = function() { }; //名前付きの関数式 var foo = function _foo() { }; 普通の関数定義と無名関数があるのは知っててけど、単なるシュガーシンタックスみたいなものかと思った。 mixiのブログによると全くの別物。 関数定義と関数式の大きな違いは、実行時に呼び出し可能になっているかどうか。 関数定義は実行時に呼び出し可能になっているから、定義と呼び出しの順番は関係ない。</description>
    </item>
  </channel>
</rss>
