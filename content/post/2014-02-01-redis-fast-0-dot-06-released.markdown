---
layout: post
title: "Redis::Fast 0.06 released"
date: 2014-02-01 21:36
comments: true
categories: [perl, redis]
---

こんにちは、もうすぐ17才と100ヶ月を迎えるいっちーです。
今朝、[Redis::Fast 0.06](https://metacpan.org/release/Redis-Fast)をリリースしました。
主な変更点はメモリーリークの修正と、エラー発生時にSegmentation Faltで落ちる問題の修正です。

<!-- More -->

## メモリーリーク

Redis::Fastをサブスクライバーモードで動作させると、メモリを無限に食い続ける問題をついに！ついに！修正しました。
原因は、一言で言ってしまえば、Perlのリファレンスカウントの扱いの勉強不足です・・・。

XSの中でPerlのオブジェクトを作るとき、プログラマが手動でリファレンスカウントを制御する必要があります。
とはいうものの、全てのオブジェクトのリファレンスカウントを制御するのは大変なので、
XSには「揮発性」という考え方があります。
`sv_2motral`を使って変数を揮発性に設定しておけば、よしななタイミングでオブジェクトを解放してくれます。
[gfx先生のブログ](http://d.hatena.ne.jp/gfx/20100519/1274247355)にもあるように、
オブジェクト作成したら原則`sv_2motral`をつけるようにすれば、
メモリーリークはほとんどなくなるはずです。

``` c
SV * s = newSVpv("Hello World",0);  // Perl の文字列オブジェクト
sv_2motral(s) // 揮発性にすることで、使われなくなったら自動的に解放してくれる
```

この「よしななタイミング」をよく理解していなかったのでリークしてました・・・。
XSからオブジェクトへアクセスできなくなったときでないとオブジェクトを解放できないので、
揮発性のオブジェクトが実際に解放されるのは「XSで書かれた関数が終了してPerlに戻るとき」です。
メッセージを待ち続ける`wait_for_messages`関数は
(タイムアウトをしない限り)ずっと終了しないので、
揮発性のオブジェクトを解放するタイミングが一切なかったのです。

不要になったら解放されるよう、揮発性オブジェクトの有効範囲を明示的に指定しました。
``` c
sv_2motral(s);
ENTER;
SAVETMPS;
sv_2motral(v);
FREETMPS;
LEAVE;
// v はココで解放される
// s は生き残ってる
```

[perlcall](http://perldoc.jp/docs/perl/5.18.1/perlcall.pod)とかちゃんとドキュメントを読みましょう > 自分


## Segmentation Falt

同期的にコマンドを実行してる最中にSIGNAL等で実行が中断されると、
Segmentation Faltが起こる問題を修正しました。
Redis::Fastは同期モードでコマンドを発行したときでも、
hiredisの非同期モードの機能を使って通信しています。
コマンド実行中にエラーが発生すると、
コールバック関数の呼び出しタイミングが変わってしまい、
メモリの確保・解放のタイミングが狂ってしまっていました。

このバグ、試した環境の中ではUbuntu+Perl5.14でしか再現しませんでした。
他の環境ではたまたま解放後もアクセスできてしまって、
正常に動作してしまっていたようです。
嫌なバグだ・・・。


## まとめ
C言語でメモリ管理するコードは書くべきでない。
