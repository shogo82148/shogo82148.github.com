<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RaspberryPi | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/raspberrypi/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2013-09-28T02:08:11+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RaspberryPiからメールを送る]]></title>
    <link href="http://shogo82148.github.io/blog/2013/05/12/mail-from-raspberrypi/"/>
    <updated>2013-05-12T21:50:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/05/12/mail-from-raspberrypi</id>
    <content type="html"><![CDATA[<p>RaspberryPi に cron を仕込んで定期実行をやってみようと考えました。
cron の設定自体は <code>crontab -e</code> コマンドを実行すれば簡単にできます。
ただ、これだけだとちゃんと動いているか少し心配なので、
エラーが起きた時に何か通知して欲しい。
普通なら設定ファイルに <code>MAILTO=hogehoge@example.com</code> と書いておくと
メールが送られるはずなのですが、
メールサーバが動いてないのでうまくいかない・・・。</p>

<p>そういうわけで、RaspberryPiからメールを送るための設定をしたのでメモ。</p>

<!-- More -->


<h2>MTAをインストールする</h2>

<p>Raspberry Pi には標準でMTA(Message Transfer Agent)が入ってないようなのでインストール。
今回はPostfixを採用</p>

<p><code>bash
sudo apt-get install postfix
</code></p>

<p>最初、Sendmailも試してみたんだけど、送信者マスカレードがなぜかうまく行かなったので断念。
後述するように、この設定がないとスパムフィルタに引っかかってしまうのです。</p>

<h2>プロバイダのSMTPにリレーしてもらう</h2>

<p>実際にメールを送りには以下の条件を満たす必要があるようです。</p>

<ul>
<li>送信元のドメインを引ける</li>
<li>固定IPからのアクセス</li>
</ul>


<p>固定IPなんて自前で持ってないし、
cron からのメールは送信元が pi@raspberrypi になってしまいドメインを引けません。
そのためそのままではスパムメールとして扱われてしまい、メールが届きません。</p>

<p>そこで、プロバイダが提供しているSMTPサーバにメールをリレーしてもらいます。
<code>/etc/postfix/main.cf</code>に以下の行を追加します。</p>

<p>``` plain /etc/postfix/main.cf
sender_canonical_maps = regexp:/etc/postfix/canonical</p>

<p>relayhost = [smtp.example.com]:587
smtp_sasl_auth_enable = yes
smtp_sasl_password_maps = hash:/etc/postfix/relay_password
smtp_sasl_security_options = noanonymous
```</p>

<p>プロバイダにリレーしてもらうには SMTP-Auth で認証する必要があるので、
ユーザ名とパスワードを設定しておきます。</p>

<p><code>plain /etc/postfix/elay_password
smtp.example.com hogehoge:your-password
</code></p>

<p>postmapコマンドを使って、Postfixから扱える形式に変換します。</p>

<p><code>bash command
$ postmap hash:/etc/postfix/relay_password
</code></p>

<p>さらに、エンベロープのFromがプロバイダから提供されたメールアドレスでないと
メールをリレーしてくれないので、
すべてのメールのFromをすべて書き換えるよう設定します。</p>

<p><code>plain /etc/postfix/canonical
/.*/ hogehoge@example.com
</code></p>

<p>最後にPostfixに設定を読み込ませて設定完了。
cron からメールを送れるようになるはず。</p>

<p><code>bash command
$ sudo /etc/init.d/postfix reload
</code></p>

<p>・・・この設定にたどり着くのに非常に苦労した。
メールなんてもう嫌だ・・・。</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.cohtan.org/2009/03/postfixtofrom.html">PostfixでメールのToやFromを書き換える方法</a></li>
<li><a href="http://www.maruko2.com/mw/Postfix_%E3%81%A7%E3%83%A1%E3%83%BC%E3%83%AB%E3%83%AA%E3%83%AC%E3%83%BC%E3%81%AE%E8%A8%AD%E5%AE%9A_(SMTP_%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88_%2B_SMTP_Auth">Postfix でメールリレーの設定 (SMTP クライアント + SMTP Auth)</a>)</li>
<li><a href="http://www.limemo.net/blog/2013/02/raspberry-pi-not-working-cron-on-raspbian.html">【トラブル】raspberry pi(ラズベリーパイ)を使ってみる - raspbianでcronがうまく動かないような…?</a>

<ul>
<li>Sendmailでの設定。なぜかうまく行かなかった。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RaspberryPiでhttps通信が失敗するのを何とかする]]></title>
    <link href="http://shogo82148.github.io/blog/2013/05/12/raspberry-pi-https-connection/"/>
    <updated>2013-05-12T16:48:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/05/12/raspberry-pi-https-connection</id>
    <content type="html"><![CDATA[<p>RaspberryPiをネットつないでみたので、PythonからいろんなURLを叩いて遊んでいたんだけど、
一部のhttps通信が Connection Timed Out で失敗しちゃう。
プログラムの問題かと思ったけど、curlで叩いてもやっぱりタイムアウト。
Macで全く同じ事をするとうまくいく・・・。
いろいろ調べて、何とかしてみたお話。</p>

<!-- More -->


<h2>原因</h2>

<p>接続先がTLSv1にしか対応していないのにSSLv3でアクセスしようとしていたことが問題だったらしい。
明示的にTLSv1を使うように指定して curl を叩いてみるとうまくいった。</p>

<p><code>bash
$ curl --tlsv3 https://hogehoge
</code></p>

<p>なぜRaspberryPiではダメで
Macでは成功するのか、という根本的な原因はよくわからなかった。
SSLv3に対応していないなら自動的にフォールバックしてくれてもよさそうなものだけど、
なぜうまく行かないんだろう・・・？</p>

<h2>Pythonでの対処</h2>

<p>PythonでもTLSv3を使えばうまくいくはずなんだけど、
暗号化方式を指定するオプションは見当たらない(2.7での話)。
どうやら標準ライブラリのファイルを直接書き換えるか、
実行時に中身を入れ替えるかしないとできないみたいだ。
この問題普通のUbuntuでも起こるらしく、
そのフォーラムで置き換えコードを見つけた。</p>

<p>``` python
import httplib
from httplib import HTTPConnection, HTTPS_PORT
import ssl</p>

<p>class HTTPSConnection(HTTPConnection):</p>

<pre><code>"This class allows communication via SSL."
default_port = HTTPS_PORT

def __init__(self, host, port=None, key_file=None, cert_file=None,
        strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None):
    HTTPConnection.__init__(self, host, port, strict, timeout,
            source_address)
    self.key_file = key_file
    self.cert_file = cert_file

def connect(self):
    "Connect to a host on a given (SSL) port."
    sock = socket.create_connection((self.host, self.port),
            self.timeout, self.source_address)
    if self._tunnel_host:
        self.sock = sock
        self._tunnel()
    # this is the only line we modified from the httplib.py file
    # we added the ssl_version variable
    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_TLSv1)
</code></pre>

<h1>now we override the one in httplib</h1>

<p>httplib.HTTPSConnection = HTTPSConnection</p>

<h1>ssl_version corrections are done</h1>

<p>```</p>

<p>これを通信開始前に読みこめば、あとは<code>urllib</code>で読み込めるようになるはず。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.abe3.net/2012/12/ruby-https-error/">RubyでHTTPS通信に失敗したのでcURLで対処した</a></li>
<li><a href="http://askubuntu.com/questions/116020/python-https-requests-urllib2-to-some-sites-fail-on-ubuntu-12-04-without-proxy">Python HTTPS requests (urllib2) to some sites fail on Ubuntu 12.04 without proxy</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
