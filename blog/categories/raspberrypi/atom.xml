<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RaspberryPi | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.com/blog/categories/raspberrypi/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.com/"/>
  <updated>2013-05-12T21:36:43+09:00</updated>
  <id>http://shogo82148.github.com/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RaspberryPiでhttps通信が失敗するのを何とかする]]></title>
    <link href="http://shogo82148.github.com/blog/2013/05/12/raspberry-pi-https-connection/"/>
    <updated>2013-05-12T16:48:00+09:00</updated>
    <id>http://shogo82148.github.com/blog/2013/05/12/raspberry-pi-https-connection</id>
    <content type="html"><![CDATA[<p>RaspberryPiをネットつないでみたので、PythonからいろんなURLを叩いて遊んでいたんだけど、
一部のhttps通信が Connection Timed Out で失敗しちゃう。
プログラムの問題かと思ったけど、curlで叩いてもやっぱりタイムアウト。
Macで全く同じ事をするとうまくいく・・・。
いろいろ調べて、何とかしてみたお話。</p>

<!-- More -->


<h2>原因</h2>

<p>接続先がTLSv1にしか対応していないのにSSLv3でアクセスしようとしていたことが問題だったらしい。
明示的にTLSv1を使うように指定して curl を叩いてみるとうまくいった。</p>

<p><code>bash
$ curl --tlsv3 https://hogehoge
</code></p>

<p>なぜRaspberryPiではダメで
Macでは成功するのか、という根本的な原因はよくわからなかった。
SSLv3に対応していないなら自動的にフォールバックしてくれてもよさそうなものだけど、
なぜうまく行かないんだろう・・・？</p>

<h2>Pythonでの対処</h2>

<p>PythonでもTLSv3を使えばうまくいくはずなんだけど、
暗号化方式を指定するオプションは見当たらない(2.7での話)。
どうやら標準ライブラリのファイルを直接書き換えるか、
実行時に中身を入れ替えるかしないとできないみたいだ。
この問題普通のUbuntuでも起こるらしく、
そのフォーラムで置き換えコードを見つけた。</p>

<p>``` python
import httplib
from httplib import HTTPConnection, HTTPS_PORT
import ssl</p>

<p>class HTTPSConnection(HTTPConnection):</p>

<pre><code>"This class allows communication via SSL."
default_port = HTTPS_PORT

def __init__(self, host, port=None, key_file=None, cert_file=None,
        strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None):
    HTTPConnection.__init__(self, host, port, strict, timeout,
            source_address)
    self.key_file = key_file
    self.cert_file = cert_file

def connect(self):
    "Connect to a host on a given (SSL) port."
    sock = socket.create_connection((self.host, self.port),
            self.timeout, self.source_address)
    if self._tunnel_host:
        self.sock = sock
        self._tunnel()
    # this is the only line we modified from the httplib.py file
    # we added the ssl_version variable
    self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_TLSv1)
</code></pre>

<h1>now we override the one in httplib</h1>

<p>httplib.HTTPSConnection = HTTPSConnection</p>

<h1>ssl_version corrections are done</h1>

<p>```</p>

<p>これを通信開始前に読みこめば、あとは<code>urllib</code>で読み込めるようになるはず。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.abe3.net/2012/12/ruby-https-error/">RubyでHTTPS通信に失敗したのでcURLで対処した</a></li>
<li><a href="http://askubuntu.com/questions/116020/python-https-requests-urllib2-to-some-sites-fail-on-ubuntu-12-04-without-proxy">Python HTTPS requests (urllib2) to some sites fail on Ubuntu 12.04 without proxy</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
