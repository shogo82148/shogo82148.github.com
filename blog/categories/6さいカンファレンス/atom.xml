<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 6さいカンファレンス | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/6さいカンファレンス/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2013-10-13T23:30:01+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[6さいカンファレンス 第9回「マスタリングの技法 ～音圧を上げよう～」まとめ]]></title>
    <link href="http://shogo82148.github.io/blog/2012/11/09/6saiconf-9/"/>
    <updated>2012-11-09T00:13:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/11/09/6saiconf-9</id>
    <content type="html"><![CDATA[<p>2012/11/8に<a href="https://twitter.com/kuina_tesso">くいなちゃん</a>さん主催で開催された6さいカンファレンスのまとめ。
第9回は「マスタリングの技法 ～音圧を上げよう～」です。</p>

<p>勝手にまとめてしまったので、何か問題があれば<a href="https://twitter.com/shogo82148">@shogo82148</a>まで。</p>

<!-- More -->


<h2>よるほー</h2>

<p>くいなちゃん: みなさん、自分が作った曲が、市販のCDの曲にくらべ、
音量が小さい (最大まで波形を上げたにも関わらず)と悩んだことはありませんか？</p>

<p>くいなちゃん: しかし、心配はいりません。
今回のことを実践していただくと、
みなさんの曲も、市販の楽曲並みに、音圧をあげることができるですん！
では次の波形をご覧ください。</p>

<p>くいなちゃん: <a href="http://kuina.tes.so/6saiconf_9/img0.png">http://kuina.tes.so/6saiconf_9/img0.png</a>
はい、さっき作った曲です。
いい曲ですね！
しかし、なんだか音量が小さいですね…
それでは、波形に注目してください。
この図では、波形が-1.0～1.0 の範囲で
示されていますが、この範囲に比べ、明らかに波形が小さいです。
余白が空きすぎです！</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img0.png" alt="くいなちゃんさんが作った曲" /></p>

<p>くいなちゃん: え、mp3ファイルがどこにあるかって？
ｷﾆｼﾅｲ!
では、とりあえず、この波形を -1.0～1.0 まで拡大してみましょう。
<a href="http://kuina.tes.so/6saiconf_9/img1.png">http://kuina.tes.so/6saiconf_9/img1.png</a>
はい、赤い矢印で示されたところが、確かに-1.0～1.0 の範囲に到達していますね。
素人さんは、この状態で完成、と思うでしょう。
しかし、それではダメダメですん☆</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img1.png" alt="拡大してみた" /></p>

<p>くいなちゃん: なぜなら、緑の2本線で示された範囲がメインの波形であって、
そこから飛び出た いわゆる魚の骨は、音量を上げる邪魔をするものだからです。
この魚の骨さえなければ、もっと音量が上がるのに…そう考えてください。</p>

<p>くいなちゃん: 市販のCD の音楽なんかは、こんな波形をしています。
<a href="http://kuina.tes.so/6saiconf_9/img2.png">http://kuina.tes.so/6saiconf_9/img2.png</a>
これは、全体が波形で埋まった、いわゆる海苔みたいなことになっているので、
業界でもしばしば 海苔 と言われます。
ここまで来ると、相当 音量が大きく聞こえます。
波形のピークは、魚の骨と同じなんですけどね。</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img2.png" alt="市販のCDの波形" /></p>

<p>くいなちゃん: で、素人さんは、この状態にしようと、魚の骨を無視して、
波形のレベルを上げるわけです。
しかし、これには問題があるのです。</p>

<p>くいなちゃん: <a href="http://kuina.tes.so/6saiconf_9/img3.png">http://kuina.tes.so/6saiconf_9/img3.png</a>
この図を見ればわかるのですが、青のラインが -1.0 ～ 1.0 の範囲をしめしています。
で、無理やり波形を拡大すると、青のラインを超えた部分が潰されて、
右の波形のようなことになってしまいます。これは、元の波形から変わっているので、
当然音も変わります。大抵、ノイズが入った汚い音になってしまいますですー</p>

<p>くいなちゃん: じゃあ、どうするのか。
それは、波形を潰すことなく、波形のピークを下げて
-1.0 ～ 1.0 の範囲に余白を作り、更に音量を上げる余地を作ればいいのです☆
では、そのための具体的に手法を、説明しましょう。</p>

<h2>聞こえない音を削る</h2>

<p>くいなちゃん: まず、この図を見てください。
<a href="http://kuina.tes.so/6saiconf_9/img4.png">http://kuina.tes.so/6saiconf_9/img4.png</a>
左の複雑な波形も、実は 単純なサイン波の集まりであることが、数学的に証明されています。
つまり、どんな曲も、高低さまざまな周波数のサイン派 が集まってできているというわけなのです。</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img4.png" alt="サイン波" /></p>

<p>くいなちゃん: よく皆さんが目にするイコライザ というのは、この周波数ごとに波形を分解したものです。
<a href="http://kuina.tes.so/6saiconf_9/img5.png">http://kuina.tes.so/6saiconf_9/img5.png</a>
左になるほど、周波数が低く(低い音)、右にいくほど高く(高い音)なっています</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img5.png" alt="イコライザ" /></p>

<p>くいなちゃん: ２つあるのは、ステレオだからですん☆
で、人間の耳は、このうち 60Hz ～ 16000Hz 程度の音を聴くことができます。
本当はもうちょっと聴くことができる人もいるんですが、大体この程度と考えてください。</p>

<p>くいなちゃん: ということは逆に言えば、60Hz未満、16000Hz以上の音は、
カットしても判らないということです。
<a href="http://kuina.tes.so/6saiconf_9/img6.png">http://kuina.tes.so/6saiconf_9/img6.png</a>
聴こえない音のくせに、波形データには含まれていますので、これを削るだけで、
少しは波形のピークも減らせるはずなのです☆(理論値)</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img6.png" alt="周波数カット" /></p>

<p>くいなちゃん: 実際に削ってみましょう。
どんなイコライザを使ってくださっても構いません。
くいなちゃんは、愛用のイコライザで削りました。
http://kuina.tes.so/6saiconf_9/img7.png
この曲線を見ても、60～16000Hz 外を削っていることが解りますね。</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img7.png" alt="くいなちゃんさん愛用のイコライザ" /></p>

<p>くいなちゃん: 気になる波形の変化を見てみましょう。
<a href="http://kuina.tes.so/6saiconf_9/img8.png">http://kuina.tes.so/6saiconf_9/img8.png</a>
おや、さっき -1.0～1.0 に到達していた赤矢印の部分に、ちょっと余裕が生まれていますね！
ということは、このぶんだけ、さらに全体の音量を上げてもOKということなのです☆
音圧が上がりますね</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img8.png" alt="削った後の波形" /></p>

<h2>波形を潰さずピークを減らす</h2>

<p>くいなちゃん: 次に、波形を潰すことなく、ピークを減らす方法を考えてみましょう。
<a href="http://kuina.tes.so/6saiconf_9/img9.png">http://kuina.tes.so/6saiconf_9/img9.png</a>
(1) は元データ、(2) は素人が無理やり波形を上げて潰したもの、(3) は潰さずに波形の高さを低くしたものです。
(3) は、下に描かれている通り、青線の超過部分の割合を1/3にしています。
これだけで、ノイズが乗ることなく、波形のピークを綺麗に抑えることができるのですん☆</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img9.png" alt="波形を潰さずピークを減らす" /></p>

<p>くいなちゃん: それを実現するのが、コンプレッサ (コンプ) です。
<a href="http://kuina.tes.so/6saiconf_9/img10.png">http://kuina.tes.so/6saiconf_9/img10.png</a>
こんな感じの画面が一般的です。
基本的なパラメータは、スレッショルド、アタック、リリース、レシオ、ゲイン　になります。
それぞれ説明します。</p>

<p><img src="http://kuina.tes.so/6saiconf_9/img10.png" alt="コンプレッサ" /></p>

<p>くいなちゃん: スレッショルドは、さっきの絵の青線に相当するものです。
どのレベルから波形を圧縮し始めるのかを指定します。
アタックは、スレッショルドを波形が超えてから、圧縮し始めるまでの時間です。音圧を上げる場合は、すぐ圧縮したいので、一番短くしましょう。
リリースは、圧縮する必要がなくなってから、圧縮をやめるまでの時間です。
これもなるべく短くすべきですが、あまりに短いとノイズが乗るので、綺麗になるよう調整してください。</p>

<p>くいなちゃん: レシオは、圧縮率です。
この図では、5.00 になっていますが、これは 1/5 に圧縮することを意味します。
1/3 にしたい場合は、3.00 にします。
ゲインは、この装置(コンプ)から波形を吐くときに、ついでに音量を上げることができるんですが、その値です。
ここで注意なのは、ゲインで上げると、結局素人さんが波形の音量を無理やり上げるのと同じことなので、これに頼っては意味がないということです。
基本的な考え方としては、波形を圧縮してピークを下げる→ピークが下がったぶんだけ全体を上げるという流れですね</p>

<p>くいなちゃん: また、かなり多くの人がここで罠にかかるのですが、魚の骨部分だけを圧縮してください。
本体の波形を圧縮してはいけません。
というのは、本体を圧縮すると、全体の音量が下がってしまいますので、全体の音量が下がる→ゲインで上げる＝もとの音量と変わらない
ということになってしまい、結局音がコンプによって圧縮されただけという結果になります。
もちろん、それが目的なら良いのですが、音圧を稼ぎたい場合は避けましょう。</p>

<p>くいなちゃん: ついでに言うと、安っぽい音源を使ったせいで、音が薄っぺらいなー
という人は、このコンプで本体の波形を圧縮すると、そこそこ迫力のある太い音に変化しますのでオススメです。
軽くその楽器にリバーブをかけると、効果倍増ですん☆
いろいろ試してみてください</p>

<p>くいなちゃん: はい、以上のことをするだけで、波形のピークが減ります。
あとは、ひたすら音量を上げていき、ノイズが乗る寸前まで音量を上げると そこそこ音圧のある曲になります。
また、パートごとにコンプをかけてピークを下げておくと、一層音圧は上がりますね。
では、ここからちょっと上級者向けのテクに突入です。</p>

<p>くいなちゃん: とその前に、ここまで質問はないですかー生きてます？？</p>

<p>くいなちゃん: どうやら、このまま進むと
みなさん 息しなくなりそうなので、上級者向けテクは
くいなちゃんの心の中にしまっておいて、今日はこの辺にしましょうか。
というわけで、以上ですんーおしまい！</p>

<h2>実際やってみよう</h2>

<p>信号処理とかの授業でフーリエ変換とか扱ったことはあるのですが，
コンプレッサのお話とか今回のカンファレンスで初めて知りました．
音楽とか僕には難しいです・・・．</p>

<p>しかし，そのためのツールを作る事ならできます！
現在策定が進んでいる Web Audio を使えばブラウザから音を簡単に出すことができます．
そして，周波数フィルタとかコンプレッサもはじめから付いているので，
設定をちょこちょこっと書いてあげるだけでこれらの機能を簡単に使うことが可能です．</p>

<p>ということで簡単なツールを作ってみました．
Chomeのみ対応です．
音楽ファイルをドラッグアンドドロップで元の音楽を読み込みます．
元の音楽→Lowパスフィルタ→Highパスフィルタ→コンプレッサ→音量調整，
の順番で音を加工します．
上の画面は音の波形，下は周波数アナライザの結果です．
灰色が元の音，緑が加工後を表しています．
スクロールバーを動かして遊んでみてください．</p>

<p><canvas id="timeDomain" width="800" height="300" style="max-width:100%"></canvas>
<canvas id="frequency" width="800" height="300" style="max-width:100%"></canvas>
<input id="play" type="button" value="Play"></p>

<div>Gain:<span id="gainValue">1</span></div>


<p><input id="gain" type="range" min="0" max="200" value="10" style="width:100%"></p>

<div>High Pass Filter:<span id="lowValue">0</span>Hz</div>


<p><input id="lowFreq" type="range" min="1" max="2000" value="2" style="width:100%"></p>

<div>Low Pass Filter:<span id="highValue">0</span>Hz</div>


<p><input id="highFreq" type="range" min="1" max="2000" value="1600" style="width:100%"></p>

<div>Threshold:<span id="thresholdValue">0</span>dB</div>


<p><input id="threshold" type="range" min="-600" max="0" value="0" style="width:100%"></p>

<div>Ratio:<span id="ratioValue">0</span>dB</div>


<p><input id="ratio" type="range" min="0" max="30" value="10" style="width:100%"></p>

<div id="reduction"></div>


<script src="http://shogo82148.github.io/files/2012-11-09-6saiconf-9.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6さいカンファレンス 第7回「Windowsのアプリをクラックしよう！(再)」まとめ]]></title>
    <link href="http://shogo82148.github.io/blog/2012/10/27/6saiconf-7/"/>
    <updated>2012-10-27T18:21:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/10/27/6saiconf-7</id>
    <content type="html"><![CDATA[<p>2012/10/25に<a href="https://twitter.com/kuina_tesso">くいなちゃん</a>さん主催で開催された6さいカンファレンスのまとめ。
第7回は「Windowsのアプリをクラックしよう！(再)」です。</p>

<p>第4回「Windowsのアプリをクラックしよう！」はどこへいってしまったのでしょう？
頑張って探したけどこれしか情報が無い・・・？</p>

<blockquote class="twitter-tweet" lang="ja"><p>昨日の ６さいカンファレンスは盛り上がりましたね (第４回 「Windowsのアプリをクラックしよう！」)　　　来週は、作曲講座をしようと思っています。　お楽しみに☆　<a href="https://twitter.com/search/%236saiconf">#6saiconf</a></p>&mdash; くいなちゃんさん (@kuina_tesso) <a href="https://twitter.com/kuina_tesso/status/251553054753701888" data-datetime="2012-09-28T05:24:56+00:00">9月 28, 2012</a></blockquote>


<script src="http://shogo82148.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>厳しい緘口令が敷かれているのか，参加者がくいなちゃんさんしか居なかったのか，そもそもそんなのなかったのか・・・．</p>

<p>勝手にまとめてしまったので、何か問題があれば<a href="https://twitter.com/shogo82148">@shogo82148</a>まで。
(カンファレンスの内容には<a href="https://twitter.com/kuina_tesso/status/211885730174222336">くいなちゃんライセンス</a>が適用されるらしいです．怖！)</p>

<!-- more -->


<h2>-----ｷﾘﾄﾘｾﾝ-----</h2>

<p>くいなちゃん: 10/25(木) 21:00 から、第７回 ６さいカンファレンスを開催します。
テーマは、「Windowsのアプリをクラックしよう！(再)」 です。
<strong> (再) と付いていますが、前回やった記憶はございません。 </strong>
参加されない方は、今のうちにご退場お願いします。
ROMでの参加も歓迎ですん☆
それでは、もうしばらくお待ちください。</p>

<p>くいなちゃん: それでは、第７回　６さいカンファレンスを開催します。
テーマは、「Windowsのアプリをクラックしよう！(再)」　ですん☆
しかし、これを開始する前に、いくつかの免責事項をお伝えしなければなりません。
(６さい的な事情)</p>

<p>くいなちゃん: まず、実際に既存の Windowsアプリをクラックする、という流れで
話を進めていきますが、実際にクラックを行っているわけではなく、
また画像も合成です。
実際に既存のアプリに対してクラックする行為は、
場合によっては犯罪となりますので、<strong> 決してマネしないでください </strong>。
本講座は、犯罪を助長する意図があるわけではなく、
むしろ攻撃側を知ることで、防衛スキルを身に着けようというものです！</p>

<h2>マインスイーパ！</h2>

<p>くいなちゃん: はい、よろしいでしょうか。
では、本日クラックするアプリはこちらです！
<a href="http://kuina.tes.so/6saiconf_7/img0.png">http://kuina.tes.so/6saiconf_7/img0.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_7/img0.png" alt="マインスイーパ" /></p>

<p>くいなちゃん: みなさん大好きな、マインスイーパですん☆
くいなちゃんは、マインスイーパが得意ではないので、上級をクリアする頃には、
時間が999になってしまいます。
そこで、この時間が経過しないよう、改造することを今日の目標としましょう。</p>

<p>くいなちゃん: まず、<a href="http://www.ollydbg.de/">ollydbg</a> というフリーソフトを起動します。
これは、主に アプリをクラックするのに使われるソフトです[要出典]
<a href="http://kuina.tes.so/6saiconf_7/img1.png">http://kuina.tes.so/6saiconf_7/img1.png</a>
画像は、<a href="http://www.ollydbg.de/">ollydbg</a> 上でマインスイーパを起動したところです。</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img1.png" alt="OllyDbg" /></p>

<p>くいなちゃん: ollydbg には、ウインドウがいくつか分かれていますが、
簡単に説明すると、左上が exeファイルを逆アセンブルしたコード、
左下が 実行時のメモリの内容、右上が CPUのレジスタの内容、
右下は…　コールスタックみたいに見えるけど、よくわからないからキニシナイ！</p>

<p>くいなちゃん: ではここで、もう一つ フリーソフトを起動しましょう。
<a href="http://www.vector.co.jp/soft/win95/hardware/se254476.html">スペシャルねこまんま５７号</a>　という、アレなアイコンとタイトルのソフトです。
主に、実行しているアプリのメモリを監視したり書き換えたりするのに使います。
<a href="http://kuina.tes.so/6saiconf_7/img2.png">http://kuina.tes.so/6saiconf_7/img2.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_7/img2.png" alt="スペシャルねこまんま５７号" /></p>

<h2>経過時間を格納している変数を捜索</h2>

<p>くいなちゃん: このソフトは、ゲームのスコアをいじったり、RPGのパラメータを999にしたりするのに重宝します。
画像は、マインスイーパの時間が 010 になった瞬間に、マインスイーパのメモリ上から 10 である部分を全部探索して、右下にリストアップしているところです (8026件)</p>

<p>くいなちゃん: 更に、時間が020になった瞬間に、20 のメモリを探索し…
とだんだん目的のメモリアドレスを絞り込んでいきます。
そしてついに、経過時間を格納している変数が割り当てられているメモリのアドレスを突き止めました！
<a href="http://kuina.tes.so/6saiconf_7/img3.png">http://kuina.tes.so/6saiconf_7/img3.png</a>
1件に絞られていますね。　中央のウインドウは、該当メモリの前後の様子です。</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img3.png" alt="変数発見！" /></p>

<p>くいなちゃん: この中央のウインドウの値を直接いじっても、値が反映されますので、RPGのパラメータを999にしたいときは、ここをいじれば ok です。
しかし今回は、時間経過で1ずつ増加されていくプログラムそのものを書き換えたいので、この値は放置します。
重要なのは、このメモリのアドレスが、0x0100579c であることです☆</p>

<h2>ブレークポイントを設定</h2>

<p>くいなちゃん: というわけで、ollydbg に戻って、左下ウインドウにあるメモリ上から、例の 0x0100579c を見つけます
<a href="http://kuina.tes.so/6saiconf_7/img4.png">http://kuina.tes.so/6saiconf_7/img4.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_7/img4.png" alt="変数発見！" /></p>

<p>くいなちゃん: ありましたか。　6A 01 という値になっている箇所がありますね。
ここを選択し、この値が書き換えられたらプログラムが一時停止するように、ブレークポイントを仕掛けます。
つまり、マインスイーパで時間が経過するときに 1 ずつ加算されているプログラムの箇所を突き止めようというものです。</p>

<p>くいなちゃん: はい、この画像は既にブレークポイントが設定され、マインスイーパが罠にかかった瞬間のスナップです。
左上のウインドウを見ると、一番上に <code>INC DWORD PTR DS:[100579C]</code>とありますね。
これは、メモリ 100579C 番地を INC (1ずつ加算する命令) することから、目的のプログラムであることが解ると思います</p>

<p>くいなちゃん: まあ、C言語っぽく言いますと、<br>
<code>int time; // 100579C番地に割り当てられる</code> <br>
<code>time++; // 例の箇所</code><br>
という感じでしょうか。</p>

<h2>exeファイルを改造</h2>

<p>くいなちゃん: では、いよいよプログラムの問題の箇所が特定できたので、マインスイーパのexeファイルを改造するですよー☆
Visual Studio 付属の、exeダンプを使って、マインスイーパの構造をテキストファイルに吐き出します。
<a href="http://kuina.tes.so/6saiconf_7/img5.png">http://kuina.tes.so/6saiconf_7/img5.png</a>
このexeダンプは、逆アセンブルしたり、いろいろ使い道があります。</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img5.png" alt="数万円から数十万円するあれ" /></p>

<p>くいなちゃん: 吐き出したテキストファイルがこちらです
<a href="http://kuina.tes.so/6saiconf_7/img6.png">http://kuina.tes.so/6saiconf_7/img6.png</a>
左のウインドウは、exeファイルのヘッダ情報になります。
まあ、今回はあまり気にしなくてokです。
右上は、exeファイルの、実際のプログラムが格納されている部分の情報になります。 file pointer to raw data を見ると、00000400 to 00003fff となっています。
また、virtual address は 01001000 to 01004a55 となっています。
これは、実行ファイル(バイナリ) の 400byte～ が、実行時の 01001000番地～ に割り付けられるということを意味しています。</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img6.png" alt="ダンプ結果" /></p>

<p>くいなちゃん: 先ほどの <code>INC DWORD…</code>という命令は、メモリ上の 01002FF5 に存在していました
(確認していなかったので、気になる人は<a href="http://kuina.tes.so/6saiconf_7/img4.png">img4.png</a> に戻ってください)
右下のウインドウは、exeファイルの機械語バイナリとなっていますが、01002FF5 の例の命令を選択しています。
<a href="http://kuina.tes.so/6saiconf_7/img4.png">img4.png</a> の命令(機械語) と一致していることが解ると思います。
確認してみてください。</p>

<p>くいなちゃん: はい、実行メモリ上の 01001000番地が、プログラムの 400byte部分に相当するとさっき解りました。
ということなので、01002FF5 という、例の命令の番地は、01002FF5 - 01001000 + 400 = 23F5 byte に存在することになりますね。
バイナリエディタで マインスイーパのexeファイルを開き、23F5 byte 目を確認してみましょう。
<a href="http://kuina.tes.so/6saiconf_7/img7.png">http://kuina.tes.so/6saiconf_7/img7.png</a>
ありましたね！</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img7.png" alt="バイナリエディタで確認" /></p>

<p>くいなちゃん: つまり、これが、くいなちゃんを苦しめていた 時間経過命令なのです！
この忌まわしい命令は、さっさと無効化しちゃいましょう。
<a href="http://kuina.tes.so/6saiconf_7/img8.png">http://kuina.tes.so/6saiconf_7/img8.png</a>
90 で埋めました。　90 というのは、機械語で <code>NOP</code> を意味し、何もしない命令になります。
とりあえず、迷ったら 90 で埋めることを覚えましょう。</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img8.png" alt="NOP埋め" /></p>

<h2>クラック成功！</h2>

<p>くいなちゃん: これにより見事、時間経過命令は、NOPで埋められ、無効化されたので、このように時間経過しなくなりました。
<a href="http://kuina.tes.so/6saiconf_7/img9.png">http://kuina.tes.so/6saiconf_7/img9.png</a>
ずっと時間は 1 のままですん☆
ハイスコアが狙えますね！！</p>

<p><img src="http://kuina.tes.so/6saiconf_7/img9.png" alt="クラック成功" /></p>

<p>くいなちゃん: というわけで、このような感じで Windowsアプリをクラックすることができます。
今回は、マインスイーパの時間経過を止めるだけでしたが、この応用で、有料アプリのパスワードをクラックしたり、技術的には色々できます。
ただ、最初でも言いましたが、クラックできることと、実際にすることは違います。
素晴らしいアプリであれば 作者に対価を支払うべきでしょうし、素晴らしくないなら そもそも使うべきではありません。
本講義では、このような攻撃手段を知ることで、自分がアプリを作るときに どうすればクラックされるのを防ぐことができるのかを考えるきっかけとなればと思い行いました。
くれぐれも悪用はしないでくださいね☆</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6さいカンファレンス 第6回「幼女を描いてみよう！　～原画から彩色まで～」まとめ]]></title>
    <link href="http://shogo82148.github.io/blog/2012/10/12/6saiconf-6/"/>
    <updated>2012-10-12T00:28:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/10/12/6saiconf-6</id>
    <content type="html"><![CDATA[<p>2012/10/11に<a href="https://twitter.com/kuina_tesso">くいなちゃん</a>さん主催で開催された6さいカンファレンスのまとめ。
第6回は「幼女を描いてみよう！　～原画から彩色まで～」です。</p>

<p>勝手にまとめてしまったので、何か問題があれば<a href="https://twitter.com/shogo82148">@shogo82148</a>まで。
(カンファレンスの内容には<a href="https://twitter.com/kuina_tesso/status/211885730174222336">くいなちゃんライセンス</a>が適用されるらしいです．怖！)</p>

<!-- more -->


<h2>ゆるふわ☆タイム</h2>

<p>くいなちゃん: 今日も、前回と引き続き、プログラミングのプの字も出てこない、ゆるふわ講義ですん☆</p>

<p>くいなちゃん: テーマは 「幼女を描いてみよう！　～原画から彩色まで～」 ということなので、今回描いてみた絵を、いきなり完成形からご覧いただくことにします。
３時間で描いたです。
<a href="http://kuina.tes.so/6saiconf_6/img0.jpg">http://kuina.tes.so/6saiconf_6/img0.jpg</a></p>

<p><img src="http://kuina.tes.so/6saiconf_6/img0.jpg" alt="幼女！" /></p>

<h2>構図を描いてみるです！</h2>

<p>くいなちゃん: では、順を追って、描いていくことにしましょう。
最初はもちろん、カンヴァスは白紙です。
そこに、まずは構図をﾃｷﾄｰに描いてみるです：
<a href="http://kuina.tes.so/6saiconf_6/img1.jpg">http://kuina.tes.so/6saiconf_6/img1.jpg</a>
はい、ここまではみなさん描けますね。
まるで６さいが描いたようなﾃｷﾄｰな落書きです。</p>

<p><img src="http://kuina.tes.so/6saiconf_6/img1.jpg" alt="構図" /></p>

<p>くいなちゃん: ここでのポイントは、脳内に立体をイメージすることです。
構図をイメージしやすいように、背景に線を引いていますが、無くてもイメージできるなら描く必要はありません。
注意してほしいのは、2D絵を描くからといって、2Dで捉えないことです。
アニメ絵でも同様ですん</p>

<p>くいなちゃん: はい、キャラに、顔と髪を追加してみました。
<a href="http://kuina.tes.so/6saiconf_6/img2.jpg">http://kuina.tes.so/6saiconf_6/img2.jpg</a>
えっ、完成形と絵が違う？
キニシナイ！
あと、独りでは寂しいので、小鳥も追加しました。</p>

<p><img src="http://kuina.tes.so/6saiconf_6/img2.jpg" alt="顔と髪と小鳥を追加" /></p>

<h2>色を塗っていくです！</h2>

<p>くいなちゃん: アニメ調の絵を描く場合は、ここからアニメ塗りをしていただけば完成しそうなんですが、せっかくなので、油彩画っぽく塗っていくことにします。</p>

<p>くいなちゃん: まずは、べた塗りです。
<a href="http://kuina.tes.so/6saiconf_6/img3.jpg">http://kuina.tes.so/6saiconf_6/img3.jpg</a></p>

<p><img src="http://kuina.tes.so/6saiconf_6/img3.jpg" alt="べた塗り" /></p>

<p>くいなちゃん: なんてことはありません。
太いブラシで、ﾃｷﾄｰに塗っただけです。
はみ出しまくってますね。　しかし、ブラシが太いので、細かな部分はそもそも塗れません。
このくらいﾃｷﾄｰでもキニシナイでok</p>

<p>くいなちゃん: 人物に影が、若干付けられていますが、原画を描くときに立体を意識したならば、光源を意識すればある程度付けられると思います。
物理学的に考えるのです！</p>

<h2>細部を塗っていくです！</h2>

<p>くいなちゃん: はい、次は、もう少し細いブラシで、細部を塗っていきます。<a href="http://kuina.tes.so/6saiconf_6/img4.jpg">http://kuina.tes.so/6saiconf_6/img4.jpg</a>
基本的には、最初に太いブラシで大まかに塗り、徐々にブラシを細くしていき、細部を描きこんでいく流れですね。
ブラシの目安は、半々にしていくと良さそうです</p>

<p><img src="http://kuina.tes.so/6saiconf_6/img4.jpg" alt="細部を塗っていく" /></p>

<p>くいなちゃん: この時点で、服に謎の模様が描かれていますが、ﾃｷﾄｰです。
その太さのブラシで表現できる粒度のものを塗ってください。</p>

<p>くいなちゃん: で、更に細いブラシで塗っていきます(3段階目)　そして、このあたりまで塗ったら、試しに線画(原画)を外してみましょう。
<a href="http://kuina.tes.so/6saiconf_6/img5.jpg">http://kuina.tes.so/6saiconf_6/img5.jpg</a>
おや、線画が無くても 綺麗に見えますね！</p>

<p><img src="http://kuina.tes.so/6saiconf_6/img5.jpg" alt="線画を外してみる" /></p>

<p>くいなちゃん: 目を描きこんでいなかったのは、意図的です。
最初のアニメ調の絵で完成させたい場合は、目も塗ってあげてください。</p>

<h2>顔を描くです！</h2>

<p>くいなちゃん: はい、それでは、もう線画が無くても輪郭が解りますので、線画は非表示にしたまま塗っていきましょう。
更に細いブラシで塗ります。</p>

<p>くいなちゃん: で、最後に、ちょー細いブラシで描きこんだらこうなりました。
<a href="http://kuina.tes.so/6saiconf_6/img6.jpg">http://kuina.tes.so/6saiconf_6/img6.jpg</a>
ついでに顔も描きこんでます。
顔の書き方は、ひたすら練習＆お勉強する必要があるので、切磋琢磨しましょう。
まあ、それは何を描くのにも当てはまるのですが。
小鳥さんにも、目を描きました。</p>

<p><img src="http://kuina.tes.so/6saiconf_6/img6.jpg" alt="顔を書き込んだところ" /></p>

<p>くいなちゃん: 塗っているときは、果たして綺麗な絵に仕上がるのか…
という不安もあると思います。
が、だんだん細いブラシで塗っているうちに、あるとき急に「絵」となる瞬間が来るのです。
信じて塗りましょう☆</p>

<h2>Pho...色調補正</h2>

<p>くいなちゃん: あとは、Pho...　色調を補正して、ﾃｷﾄｰにサインっぽいものを入れて、完成ですん☆
<a href="http://kuina.tes.so/6saiconf_6/img0.jpg">http://kuina.tes.so/6saiconf_6/img0.jpg</a>
かんたんでしょ？</p>

<div style="height:500px;">
<div style="position:relative">
<img id="image0" src="http://kuina.tes.so/6saiconf_6/img1.jpg">
<img id="image1" src="http://kuina.tes.so/6saiconf_6/img2.jpg">
<img id="image2" src="http://kuina.tes.so/6saiconf_6/img3.jpg">
<img id="image3" src="http://kuina.tes.so/6saiconf_6/img4.jpg">
<img id="image4" src="http://kuina.tes.so/6saiconf_6/img5.jpg">
<img id="image5" src="http://kuina.tes.so/6saiconf_6/img6.jpg">
<img id="image6" src="http://kuina.tes.so/6saiconf_6/img0.jpg">
</div>
</div>


<p><input type="range" id="range" min="0" max="600" value="600" style="width:100%;"></p>

<script>
window.addEventListener('load', function() {
    var i, style;
    for(i=0;i<=6;i++) {
        style = $('image' + i).style;
        style.position = 'absolute';
        style.top = '0px';
        style.left = '0px';
    }

    $("range").addEventListener('change', function() {
        var i, style, val = $('range').value / 100 + 1;
        var opacity;
        for(i=0;i<=6;i++) {
            style = $('image' + i).style;
            opacity = val - i;
            if(opacity<0) opacity = 0;
            if(opacity>1) opacity = 1;
            style.opacity = opacity;
        }
    });

    function $(name) {
        return document.getElementById(name);
    }
});
</script>


<p>くいなちゃん: 今回はデジタルでしたが、アナログで油彩画などを描く場合、今回のように線画を表示したまま塗ることはできません。
その場合、まず鉛筆などで薄く線画を描き、べた塗りの段階である程度境界をしっかりさせておき、あとは脳内で頑張る必要がありますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6さいカンファレンス 第5回「６さいからの作曲講座」まとめ]]></title>
    <link href="http://shogo82148.github.io/blog/2012/10/11/6saiconf-5/"/>
    <updated>2012-10-11T12:37:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/10/11/6saiconf-5</id>
    <content type="html"><![CDATA[<p>2012/10/04に<a href="https://twitter.com/kuina_tesso">くいなちゃん</a>さん主催で開催された6さいカンファレンスのまとめ。
第5回は「６さいからの作曲講座」です。</p>

<p>勝手にまとめてしまったので、何か問題があれば<a href="https://twitter.com/shogo82148">@shogo82148</a>まで。
(カンファレンスの内容には<a href="https://twitter.com/kuina_tesso/status/211885730174222336">くいなちゃんライセンス</a>が適用されるらしいです．怖！)</p>

<!-- more -->


<h2>THE END</h2>

<p>くいなちゃん: みなさん、楽譜は読めますね！(ﾁﾗｯ</p>

<p>くいなちゃん: 今回は、作曲理論などの難しい講義というよりも、実際にどうすれば綺麗な曲が作れるのか、という実践的な内容になっています。
くいなちゃんの独自理論ですん</p>

<p>くいなちゃん: では、さっそく、曲を作ってみましょうー</p>

<h2>コード</h2>

<p>くいなちゃん: はい、まず曲に必要なのは、　"コード"　です。　「えっ、メロディじゃ？」 と言った あなたは素人です。
コードをしっかり押さえない曲は、聴くに堪えない感じになってしまいます。
くいなちゃんは、コードもメロディも全部同時に浮かぶことのできる天才肌ですが、とりあえず今回はコードを中心に創っていきましょう！</p>

<p>くいなちゃん: コードのルール： <strong> 「あるコードには、移りやすい次のコードが ある程度決まっている」 </strong> です！
たとえば、C(ド・ミ・ソ) のコードからは、G(ソ・シ・レ) や F(略) や Am(略) に移りやすいです。　逆に、G や F から、 C にも移りやすいです。</p>

<p>くいなちゃん: ということなので、C → G → C → G　は移りやすいコードのルールで作ったので、自然なコードということになりますね。　このコードで曲を作っていきましょ！</p>

<p>くいなちゃん: はい、この楽譜をご覧ください。　C(ドミソ) と G(ソシレ) が交互に来ているのが解るかと思います。　わからない人は、じっくり読んでね。
<a href="http://kuina.tes.so/6saiconf_5/img0.png">http://kuina.tes.so/6saiconf_5/img0.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_5/img0.png" alt="コードの例" /></p>

<p>くいなちゃん: はい、コード完成です！
せっかくなので、これを鳴らしてみましょう。
<a href="http://kuina.tes.so/6saiconf_5/snd0.mp3">http://kuina.tes.so/6saiconf_5/snd0.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd0.mp3" controls></p>

<p>くいなちゃん: 自然ですね！</p>

<h2>メロディをのせる</h2>

<p>くいなちゃん: では、コードが完成したので、メロディを乗せて行きましょう。
メロディのルール： <strong> 「拍子の部分には、コードの音を使う」 </strong>  です！
さっきの、音が鳴っているタイミングの部分に、コードの音を使って、メロディを配置してみましょう。</p>

<p>くいなちゃん: <a href="http://kuina.tes.so/6saiconf_5/img1.png">http://kuina.tes.so/6saiconf_5/img1.png</a>
はい、これを見ると解る通り、メロディに使われている音は、コードの一部の音となっています。　赤く印を付けた部分が、メロディに該当するコードの音です！</p>

<p><img src="http://kuina.tes.so/6saiconf_5/img1.png" alt="メロディをつけてみた" /></p>

<p>くいなちゃん: せっかくなので、鳴らしてみましょう！
<a href="http://kuina.tes.so/6saiconf_5/snd1.mp3">http://kuina.tes.so/6saiconf_5/snd1.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd1.mp3" controls></p>

<p>くいなちゃん: はい、自然な感じですね！
ただ、ちょっと面白みの無い曲です。</p>

<h2>メロディを複雑にしてみる</h2>

<p>くいなちゃん: というわけなので、メロディを複雑にしてみましょう。
今作ったメロディの間に、音を入れていきます。
ただし、ここにもルールがあります。
間に入れるメロディのルール： <strong> 「間に入れる音は、調の音を使う」 </strong> です！</p>

<p>くいなちゃん: 「調」ってなんぞ？
と思われるかもしれません。
調とは、白い鍵盤の音のことです！(嘘)</p>

<p>くいなちゃん: 白い鍵盤の音、とは、シャープやフラットの付いていない音のことですので、楽譜上では 気にせずﾃｷﾄｰに音を配置すればOKです。
ﾃｷﾄｰに配置しましょう(音と音の間に新たな音を入れるときは、2音の間を補間するように、平均の音を埋めると良い)。
<a href="http://kuina.tes.so/6saiconf_5/img2.png">http://kuina.tes.so/6saiconf_5/img2.png</a>
赤く印を付けた音は、さっきの楽譜の音です。　さっきの楽譜の音の間に、新たな音が追加されているのが判ると思います！</p>

<p><img src="http://kuina.tes.so/6saiconf_5/img2.png" alt="メロディを複雑に" /></p>

<p>くいなちゃん: 鳴らしてみましょう！ <a href="http://kuina.tes.so/6saiconf_5/snd2.mp3">http://kuina.tes.so/6saiconf_5/snd2.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd2.mp3" controls></p>

<p>くいなちゃん: はい、メロディがちょっと複雑で、「曲」っぽくなりましたね！　基本はこんな感じです☆</p>

<h2>もっと複雑なコードに挑戦！</h2>

<p>くいなちゃん: はい、ここからは、もっと面白い曲を作りましょう。
いまどき こんな C → G → C → G　なんて面白味のｶｹﾗも無いようなコードなんて、誰も使いません。</p>

<p>くいなちゃん: 次に使うコードは、コレです！！ <a href="http://kuina.tes.so/6saiconf_5/img3.png">http://kuina.tes.so/6saiconf_5/img3.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_5/img3.png" alt="複雑なコード" /></p>

<p>くいなちゃん: ドミソ　が　C　なら、コレは一体何なんだ…！　と思われるかもしりませんが、世の中には知らないほうが良いこともあります。　鳴らしてみましょう！
<a href="http://kuina.tes.so/6saiconf_5/snd3.mp3">http://kuina.tes.so/6saiconf_5/snd3.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd3.mp3" controls></p>

<p>くいなちゃん: さっきの曲よりも、色鮮やかで豊かな響きになったと思います。　このコードで曲を作るですん☆　メロディを乗せてみましょう。</p>

<p>くいなちゃん: さっき「拍子の部分に置くメロディは、コードの音を使う」　と言いました。　ここで注目してほしいのは、　さっきは　「ドミソ」　などの 3つの音のコードでしたが、今回は　「ファラドミソ」　という 5つの音のコードです。　つまり、よりたくさんの音が、メロディに使えるのですん！</p>

<p>くいなちゃん: とりあえず、コードの音を使って、ﾃｷﾄｰに配置してみました。
<a href="http://kuina.tes.so/6saiconf_5/img4.png">http://kuina.tes.so/6saiconf_5/img4.png</a>
例によって、赤い印が、コードとメロディの対応関係です。</p>

<p><img src="http://kuina.tes.so/6saiconf_5/img4.png" alt="メロディ追加" /></p>

<p>くいなちゃん: 鳴らしてみましょう。
<a href="http://kuina.tes.so/6saiconf_5/snd4.mp3">http://kuina.tes.so/6saiconf_5/snd4.mp3</a>
さっきの曲よりも、なんだか幻想的ですね！</p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd4.mp3" controls></p>

<h2>メロディのリズムを複雑化しましょう！</h2>

<p>くいなちゃん: しかし、「リズム」が単純なせいで、せっかくの幻想的な雰囲気も台無しです。
メロディのリズムを複雑化しましょう！
基本的には、さっきの曲の時と同じく、間に音を配置していく感じですん。
赤い線で示された音が、さっき配置した音です。
<a href="http://kuina.tes.so/6saiconf_5/img5.png">http://kuina.tes.so/6saiconf_5/img5.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_5/img5.png" alt="メロディのリズムを複雑化" /></p>

<p>くいなちゃん: 鳴らすです！<a href="http://kuina.tes.so/6saiconf_5/snd5.mp3">http://kuina.tes.so/6saiconf_5/snd5.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd5.mp3" controls></p>

<p>くいなちゃん: はい、ステキな曲になりましたね！
しかし、リズムは、メロディにのみ存在しているのではありません。
伴奏のほうのリズムも、ちょっとﾃｷﾄｰに工夫してみましょう！
<a href="http://kuina.tes.so/6saiconf_5/img6.png">http://kuina.tes.so/6saiconf_5/img6.png</a></p>

<p><img src="http://kuina.tes.so/6saiconf_5/img6.png" alt="コードのリズムを複雑化" /></p>

<p>くいなちゃん: 鳴らすです！<a href="http://kuina.tes.so/6saiconf_5/snd6.mp3">http://kuina.tes.so/6saiconf_5/snd6.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd6.mp3" controls></p>

<h2>ちょっと調整</h2>

<p>くいなちゃん: まあ、こんな感じで曲を作っていきます。
そして、楽器を変えて、ちょっと調整したら、曲の完成です！：
<a href="http://kuina.tes.so/6saiconf_5/snd7.mp3">http://kuina.tes.so/6saiconf_5/snd7.mp3</a></p>

<p><audio src="http://kuina.tes.so/6saiconf_5/snd7.mp3" controls></p>

<p>くいなちゃん: はい、これで、みなさんも作曲ができるようになったと思います。
最初はこんな感じから出発し、わざと理論を踏み外してみたりと、独自の道を進まれるのが良いでしょう。
楽しんでください☆　おしまい☆　</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6さいカンファレンス 第3回「アルゴリズムを自力で生み出すプログラムを作ろう！」まとめ]]></title>
    <link href="http://shogo82148.github.io/blog/2012/10/04/6saiconf-3/"/>
    <updated>2012-10-04T16:58:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/10/04/6saiconf-3</id>
    <content type="html"><![CDATA[<p>2012/09/06に<a href="https://twitter.com/kuina_tesso">くいなちゃん</a>さん主催で開催された6さいカンファレンスのまとめ。
第3回は「アルゴリズムを自力で生み出すプログラムを作ろう！」です。</p>

<p>勝手にまとめてしまったので、何か問題があれば<a href="https://twitter.com/shogo82148">@shogo82148</a>まで。</p>

<!-- more -->




<script>
function Tree() {
   this.value = '';
   this.children = [];
}

Tree.prototype.dump = function() {
    var result = this.value;
    var i;
    for(i = 0; i < this.children.length; i++)
        result += ' ' + this.children[i].dump();
    return result;
};

Tree.prototype.calc = function(x) {
    switch(this.value) {
    case '+': return this.children[0].calc(x) + this.children[1].calc(x);
    case '-': return this.children[0].calc(x) - this.children[1].calc(x);
    case '*': return this.children[0].calc(x) * this.children[1].calc(x);
    case '/': return this.children[0].calc(x) / this.children[1].calc(x);
    case '^': return Math.pow(this.children[0].calc(x), this.children[1].calc(x));
    case 'x': return x;
    }
    return this.value * 1;
};

Tree.make = function(len) {
    var result = new Tree();
    var numchildren = 0;
    switch(len >= 5 ? 6 : (Math.random()*7|0)) {
    case 0: result.value = '+'; numchildren = 2; break;
    case 1: result.value = '-'; numchildren = 2; break;
    case 2: result.value = '*'; numchildren = 2; break;
    case 3: result.value = '/'; numchildren = 2; break;
    case 4: result.value = '^'; numchildren = 2; break;
    case 5: result.value = 'x'; numchildren = 0; break;
    default: result.value = (Math.random()*10|0)+1; numchildren = 0; break;
    }
    var i;
    for(i = 0; i < numchildren; i++)
        result.children.push(this.make(len + 1));
    return result;
};

Tree.prototype.countLeaves = function() {
    var result = 1;
    var i;
    for( i = 0; i < this.children.length; i++)
        result += this.children[i].countLeaves();
    return result;
};

Tree.prototype.copy = function(leaf, other) {
    leaf.value--;
    if(leaf.value == -1)
        return other.copy(leaf, null);
    var result = new Tree();
    result.value = this.value;
    var i;
    for(i = 0; i < this.children.length; i++)
        result.children.push(this.children[i].copy(leaf, other));
    return result;
};

Tree.prototype.select = function(leaf) {
    leaf.value--;
    if(leaf.value == -1)
        return this;
    var i, result;
    for(i = 0; i < this.children.length; i++) {
        result = this.children[i].select(leaf);
        if(result != null)
            return result;
    }
    return null;
};

function GP(genesnum) {
    this.genes = new Array(genesnum);
    var i;
    for(i=0; i<genesnum; i++)
        this.genes[i] = Tree.make(0);
    this.values = new Array(genesnum);
    this.bestgene = null;
    this.bestvalue = 0.0;
    this.refreshValues();
}

GP.prototype.refreshValues = function() {
    var i, j, v;
    for(i = 0; i < this.genes.length; i++) {
        var fx = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
        this.values[i] = 0.0;
        for(j = 0; j < fx.length; j++) {
            if(this.genes[i].countLeaves() >= 50) {
                v = 100000000;
            } else {
                v = this.genes[i].calc(j) - fx[j];
                v *= v;
            }
            if(isNaN(v)) v = 100000000;
            this.values[i] += v;
        }
        this.values[i] = 1 / this.values[i];
        if(this.bestvalue < this.values[i]) {
            this.bestvalue = this.values[i];
            this.bestgene = this.genes[i];
        }
    }
    return this.bestgene;
};

GP.prototype.getGoodGene = function() {
    var totalvalue = 0;
    var i;
    for(i = 0; i < this.genes.length; i++) {
        totalvalue += this.values[i];
    }
    var r = Math.random() * totalvalue;
    var select = 0;
    while(r >= this.values[select]) {
        r -= this.values[select];
        select++;
    }
    return this.genes[select];
};

GP.prototype.inherit = function() {
    var newgenes = [];
    var i, a, b, leafa, leafb;
    for(i = 0; i < this.genes.length; i++) {
        a = this.getGoodGene(), b;
        if(Math.random() < 0.05) {
            b = Tree.make(0);
        } else {
            b = this.getGoodGene();
        }
        if(a==b) newgenes.push(a);
        else {
            leafa = {value: Math.random()*a.countLeaves()|0};
            leafb = {value: Math.random()*b.countLeaves()|0};
            newgenes.push(a.copy(leafa, b.select(leafb)));
        }
    }
    this.genes = newgenes;
    this.refreshValues();
    return this.bestvalue;
};
</script>


<h2>WELCOME TO HEAVEN!!</h2>

<p>くいなちゃん: ところでみなさん、次の( ) に入る数を当ててください</p>

<pre><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ( )
</code></pre>

<p>くいなちゃん: はい、正解です！
これは、フィボナッチ数列と呼ばれ、
前の2つの値の和が、次の値になっているという数列です</p>

<p>くいなちゃん: これを、f(0) = 0, f(1) = 1, f(2) = 1, f(3) = 2, f(4) = 3, f(5) = 5, …
と書いていくことにしましょう。　f(10) = 55　ですね！</p>

<p>くいなちゃん: もっと汎用的に考えて、f(x) の x を与えると、フィボナッチ数が返ってくることを考えましょう。
x = 10 のとき、f(x) が 55 になる、といった感じです</p>

<p>くいなちゃん: ではみなさん、この f(x) を、プログラムで書くことはできますでしょうか。
言語は何でも構いません。</p>

<p>くいなちゃん: やり方は、いくつかあります。
x = 100 と与えられれば、0, 1, 1, 2, 3, 5, …　と 約100回繰り返して、x = 100 の値を求めるというものです。</p>

<p>くいなちゃん: しかし、これはちょっと効率が悪いですね…
x = 100000 なら、100000回計算しなくてはなりません。
理想的には、x = 100000 でも、一発で計算結果が返ってくるアルゴリズムが望ましいです。
難しい言葉で言えば、O(1) ですね。</p>

<p>くいなちゃん: そんなの無理！
って思うかもしれませんが、実は可能です。
Wikipedia で調べると、　f(x) = 1 / √5 ( ((1+√5)/2)<sup>x</sup> - ((1-√5)/2)<sup>x)　　と出てきます。</sup></p>

<p>くいなちゃん: イミフですね！
あなたがどう頭を使っても、なかなかこのアルゴリズムに到達することはできないでしょう…。</p>

<p>くいなちゃん: というわけで、今回は、
あなたが頭を使うことなしに、アルゴリズムを自動で作り出すプログラムを作ろう！
ということをしたいと思います。</p>

<p>くいなちゃん: どうやって？
と思うかもしれませんので、これからその仕組みを簡単に説明しましょう。</p>

<h2>遺伝的プログラミング</h2>

<p>くいなちゃん: まず、あなたは人間です(たぶん)。
人間は、優れた頭脳や肉体を持っていますが、これは神によって創られたものではありません(たぶん)。
生物学的な「遺伝」によって、生まれました。</p>

<p>くいなちゃん: というわけなので、これをプログラムで同じ感じにやれば、
超複雑なプログラムが、遺伝によって生まれうるのではないか！
というわけなのです</p>

<p>くいなちゃん: これを、「遺伝的プログラミング」
と呼びます。
(遺伝的アルゴリズムとはちょっと違う)</p>

<p>くいなちゃん: というわけなので、折角なので このフィボナッチ数を求めるプログラム(アルゴリズム) を、遺伝によって発見させてみることにしましょー☆</p>

<p>くいなちゃん: 次のプログラムと図をご覧ください。
<a href="http://kuina.tes.so/6saiconf_3/img0.png">http://kuina.tes.so/6saiconf_3/img0.png</a>
ここでは、四則演算と累乗が、木構造として定義されています。
(今回は、Javaですん☆)</p>

<p>``` java Tree.java http://kuina.tes.so/6saiconf_3/img0.png
public class Tree {</p>

<pre><code>public String value;
public Tree[] children;

public String dump() {
    String result = value;
    for (int i = 0; i &lt; children.length; i++)
        result += " " + children[i].dump();
    return result;
}

public double calc(double x) {
    switch (value.charAt(0)) {
    case '+': return children[0].calc(x) + children[1].calc(x);
    case '-': return children[0].calc(x) - children[1].calc(x);
    case '*': return children[0].calc(x) * children[1].calc(x);
    case '/': return children[0].calc(x) / children[1].calc(x);
    case '^': return Math.pow(children[0].calc(x), children[1].calc(x));
    case 'x': return x;
    }
    return Double.parseDouble(value);
}
</code></pre>

<p>}
```</p>

<p>くいなちゃん: <a href="/blog/2012/10/02/6saiconf-2/">前回</a>も言いましたが、くいなちゃんは ポーランド記法が好きなので、
みなさんもポーランド記法に慣れてくださいね。
例えば、ここで x*(2-3) という式は、ポーランド記法で　* x - 2 3　となり、右のような木構造になります。</p>

<p>くいなちゃん: プログラム中の dump() は、式を単に出力する関数で、calc() は、式の計算結果を返す関数になっています。
再帰使ってるけど、大丈夫かな？</p>

<h2>ランダムで式を作る</h2>

<p>くいなちゃん: で、くいなちゃんは めんどくさがり屋なので、いちいち式を作るのが嫌です。
なので、ランダムで式を作る関数を追加しましょう。
<a href="http://kuina.tes.so/6saiconf_3/img1.png">http://kuina.tes.so/6saiconf_3/img1.png</a></p>

<p>``` java Tree.java http://kuina.tes.so/6saiconf_3/img1.png
public class Tree {</p>

<pre><code>public String value;
public Tree[] children;

public String dump() {
    String result = value;
    for (int i = 0; i &lt; children.length; i++)
        result += " " + children[i].dump();
    return result;
}

public double calc(double x) {
    switch (value.charAt(0)) {
    case '+': return children[0].calc(x) + children[1].calc(x);
    case '-': return children[0].calc(x) - children[1].calc(x);
    case '*': return children[0].calc(x) * children[1].calc(x);
    case '/': return children[0].calc(x) / children[1].calc(x);
    case '^': return Math.pow(children[0].calc(x), children[1].calc(x));
    case 'x': return x;
    }
    return Double.parseDouble(value);
}

static public Tree make(java.util.Random rand, int len) {
    Tree result = new Tree();
    switch(len &gt;= 5 ? 6 : rand.nextInt(7)) {
    case 0: result.value = "+"; result.children = new Tree[2]; break;
    case 1: result.value = "-"; result.children = new Tree[2]; break;
    case 2: result.value = "*"; result.children = new Tree[2]; break;
    case 3: result.value = "/"; result.children = new Tree[2]; break;
    case 4: result.value = "^"; result.children = new Tree[2]; break;
    case 5: result.value = "x"; result.children = new Tree[0]; break;
    default: result.value = ((Integer)(rand.nextInt(10) + 1)).toString(); result.children = new Tree[0];
    }
    for (int i = 0; i &lt; result.children.length; i++)
        result.children[i] = make(rand, len + 1);
    return result;
}
</code></pre>

<p>}
```</p>

<p>くいなちゃん: バツしてるところは、さっき書いた部分なので気にしなくてokです</p>

<p>くいなちゃん: これで、+ - * / \^ x 0 1 2 3 4 5 6 7 8 9　の文字がランダムに生成されるようになりました。　make() ですね。</p>

<p>くいなちゃん: はい、では、試しにランダムで式を作って、計算させてみましょう☆
<a href="http://kuina.tes.so/6saiconf_3/img2.png">http://kuina.tes.so/6saiconf_3/img2.png</a>
画面の下のほうに実行結果が出ています。　- 4 / 2 - 10 2　= 3.75　　たしかにちゃんと計算されてそう。</p>

<p>``` java Example.java http://kuina.tes.so/6saiconf_3/img2.png
public class Example {</p>

<pre><code>public static void main(String[] args) {
    Tree tree = Tree.make(new java.util.Random(), 0);
    System.out.println(tree.dump());
    System.out.println("= " + ((Double)tree.calc(1.0)).toString());
}
</code></pre>

<p>}
```</p>

<p><input type="button" id="Example1" value="計算"></p>

<pre><code id="Example1Result"></code></pre>


<script>
document.getElementById('Example1').addEventListener('click', function() {
    var tree = Tree.make(0);
    document.getElementById('Example1Result').innerText = tree.dump() + '\n= ' + tree.calc(1.0);
}, false);
</script>


<h2>遺伝させる</h2>

<p>くいなちゃん: こんな感じで、式が木構造で表現できるようになりました！
あとは、これを遺伝させて、フィボナッチ数を求めるアルゴリズム(例の複雑な式)が求まれば、成功ですん☆</p>

<p>くいなちゃん: では、遺伝とは、具体的に何をさせるのか、説明いたしましょう。</p>

<p>くいなちゃん: まず、ランダムで作った式 1つ1つを、「遺伝子」と呼ぶことにしましょう。
遺伝子は　あらかじめ 100個くらい用意します。</p>

<p>くいなちゃん: 次に、これらの遺伝子の「子供」を作り、次の世代の遺伝子とすることにします。
次の世代も、親の世代と同じ 100個になるように調整します。</p>

<p>くいなちゃん: あとは、これを延々と繰り返していくわけですが、ここで、子孫を残す親を、「優れた遺伝子」から選ばれるような仕組みにします。
つまり、フィボナッチ数に近いような式になっている遺伝子は、親になる可能性が高くなるということです。</p>

<p>くいなちゃん: これにより、世代を重ねていくごとに、より良い遺伝子(式) になっていくことが期待できるのですー☆</p>

<p>くいなちゃん: 遺伝的プログラミングが、遺伝的アルゴリズムと異なるのは、後者が n個のデータを遺伝させるのに対し、前者は ツリー(式やプログラム)を遺伝させるということです。</p>

<p>くいなちゃん: はい、親を2人選んだら、子供が生まれるわけですが、具体的には「交叉」と「突然変異」というシステムで実現します。
<a href="http://kuina.tes.so/6saiconf_3/imga.png">http://kuina.tes.so/6saiconf_3/imga.png</a>
この図で、左側が交叉、右側が突然変異を説明しています</p>

<p>くいなちゃん: 交叉は、両親の遺伝子の一部ずつを取ってきて、子に遺伝させるということです。
しかし、ごく微小確率(ここでは5%としている) で、突然変異が起こり、デタラメな式に書き換わってしまうのです。</p>

<p>くいなちゃん: まあこれは、人間においても、遺伝子のコピーミスなどで、ガン細胞が発生したりする過程と同じですん☆</p>

<p>くいなちゃん: はい、以上をプログラムで書いたのが、これです。
Javaのせいで気分が悪くなったら、無理に読まなくて結構ですん
<a href="http://kuina.tes.so/6saiconf_3/img3.png">http://kuina.tes.so/6saiconf_3/img3.png</a></p>

<p>``` java GP.java http://kuina.tes.so/6saiconf_3/img3.png
public class GP {</p>

<pre><code>private java.util.Random rand;
private Tree[] genes;
private double[] values;
private Tree bestgene;
private double bestvalue;

public GP(int genesnum) {
    rand = new java.util.Random();
    genes = new Tree[genesnum];
    for (int i = 0; i &lt; genes.length; i++)
        genes[i] = Tree.make(rand, 0);
    values = new double[genesnum];
    bestgene = null;
    bestvalue = 0.0;
    refreshValues();
}

public Tree refreshValues() {
    for (int i = 0; i &lt; genes.length; i++) {
        // x    = 0 1 2 3 4 5 6  7  8  9 10
        // f(x) = 0 1 1 2 3 5 8 13 21 34 55
        double[] fx = {0.0, 1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0, 55.0};
        values[i] = 0.0;
        for (int j = 0; j &lt; fx.length; j++) {
            double v;
            if (genes[i].countLeaves() &gt;= 50)
                v = 100000000.0;
            else {
                v = genes[i].calc((double)j) - fx[j];
                v *= v;
            }
            if (Double.isNaN(v))
                v = 100000000.0;
            values[i] += v;
        }
        values[i] = 1.0 / values[i];
        if (bestvalue &lt; values[i]) {
            bestvalue = values[i];
            bestgene = genes[i];
        }
    }
    return bestgene;
}
</code></pre>

<p>}
```</p>

<p>くいなちゃん: とはいえ、まだこのプログラムでは、交叉と突然変異を書いていません。
ランダムで遺伝子を100個用意して、その中で フィボナッチ数に最も近そうな遺伝子が見つかるところまでです</p>

<p>くいなちゃん: とりあえず、折角ここまで書いたのでテストしてみましょう。
<a href="http://kuina.tes.so/6saiconf_3/img4.png">http://kuina.tes.so/6saiconf_3/img4.png</a>
まだ 1世代目なので、そんなに優れた遺伝子はありません。
実行例では、\^ x x　つまり　x<sup>x</sup> (xのx乗)　がフィボナッチ数列に最も近い式だ、ということになりました。
なるほど、確かにちょっと近そう…？</p>

<p>``` java Example.java http://kuina.tes.so/6saiconf_3/img4.png
public class Example {</p>

<pre><code>public static void main(String[] args) {
    GP gp = new GP(100);
    Tree tree = gp.refreshValues();
    System.out.println(tree.dump());
    for (int i = 0; i &lt; 11; i++)
        System.out.println("f(" + i + ")" + "= " + ((Double)tree.calc((double)i)).toString());
}
</code></pre>

<p>}
```</p>

<p><input type="button" id="Example2" value="計算"></p>

<pre><code id="Example2Result"></code></pre>


<script>
document.getElementById('Example2').addEventListener('click', function() {
    var gp = new GP(100);
    var tree = gp.refreshValues();
    var result = '';
    var i;
    result += tree.dump() + '\n';
    for(i = 0; i < 11; i++) {
        result += 'f(' + i + ') = ' + tree.calc(i) + '\n';
    }
    document.getElementById('Example2Result').innerText = result;
}, false);
</script>


<p>くいなちゃん: (そうでもない)</p>

<p>くいなちゃん: はい、いよいよ交叉と突然変異を追加するわけですが、
その前に、便利関数として、木のノード数を数える関数や、自分自身のコピー木を作る関数や、任意の番号のノードを取得できる関数などを、数式木のクラスに書き加えました。
<a href="http://kuina.tes.so/6saiconf_3/img5.png">http://kuina.tes.so/6saiconf_3/img5.png</a>
図をじっと見てたら、何してるかくらいは判るはず</p>

<p>``` java Tree.java http://kuina.tes.so/6saiconf_3/img5.png
public class Tree {</p>

<pre><code>public String value;
public Tree[] children;

public String dump() {
    String result = value;
    for (int i = 0; i &lt; children.length; i++)
        result += " " + children[i].dump();
    return result;
}

public double calc(double x) {
    switch (value.charAt(0)) {
    case '+': return children[0].calc(x) + children[1].calc(x);
    case '-': return children[0].calc(x) - children[1].calc(x);
    case '*': return children[0].calc(x) * children[1].calc(x);
    case '/': return children[0].calc(x) / children[1].calc(x);
    case '^': return Math.pow(children[0].calc(x), children[1].calc(x));
    case 'x': return x;
    }
    return Double.parseDouble(value);
}

static public Tree make(java.util.Random rand, int len) {
    Tree result = new Tree();
    switch(len &gt;= 5 ? 6 : rand.nextInt(7)) {
    case 0: result.value = "+"; result.children = new Tree[2]; break;
    case 1: result.value = "-"; result.children = new Tree[2]; break;
    case 2: result.value = "*"; result.children = new Tree[2]; break;
    case 3: result.value = "/"; result.children = new Tree[2]; break;
    case 4: result.value = "^"; result.children = new Tree[2]; break;
    case 5: result.value = "x"; result.children = new Tree[0]; break;
    default: result.value = ((Integer)(rand.nextInt(10) + 1)).toString(); result.children = new Tree[0];
    }
    for (int i = 0; i &lt; result.children.length; i++)
        result.children[i] = make(rand, len + 1);
    return result;
}

public int countLeaves() {
    int result = 1;
    for (int i = 0; i &lt; children.length; i++)
        result += children[i].countLeaves();
    return result;
}

public Tree copy(int[] leaf, Tree other) {
    leaf[0]--;
    if (leaf[0] == -1)
        return other.copy(leaf, null);
    Tree result = new Tree();
    result.value = value;
    result.children = new Tree[children.length];
    for (int i = 0; i &lt; children.length; i++)
        result.children[i] = children[i].copy(leaf, other);
    return result;
}

public Tree select(int[] leaf) {
    leaf[0]--;
    if (leaf[0] == -1)
        return this;
    for (int i = 0; i &lt; children.length; i++) {
        Tree result = children[i].select(leaf);
        if ( result != null)
            return result;
    }
    return null;
}
</code></pre>

<p>}
```</p>

<p>くいなちゃん: 判れ。</p>

<p>くいなちゃん: で、がんばって、交叉と突然変異を実装しました。
<a href="http://kuina.tes.so/6saiconf_3/img6.png">http://kuina.tes.so/6saiconf_3/img6.png</a>
getGoodGene は、より優れた遺伝子が高確率で選択させるようにした関数で、これで親になる遺伝子を選びます。
inherit は、交叉・突然変異を一まとめにして、「次の世代を作る遺伝処理」をする関数になっています。
突然変異は、0.05 の確率で起こることが、ソースをよく読んでたら解りますね。(ﾁﾗｯ</p>

<p>``` java GP.java http://kuina.tes.so/6saiconf_3/img6.png
public class GP {</p>

<pre><code>private java.util.Random rand;
private Tree[] genes;
private double[] values;
private Tree bestgene;
private double bestvalue;

public GP(int genesnum) {
    rand = new java.util.Random();
    genes = new Tree[genesnum];
    for (int i = 0; i &lt; genes.length; i++)
        genes[i] = Tree.make(rand, 0);
    values = new double[genesnum];
    bestgene = null;
    bestvalue = 0.0;
    refreshValues();
}

public Tree refreshValues() {
    for (int i = 0; i &lt; genes.length; i++) {
        // x    = 0 1 2 3 4 5 6  7  8  9 10
        // f(x) = 0 1 1 2 3 5 8 13 21 34 55
        double[] fx = {0.0, 1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0, 55.0};
        values[i] = 0.0;
        for (int j = 0; j &lt; fx.length; j++) {
            double v;
            if (genes[i].countLeaves() &gt;= 50)
                v = 100000000.0;
            else {
                v = genes[i].calc((double)j) - fx[j];
                v *= v;
            }
            if (Double.isNaN(v))
                v = 100000000.0;
            values[i] += v;
        }
        values[i] = 1.0 / values[i];
        if (bestvalue &lt; values[i]) {
            bestvalue = values[i];
            bestgene = genes[i];
        }
    }
    return bestgene;
}

public Tree getGoodGene() {
    double totalvalue = 0.0;
    for (int i = 0; i &lt; genes.length; i++)
        totalvalue += values[i];
    double r = rand.nextDouble() * totalvalue;
    int select = 0;
    while (r &gt;= values[select]) {
        r -= values[select];
        select++;
    }
    return genes[select];
}

public double inherit() {
    Tree[] newgenes = new Tree[genes.length];
    for (int i = 0; i &lt; genes.length; i++) {
        Tree a = getGoodGene(), b;
        if (rand.nextDouble() &lt; 0.05)
            b = Tree.make(rand, 0);
        else
            b = getGoodGene();
        if (a == b)
            newgenes[i] = a;
        else {
            int[] leafa = new int[] { rand.nextInt(a.countLeaves()) };
            int[] leafb = new int[] { rand.nextInt(b.countLeaves()) };
            newgenes[i] = a.copy(leafa, b.select(leafb));
        }
    }
    genes = newgenes;
    refreshValues();
    return bestvalue;
}
</code></pre>

<p>}
```</p>

<p>くいなちゃん: なるほど、わからん</p>

<p>くいなちゃん: はい、それでは、本当に 遺伝を繰り返すと、良い遺伝子が得られるのか、テストしてみましょう。
<a href="http://kuina.tes.so/6saiconf_3/img7.png">http://kuina.tes.so/6saiconf_3/img7.png</a>
この出力は、どの程度 フィボナッチ数列に近い遺伝子が見つかったかを示すものです(大きいほうが近い)。
なるほど、確かに、だんだん進化してますね。</p>

<p>``` java Example.java http://kuina.tes.so/6saiconf_3/img7.png
public class Example {</p>

<pre><code>public static void main(String[] args) {
    GP gp = new GP(100);
    for (int i = 0; i &lt; 50; i++)
        System.out.println(gp.inherit());
}
</code></pre>

<p>}
```</p>

<p><input type="button" id="Example3" value="計算"></p>

<pre><code id="Example3Result"></code></pre>


<script>
document.getElementById('Example3').addEventListener('click', function() {
    var gp = new GP(100);
    var i, result = '';
    for(i = 0; i < 50; i++) {
        result += gp.inherit() + '\n';
    }
    document.getElementById('Example3Result').innerText = result;
}, false);
</script>


<p>くいなちゃん: では、せっかくなので、100000回くらい遺伝させてみましょう！！</p>

<p>くいなちゃん: 100000回というと、孫の孫の孫の孫の…　と膨大な数の子孫を経た世代ということです。
恐ろしい。</p>

<p>くいなちゃん: その結果…
<a href="http://kuina.tes.so/6saiconf_3/img8.png">http://kuina.tes.so/6saiconf_3/img8.png</a>
なんかすごく近い関数が発見されました！！
右側にフィボナッチ数列を載せていますが、確かに比較すると 近いことが判ると思います。
(ただ、確かに近いけれど、なんか違う…)</p>

<p>``` java Example.java http://kuina.tes.so/6saiconf_3/img8.png
public class Example {</p>

<pre><code>public static void main(String[] args) {
    GP gp = new GP(100);
    for (int i = 0; i &lt; 100001; i++) {
        double value = gp.inherit();
        if (i % 10000 == 0)
            System.out.println(value);
    }
    Tree bestgene = gp.refreshValues();
    System.out.println(bestgene.dump());
    for (int i = 0; i &lt; 11; i++)
        System.out.println("f(" + i + ")" + "= " + ((Double)bestgene.calc((double)i)).toString());
}
</code></pre>

<p>}
```</p>

<p><input type="button" id="Example4" value="計算"></p>

<pre><code id="Example4Result"></code></pre>


<script>
document.getElementById('Example4').addEventListener('click', function() {
    var gp = new GP(100);
    var i, result = [];

    for(i=0;i<20;i++) result.push('');

    i = 0;
    setTimeout(function loop() {
        if(i>100000) {
            var tree = gp.refreshValues();
            println(tree.dump());
            for(i = 0; i < 11; i++) {
                println('f(' + i + ') = ' + tree.calc(i));
            }
            return ;
        }
        var value = gp.inherit();
        if(i % 100 == 0) {
            println(i + ': ' + value);
        }
        i++;
        setTimeout(loop, 0);
    }, 0);

    function println(s) {
       result.push(s);
       result.shift();
       document.getElementById('Example4Result').innerText = result.join('\n');
    }
}, false);
</script>


<p>くいなちゃん: その式とは、　+ x + / x 4 / * …　　と続く、大変意味不明な式です。
なんですか、この式は…？</p>

<p>くいなちゃん: 期待していた、最初のほうで言った式とは、なんか違いますよね…　気のせいかな？</p>

<p>くいなちゃん: とは言っても、ポーランド記法に慣れていない 皆さんは、ぱっと見ても解らないと思います。　なので、普通の式に整理して書き直してみました☆</p>

<p>くいなちゃん: 今回、このプログラムが発見した フィボナッチ数列の式とは…
<a href="http://kuina.tes.so/6saiconf_3/img9.png">http://kuina.tes.so/6saiconf_3/img9.png</a>
これです！！</p>

<p>くいなちゃん: 一番下のやつ</p>

<p>くいなちゃん: 参考までに、正しいフィボナッチ数列の式を一番上に掲げておきました。</p>

<p>くいなちゃん: なんと、√とか使わない式で、フィボナッチ数列を再現したのです…！</p>

<p>くいなちゃん: はい、分数です</p>

<p>くいなちゃん: そこにある式全部で、一つの式です。
つまり、6次式ですね！</p>

<p>くいなちゃん: 6次式より、高次だった</p>

<p>くいなちゃん: はい、まとめですん☆　遺伝的プログラムを用いると、こんな感じで、近いアルゴリズムを 自動で発見させることができます。
今回は、簡単な計算式のみを遺伝させましたが、for文や if文なども含めて遺伝させると、ちょー複雑なプログラムも 自動で誕生させることができます。　試してみてください☆</p>
]]></content>
  </entry>
  
</feed>
