<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: postgresql | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/postgresql/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-08-25T07:20:49+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Re: PostgreSQLで排他制約がめっちゃ便利！！]]></title>
    <link href="https://shogo82148.github.io/blog/2017/04/22/postgresql-exclusion-constraint/"/>
    <updated>2017-04-22T19:10:21+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/04/22/postgresql-exclusion-constraint</id>
    <content type="html"><![CDATA[<p><a href="http://soudai.hatenablog.com/entry/2017/04/16/152905">PostgreSQLで排他制約がめっちゃ便利！！</a>を拝見したのですが、
とても些細なミスがあるのに気がついてしまいました。
本題とは関係ない重箱の隅をつつくような話なので、わざわざコメントするほどのことでもないかと考えていたのですが、
どうしても試してみたいクエリを思いつき、
偶然にも<a href="http://shogo82148.github.io/blog/2017/03/28/database-gis/">Redis、PostgreSQL、MySQLで近傍検索</a>したときに
セットアップしたPostgreSQL環境が残っていたのでやってみました。</p>

<!-- More -->


<h2>試したかったこと</h2>

<p>そーだいさんの記事からSQLの実行結果を一部引用します。</p>

<pre><code class="plain">demo=# SELECT * FROM schedule;

 schedule_id |  room_name  |               reservation_time
-------------+-------------+-----------------------------------------------
           1 | soudai_room | ["2017-04-16 11:30:00","2017-04-16 12:00:00")
           4 | soudai_room | ["2017-04-16 12:00:00","2017-04-16 12:30:00")
           5 | soudai_room | ("2017-04-16 12:30:00","2017-04-16 12:40:00")
           8 | soudai_room | ["2017-04-16 14:30:00","2017-04-16 16:00:00")
(4 行)
</code></pre>

<p><code>schedule_id</code>の<strong>5</strong>をよく見て下さい。
他のスケジュールは<strong>半開区間</strong><code>[)</code>(開始時刻は期間に<strong>含む</strong>が、終了時刻は期間に<strong>含まない</strong>)になっているのですが、
<code>schedule_id</code>の5だけ<strong>開区間</strong><code>()</code>(開始時刻も終了時刻も期間に<strong>含まない</strong>)になっています。
つまり 2017-04-16 12:30:00 ジャストに空き時間があるのです。</p>

<p><strong>ここに予約を入れてみたい！！！</strong></p>

<h2>試してみた</h2>

<h3>環境再現</h3>

<p>以下のSQLを実行して、そーだいさんの記事と同じ内容を含んだテーブルを作成します。</p>

<pre><code class="sql">CREATE TABLE schedule
(
    schedule_id SERIAL PRIMARY KEY NOT NULL,
    room_name TEXT NOT NULL,
    reservation_time tsrange NOT NULL
);

INSERT INTO schedule (schedule_id, room_name, reservation_time) VALUES
    (1, 'soudai_room', '["2017-04-16 11:30:00","2017-04-16 12:00:00")'),
    (4, 'soudai_room', '["2017-04-16 12:00:00","2017-04-16 12:30:00")'),
    (5, 'soudai_room', '("2017-04-16 12:30:00","2017-04-16 12:40:00")'),
    (8, 'soudai_room', '["2017-04-16 14:30:00","2017-04-16 16:00:00")');

-- schedule_idが1から始まってしまい、INSERTした内容と重複してしまうので調整
SELECT setval ('schedule_schedule_id_seq', 8);
</code></pre>

<p>SELECTを実行すると同じ内容になっていることを確認できます。</p>

<pre><code class="plain">demo=# SELECT * FROM schedule;
 schedule_id |  room_name  |               reservation_time
-------------+-------------+-----------------------------------------------
           1 | soudai_room | ["2017-04-16 11:30:00","2017-04-16 12:00:00")
           4 | soudai_room | ["2017-04-16 12:00:00","2017-04-16 12:30:00")
           5 | soudai_room | ("2017-04-16 12:30:00","2017-04-16 12:40:00")
           8 | soudai_room | ["2017-04-16 14:30:00","2017-04-16 16:00:00")
(4 rows)
</code></pre>

<p>さて、ちょうど 2017-04-16 12:30:00 は空き時間になっているので、
以下のクエリは0件になるはずです。</p>

<pre><code class="sql">SELECT * FROM schedule 
          WHERE reservation_time @&gt; '2017-04-16 12:30:00'::timestamp;
</code></pre>

<pre><code class="plain"> schedule_id | room_name | reservation_time
-------------+-----------+------------------
(0 rows)
</code></pre>

<p>予想通り検索結果は0件になりましたね。</p>

<p>そして、2017-04-16 12:30:00の直前と直後はスケジュールが埋まっています。</p>

<pre><code class="plain">demo=# SELECT * FROM schedule
          WHERE reservation_time @&gt; '2017-04-16 12:29:59.999999'::timestamp;
 schedule_id |  room_name  |               reservation_time
-------------+-------------+-----------------------------------------------
           4 | soudai_room | ["2017-04-16 12:00:00","2017-04-16 12:30:00")
(1 row)

demo=# SELECT * FROM schedule
          WHERE reservation_time @&gt; '2017-04-16 12:30:00.000001'::timestamp;
 schedule_id |  room_name  |               reservation_time
-------------+-------------+-----------------------------------------------
           5 | soudai_room | ("2017-04-16 12:30:00","2017-04-16 12:40:00")
(1 row)
</code></pre>

<h3>排他制約を有効にする</h3>

<p>予約を入れるまえに排他制約を有効にしておきましょう。
すでにテーブルを作成しているので、<code>ALTER TABLE</code>文でテーブルの定義を変更します。</p>

<pre><code class="sql">ALTER TABLE schedule ADD EXCLUDE USING GIST (reservation_time WITH &amp;&amp;);
</code></pre>

<p>排他制約が有効になっているか、そーだいさんの記事と同じクエリを実行してみましょう。</p>

<pre><code class="sql">INSERT INTO schedule
  (room_name, reservation_time)
     VALUES
  ('soudai_room', '[2017-04-16 15:30, 2017-04-16 17:00)');
</code></pre>

<pre><code class="plain">demo=# INSERT INTO schedule
demo-#   (room_name, reservation_time)
demo-#      VALUES
demo-#   ('soudai_room', '[2017-04-16 15:30, 2017-04-16 17:00)');
ERROR:  conflicting key value violates exclusion constraint "schedule_reservation_time_excl"
DETAIL:  Key (reservation_time)=(["2017-04-16 15:30:00","2017-04-16 17:00:00")) conflicts with existing key (reservation_time)=(["2017-04-16 14:30:00","2017-04-16 16:00:00")).
</code></pre>

<p>期待通り排他制約により実行に失敗してくれました。</p>

<h3>予約を入れてみる</h3>

<p>さあ、ここからが本題です。
ちょうど 2017-04-16 12:30:00 の時間に予約を入れてみましょう。</p>

<pre><code class="sql">INSERT INTO schedule
  (room_name, reservation_time)
     VALUES
  ('soudai_room', '[2017-04-16 12:30:00, 2017-04-16 12:30:00]');
</code></pre>

<pre><code class="plain">demo=# INSERT INTO schedule
demo-#   (room_name, reservation_time)
demo-#      VALUES
demo-#   ('soudai_room', '[2017-04-16 12:30:00, 2017-04-16 12:30:00]');
INSERT 0 1
</code></pre>

<pre><code class="plain">demo=# SELECT * FROM schedule;
 schedule_id |  room_name  |               reservation_time
-------------+-------------+-----------------------------------------------
           1 | soudai_room | ["2017-04-16 11:30:00","2017-04-16 12:00:00")
           4 | soudai_room | ["2017-04-16 12:00:00","2017-04-16 12:30:00")
           5 | soudai_room | ("2017-04-16 12:30:00","2017-04-16 12:40:00")
           8 | soudai_room | ["2017-04-16 14:30:00","2017-04-16 16:00:00")
          10 | soudai_room | ["2017-04-16 12:30:00","2017-04-16 12:30:00"]
(5 rows)
</code></pre>

<p><strong>やった予約成功！</strong></p>

<p>PostreSQLのドキュメントによるとtimestamp型の精度は1マイクロ秒らしいので、
部屋を利用できるのは1マイクロ秒だけですが・・・。</p>

<h2>インデックスの使われ方について</h2>

<p>インデックスの使われ方について気になったので、少し検証を続行してみます。
僕自身はMySQLを扱う事が多いのですが、MySQLではユニーク制約を設定すると、設定したカラムに自動的にインデックスが張られて、
それが検索時にも使用されます。
PostreSQLの排他制約でもそうなのかな？と疑問に思ったので、実行計画を確認してみました。</p>

<p>今回用意したテーブルだと行数が少なすぎて、
インデックスが利用可能な場合でもフルスキャンが選択されてしまいます。
データを大量に用意するのも面倒ですし、どうやらフルスキャンを無効化するオプション(厳密には、フルスキャン以外に選択肢がない場合があるので、なるべく使わない)があるらしいので、
その状態で実行計画を確認してみましょう。</p>

<pre><code class="plain">demo=# SET enable_seqscan = OFF;
SET
demo=# EXPLAIN SELECT * FROM schedule
          WHERE reservation_time @&gt; '2017-04-16 12:30:00'::timestamp;
                                           QUERY PLAN
------------------------------------------------------------------------------------------------
 Index Scan using schedule_reservation_time_excl on schedule  (cost=0.13..8.15 rows=1 width=68)
   Index Cond: (reservation_time @&gt; '2017-04-16 12:30:00'::timestamp without time zone)
(2 rows)
</code></pre>

<p>(読み方よくわかってないけど)Index Scanとあるので、きっとインデックスを使ってくれているのでしょう。</p>

<p>排他制約に<code>room_name</code>を入れた場合も試してみました。</p>

<pre><code class="sql">CREATE EXTENSION btree_gist;
ALTER TABLE schedule ADD EXCLUDE USING GIST (room_name WITH =, reservation_time WITH &amp;&amp;);
</code></pre>

<pre><code class="plain">demo=# SET enable_seqscan = OFF;
SET
demo=# EXPLAIN SELECT * FROM schedule
          WHERE room_name = 'soudai_room' AND reservation_time @&gt; '2017-04-16 12:30:00'::timestamp;
                                                           QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------
 Index Scan using schedule_room_name_reservation_time_excl on schedule  (cost=0.14..8.16 rows=1 width=68)
   Index Cond: ((room_name = 'soudai_room'::text) AND (reservation_time @&gt; '2017-04-16 12:30:00'::timestamp without time zone))
(2 rows)
</code></pre>

<p>(やっぱり読み方よくわかってないけど)Index Scanとあるので、きっとインデックスを使ってくれているのでしょう。</p>

<p>今回はフルスキャンを手動で無効化しましたが、大量にデータがあれば自動的にインデックスを使ってくれそうです。</p>

<h2>再発防止策を考えてみる</h2>

<p>試したいことを試せたのでここで終わりでもいいんですが、
エンジニアとしてはやはり再発防止策を入れておきたいところです。
色々な範囲関数があるので、それを使えばCHECK制約をかけられるのでは、と書いてみたのがこちら。</p>

<pre><code class="sql">CREATE EXTENSION btree_gist;
CREATE TABLE schedule
(
    schedule_id SERIAL PRIMARY KEY NOT NULL,
    room_name TEXT NOT NULL,
    reservation_time tsrange NOT NULL,
    CHECK (    lower_inc(reservation_time)),
    CHECK (NOT upper_inc(reservation_time)),
    EXCLUDE USING GIST (room_name WITH =, reservation_time WITH &amp;&amp;)
);
</code></pre>

<p>さあ、データを投入してみましょう。</p>

<pre><code class="sql">INSERT INTO schedule (room_name, reservation_time) VALUES
    ('soudai_room', '["2017-04-16 11:30:00","2017-04-16 12:00:00")');
INSERT INTO schedule (room_name, reservation_time) VALUES
    ('soudai_room', '("2017-04-16 12:30:00","2017-04-16 12:40:00")');
</code></pre>

<p>期間が半区間<code>[)</code>になっている最初のクエリは成功しますが、
開区間<code>()</code>になっている二番目のクエリは以下のようなエラーを吐いて挿入に失敗します。</p>

<pre><code class="plain">demo=# INSERT INTO schedule (room_name, reservation_time) VALUES
demo-#     ('soudai_room', '("2017-04-16 12:30:00","2017-04-16 12:40:00")');
ERROR:  new row for relation "schedule" violates check constraint "schedule_reservation_time_check"
DETAIL:  Failing row contains (2, soudai_room, ("2017-04-16 12:30:00","2017-04-16 12:40:00")).
</code></pre>

<h2>まとめ</h2>

<p>制約はユニーク制約くらいしか使ったことがないのですが、いろんな制約があって便利ですね。
(と書いたところで外部キー制約を使った経験を思い出したけど、<a href="http://songmu.github.io/slides/fk-night/#0">MySQLユーザにはいろいろ事情があってね・・・</a>)</p>

<p>特に、時間指定が半区間<code>[)</code>か閉区間<code>[]</code>かで苦しめられた身からすると、これを制約に入れられるのは非常に魅力的です(ちなみに僕は半区間<code>[)</code>推進派です)。
PostgreSQLを利用することがあれば使っていきたい機能ですね(使う機会あるかな・・・)。</p>

<h2>参考文献</h2>

<ul>
<li><a href="http://soudai.hatenablog.com/entry/2017/04/16/152905">PostgreSQLで排他制約がめっちゃ便利！！</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/datatype-datetime.html">8.5. 日付/時刻データ型  - PostgreSQL 9.6.2文書</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/rangetypes.html">8.17. 範囲型 - PostgreSQL 9.6.2文書</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/sql-altertable.html">ALTER TABLE - PostgreSQL 9.6.2文書</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/functions-range.html">9.19. 範囲関数と演算子 - PostgreSQL 9.6.2文書</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/using-explain.html">14.1. EXPLAINの利用 - PostgreSQL 9.6.2文書</a></li>
<li><a href="https://www.postgresql.jp/document/9.6/html/runtime-config-query.html#runtime-config-query-enable">19.7. 問い合わせ計画 - PostgreSQL 9.6.2文書</a></li>
<li><a href="http://songmu.github.io/slides/fk-night/#0">我々(主語が大きい)は何故MySQLで外部キーを使わないのか</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis、PostgreSQL、MySQLで近傍検索]]></title>
    <link href="https://shogo82148.github.io/blog/2017/03/28/database-gis/"/>
    <updated>2017-03-28T19:59:49+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/03/28/database-gis</id>
    <content type="html"><![CDATA[<p>「<a href="http://techblog.kayac.com/serverside-geohash">サーバーで付近の情報を通知するサービスのつくり方</a>」
という、Geohashを使って近傍検索を実現する記事をみつけました。
最近<a href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/">Redisに関する記事</a>を書いた関係で、
この記事をみて「GeohashはRedisと一緒に使うともっと便利だよ！」と思わず宣伝したくなったのですが、
MySQL5.7でInnoDBに空間インデックス(Spatial Index)のサポートが入ったので
「MySQLでももっと簡単にできるのでは？」と思い、
RedisやMySQLを含めたいろんなDBで近傍検索を実現する方法を調べてみました。</p>

<p>以前、<a href="https://shogo82148.github.io/blog/2012/08/02/fireworks/">スマートフォンのセンサを活用して花火の打ち上げ場所を推定するアプリ</a>を作った関係で、
地球上での距離計算の実装も気になったので、それについても調査してみました。</p>

<!-- More -->


<h2>関連知識</h2>

<h3>GeoHash</h3>

<p><a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%82%AA%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5">Geohash（ジオハッシュ）</a>
は緯度・経度を短い文字列に変換する方法です。
距離が近い2地点のGeohashは似たような文字列になるという特徴があります(一部例外あり)。
この特徴を利用すると、文字列検索だけで近傍検索が実現できます。</p>

<h3>地球上の二点間の距離</h3>

<p>地球は完全な球体ではなく、回転楕円体であることが知られています。
地球の形がわからないと緯度・経度などを決められないので、
<a href="https://ja.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E6%A5%95%E5%86%86%E4%BD%93">地球楕円体</a>が定義されています。
近似方法によっていくつか種類があるのですが、GPSなどで使われているWGS84がよく使われているようです。</p>

<p>国土地理院が提供している<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/main.html">測量計算サイト</a>では
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/bl2stf.html">距離と方位角の計算</a>を使って緯度・経度から距離を計算できます。
回転楕円体上の距離の厳密解は求められない(要出典)ので、
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/algorithm/bl2st/bl2st.htm">数値計算</a>によって求めることになります。
計算式を見て分かる通り非常に複雑なので、なんらかの近似をしている実装がほとんどです。</p>

<h2>各種DBでの実現方法</h2>

<h3>Redis</h3>

<p>Redisでは3.2から<a href="https://redis.io/commands#geo">GEO</a>関連の機能をサポートしています。
ソート済みセットにGeohashを組み合わせて実現しています。</p>

<p>簡単に試してみました。データは以下の記事から拝借したものを使用します。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/ilo/20090212/1234448136">MySQLで指定した緯度経度から半径nメートル内検索っぽいのを実現するSQL</a></li>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<p><a href="https://redis.io/commands/geoadd"><code>GEOADD</code></a>でデータ挿入です。
ちなみにデータを削除する<code>GEODEL</code>は用意されていないとのこと。
中身はソート済みセットなので、<a href="https://redis.io/commands/zrem">ZREM</a>でいいんですね。</p>

<pre><code class="plain">$ cat command.txt
GEOADD geotable 139.777254 35.713768 上野駅         139.774029 35.711846 西郷隆盛像
GEOADD geotable 139.774744 35.712737 上野の森美術館 139.770872 35.712351 不忍池弁財天
GEOADD geotable 139.775696 35.716293 野口英世博士像 139.775803 35.715420 国立西洋美術館
GEOADD geotable 139.776544 35.716319 国立科学博物館 139.772776 35.717186 東京都美術館
GEOADD geotable 139.776462 35.718883 東京国立博物館 139.794547 35.715280 花やしき
GEOADD geotable 139.792692 35.710635 雷門
$ redis-cli &lt; command.txt
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 1
</code></pre>

<p><code>GEOHASH</code>で各地点のGeohashを取得できます。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEOHASH geotable 上野駅 西郷隆盛像 上野の森美術館
1) "xn77htqxy10"
2) "xn77hthkdf0"
3) "xn77htkcg80"
</code></pre>

<p><code>GEORADIUS</code>で近傍検索ができます。
上野駅から半径300m以内の地点を求める例です。
データに日本語を使ったので非常にわかりにくいですが、
上野駅から近い順に「上野駅」「国立西洋美術館」「上野の森美術館」「国立科学博物館」の距離と座標を返してくれました。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEORADIUS geotable 139.777254 35.713768 300 m WITHCOORD WITHDIST ASC
1) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe9\xa7\x85"
   2) "0.1203"
   3) 1) "139.77725297212600708"
      2) "35.71376868735887911"
2) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe8\xa5\xbf\xe6\xb4\x8b\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "225.4920"
   3) 1) "139.77580457925796509"
      2) "35.71541879083360271"
3) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe3\x81\xae\xe6\xa3\xae\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "254.1580"
   3) 1) "139.77474242448806763"
      2) "35.71273705584702896"
4) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe7\xa7\x91\xe5\xad\xa6\xe5\x8d\x9a\xe7\x89\xa9\xe9\xa4\xa8"
   2) "290.8339"
   3) 1) "139.77654486894607544"
      2) "35.71631861684517872"
</code></pre>

<p>上野駅と上野駅の距離は当然0mなはずですが、ちょっとだけズレてます。
これはソート済みセットの制約で緯度・経度それぞれ53bitを26bitにまるめているからです(たぶん)。
距離の計算は<a href="https://github.com/antirez/redis/blob/4.0/src/geohash_helper.c#L52">半径6372797.560856mの完全な球体</a>で近似し、
<a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>というのを使っています。</p>

<p>ちなみに扱える緯度・経度には以下の制限があり、極付近の座標は扱えません。</p>

<ul>
<li>経度 -180度から180度</li>
<li>緯度 -85.05112878度から85.05112878度</li>
</ul>


<p>これは Spherical Mercator(球面メルカトル図法) の制限らしいです。
Google Maps, OpenStreetMap, Bing 等でよく見る地図は平面ですが、本来の地球は丸いので、うまく平面にマッピングする必要があります。
このときにどうしても本来の地形から歪んでしまうわけですが、
極付近では歪みが無限大になってしまいうまく平面の地図にできないのです。</p>

<p>ただ、Redis自体は平面へのマッピングをしないので、別にこの制限要らな気もします。
まあ、コーナーケースなので他にも問題がありそうですし、
そもそも北極・南極向けにサービス作らないので気にしないでおきましょう。</p>

<h3>PostgreSQL</h3>

<p>日本語で書かれた先行事例を見つけたので、PostgreSQLの紹介から。
以下の記事にあるように、PostGISというオプション機能をインストールすると簡単に実現できます。</p>

<ul>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<pre><code class="sql">-- PostGISを有効化
CREATE EXTENSION postgis;

-- テーブルの作成
CREATE TABLE geotable (
    id   SERIAL NOT NULL PRIMARY KEY,
    name varchar (255) NOT NULL,
    geom geography(POINT, 4326) NOT NULL
);

-- データの挿入
INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeographyFromText('SRID=4326;POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeographyFromText('SRID=4326;POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeographyFromText('SRID=4326;POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeographyFromText('SRID=4326;POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeographyFromText('SRID=4326;POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeographyFromText('SRID=4326;POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeographyFromText('SRID=4326;POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeographyFromText('SRID=4326;POINT(139.776462 35.718883)')),
('花やしき', ST_GeographyFromText('SRID=4326;POINT(139.794547 35.71528)')),
('雷門', ST_GeographyFromText('SRID=4326;POINT(139.792692 35.710635)'));

-- 空間インデックスの作成
CREATE INDEX gist_geotable on geotable USING GIST (geom);
</code></pre>

<p><code>ST_GeoHash</code>でGeohashを求めることができます。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom) FROM geotable;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |      st_geohash
-----------------------+-----------------------------+----------------------
 上野駅             | POINT(139.777254 35.713768) | xn77htqxy0fu2t0y69sv
 西郷隆盛像       | POINT(139.774029 35.711846) | xn77hthkdfw51p8cmr68
 上野の森美術館 | POINT(139.774744 35.712737) | xn77htkcg8enm86bp3j7
 不忍池弁財天    | POINT(139.770872 35.712351) | xn77ht4p92sp8jdqkjzf
 野口英世博士像 | POINT(139.775696 35.716293) | xn77htvw3z9495yr4dxd
 国立西洋美術館 | POINT(139.775803 35.71542)  | xn77htv9kkbffr4ptjcy
 国立科学博物館 | POINT(139.776544 35.716319) | xn77htynts3mer092t8v
 東京都美術館    | POINT(139.772776 35.717186) | xn77hw57twp9x63n6vus
 東京国立博物館 | POINT(139.776462 35.718883) | xn77hwqjedkhwdmmwp0n
 花やしき          | POINT(139.794547 35.71528)  | xn77jjg2949rgdfxbrjp
 雷門                | POINT(139.792692 35.710635) | xn77jhcvtbf5mdcexf85
(11 rows)
</code></pre>

<p>近傍検索には<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_DWithin.html"><code>ST_DWithin</code></a>を使います。
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance.html"><code>ST_Distance</code></a>や
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Sphere.html"><code>ST_Distance_Sphere</code></a>、
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Spheroid.html"><code>ST_Distance_Spheroid</code></a>等
を使って距離を計算して絞り込むことも出来ますが、これらの関数はインデックスを使ってくれません。
<code>ST_DWithin</code>は
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/using_postgis_dbmanagement.html#id286995989">GiSTインデックス</a>
を利用してくれるので高速に処理してくれます。</p>

<pre><code class="sql">SELECT
    name,
    ST_AsText(geom),
    ST_Distance('SRID=4326;POINT(139.777254 35.713768)', geom) as dist
FROM geotable
WHERE ST_DWithin(geom, ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)'), 300.0)
ORDER BY dist;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |     dist
-----------------------+-----------------------------+---------------
 上野駅             | POINT(139.777254 35.713768) |             0
 国立西洋美術館 | POINT(139.775803 35.71542)  | 225.468916585
 上野の森美術館 | POINT(139.774744 35.712737) | 254.308127877
 国立科学博物館 | POINT(139.776544 35.716319) | 290.242707221
</code></pre>

<p><code>ST_</code>で始まる関数は<a href="http://www.opengeospatial.org/standards/sfs">OpenGIS</a>やSQL/MMで標準化されているものらしいです。</p>

<h3>MySQL</h3>

<p>MySQLに関しては以下の記事を見つけました。
この記事が書かれた頃はMyISAMでしか空間インデックスをサポートしていませんでしたが、
5.7からInnoDBでもサポートされるようになったので、
InnoDBでも同様のことができるはずです。</p>

<ul>
<li><a href="http://qiita.com/kochizufan/items/a68b30ba74849483f75c">mysql空間テーブルの作り方</a></li>
</ul>


<p>MySQL5.7で入った機能についてはこちらを参照。
空間インデックス以外にも大量に変更があるので、アップグレードする人は確認をおすすめします。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B01LCJRCYE&linkId=ac9d8d9e348bd97dc858337c94e82696"></iframe>


<p>MySQLもPostgreSQLもOpenGISに準拠する方針みたいなので、
PostgreSQLと同じ感じでSQLが書けると信じたいところですが、
当然ながらそうは行きません。</p>

<p>一番大きな違いは<code>geography</code>型には対応しておらず<code>geometry</code>型しか使えないということです。
<code>geography</code>型は測地系の情報を持っている(つまり地球が回転楕円体だということを知っている)のですが、
<code>geometry</code>型は測地系の情報が無いため、平面しか扱えません。</p>

<pre><code class="sql">CREATE DATABASE test; -- 5.6以前は勝手に作ってくれたけど、5.7からは無いらしい
USE test;
CREATE TABLE IF NOT EXISTS `geotable` (
  `id`   int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR (255) NOT NULL,
  `geom` geometry NOT NULL,
  PRIMARY KEY (`id`),
  SPATIAL KEY `geom` (`geom`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
</code></pre>

<p>座標の指定も<code>ST_GeographyFromText</code>ではなく<code>ST_GeomFromText</code>を使います。</p>

<pre><code class="sql">INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeomFromText('POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeomFromText('POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeomFromText('POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeomFromText('POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeomFromText('POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeomFromText('POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeomFromText('POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeomFromText('POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeomFromText('POINT(139.776462 35.718883)')),
('花やしき', ST_GeomFromText('POINT(139.794547 35.71528)')),
('雷門', ST_GeomFromText('POINT(139.792692 35.710635)'));
</code></pre>

<p>PostgreSQLと同様にGeohashを求める<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-geohash-functions.html"><code>ST_GeoHash</code>があります</a>が、
桁数を指定する必要があるという違いがあります。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom, 11) FROM geotable;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+----------------------+
| name                  | ST_AsText(geom)             | ST_GeoHash(geom, 11) |
+-----------------------+-----------------------------+----------------------+
| 上野駅                | POINT(139.777254 35.713768) | xn77htqxy0f          |
| 西郷隆盛像            | POINT(139.774029 35.711846) | xn77hthkdfw          |
| 上野の森美術館        | POINT(139.774744 35.712737) | xn77htkcg8e          |
| 不忍池弁財天          | POINT(139.770872 35.712351) | xn77ht4p92s          |
| 野口英世博士像        | POINT(139.775696 35.716293) | xn77htvw3z9          |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | xn77htv9kkb          |
| 国立科学博物館        | POINT(139.776544 35.716319) | xn77htynts3          |
| 東京都美術館          | POINT(139.772776 35.717186) | xn77hw57twp          |
| 東京国立博物館        | POINT(139.776462 35.718883) | xn77hwqjedk          |
| 花やしき              | POINT(139.794547 35.71528)  | xn77jjg2949          |
| 雷門                  | POINT(139.792692 35.710635) | xn77jhcvtbf          |
+-----------------------+-----------------------------+----------------------+
11 rows in set (0.00 sec)
</code></pre>

<p>MySQLにも距離を求める<code>ST_Distance</code>はあるのですが、これは平面専用です。
地球上での距離を求めるには<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-convenience-functions.html"><code>ST_Distance_Sphere</code>を使います</a>。
MySQL5.7から追加された関数で、これを使うと半径6370986mの球体で近似したときの距離を計算できます。</p>

<p>そして残念なことにPostgreSQLにはあった<code>ST_DWithin</code>はMySQLにはありません。
<code>ST_Distance_Sphere</code>を使えばクエリは書けるのですが、インデックスを使ってくれないので非効率です。
そのため、矩形の範囲指定で大雑把に絞り込んだあとで<code>ST_Distance_Sphere</code>を使って詳細に絞り込むことになります。</p>

<pre><code class="sql">SET @ueno = ST_GeomFromText('POINT(139.777254 35.713768)');
SELECT
    name,
    ST_AsText(geom),
    ST_Distance_Sphere(@ueno, geom) AS dist
FROM geotable
WHERE ST_Distance_Sphere(@ueno, geom) &lt;= 300
AND ST_Within(geom, ST_Buffer(@ueno, DEGREES(300/(6370986*COS(RADIANS(ST_Y(@ueno))))), ST_Buffer_Strategy('point_square')))
ORDER BY dist;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+--------------------+
| name                  | ST_AsText(geom)             | dist               |
+-----------------------+-----------------------------+--------------------+
| 上野駅                | POINT(139.777254 35.713768) |                  0 |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | 225.62014319497658 |
| 上野の森美術館        | POINT(139.774744 35.712737) | 253.96163316266237 |
| 国立科学博物館        | POINT(139.776544 35.716319) | 290.81011310408957 |
+-----------------------+-----------------------------+--------------------+
4 rows in set (0.00 sec)
</code></pre>

<p>緯度によって経度1度あたりの長さが違うので、矩形選択の範囲に補正を入れてあります。
本当は緯度の補正は無くても良いはずですが、広めならいいだろ！ってことで雑に書いています。
本番で使いたい人は補正＆バリデーション頑張ってください(特に極の辺りで大変なことになるので)。</p>

<h3>その他DB</h3>

<p>力尽きたので簡単に。</p>

<p>SQLiteは<a href="https://www.gaia-gis.it/fossil/libspatialite/index">SpatiaLite</a>という拡張モジュールで空間データを扱えるようです。</p>

<p>全文検索エンジンの<a href="http://groonga.org/ja/">Groonga</a>も近傍検索に対応していて、
距離の計算方法は以下の3つから選べるようです。
(<a href="http://groonga.org/ja/docs/reference/functions/geo_distance.html"><code>geo_distance</code></a>)</p>

<ul>
<li><code>rectangle</code>: 方形近似して距離を計算</li>
<li><code>sphere</code>: <a href="https://github.com/groonga/groonga/blob/v7.0.0/lib/grn_geo.h#L42">半径6357303m</a>の完全な球体と仮定して計算</li>
<li><code>ellipsoid</code>: WGS84地球楕円体を<a href="http://yamadarake.jp/trdi/report000001.html">ヒュベニの距離計算式</a>で近似</li>
</ul>


<p>ヒュベニの距離計算式というのが出てきましたが、<code>ellipsoid</code>で使っているのは簡易版で、
<a href="http://www.amano-tec.com/apps/paceruler.html">本来のヒュベニの距離計算式</a>は非常に複雑で難しい・・・。</p>

<h2>まとめ</h2>

<p>Redis、PostgreSQL、MySQLで近傍検索をやってみました。</p>

<ul>
<li>Redisは近傍検索だけならお手軽</li>
<li>PostgreSQL+PostGISは今回触った中では最強。地理データを真面目に扱うならいいかも</li>
<li>MySQLは5.6以前よりは扱いやすくなったものの、空間インデックスを効果的に使うには一工夫必要</li>
</ul>


<p>PostgreSQL+PostGISと比べると、どうしてもMySQL5.7は見劣りしますね。
しかし、検索をSQLで書けるという利点は大きいので、利用を検討する価値はあると思います。</p>

<p>ところで、大体のDBで地球を完全な球で近似する実装が入ってるんですが、
半径が微妙に違うんですよね。</p>

<ul>
<li>Redis: 6 372 797.560 856m</li>
<li>PostgreSQL: 6 370 986m</li>
<li>MySQL: 6 370 986m</li>
<li>Groonga: 6 357 303m</li>
<li>赤道半径: 6 378 137m</li>
<li>極半径: 6 356 752.314 245m</li>
</ul>


<p>0.24%しか違わないので、実用上は全く問題ないんですが、
出典がよくわからないし気になります。</p>
]]></content>
  </entry>
  
</feed>
