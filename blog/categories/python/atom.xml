<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2018-01-02T15:03:45+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MeCabをAWS Lambdaで動かす(2017年版)]]></title>
    <link href="https://shogo82148.github.io/blog/2017/12/06/mecab-in-lambda/"/>
    <updated>2017-12-06T05:39:57+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/12/06/mecab-in-lambda</id>
    <content type="html"><![CDATA[<p><a href="http://www.yasuhisay.info/entry/saba_disambiguator">AWS Lambda上で鯖(Mackerel)の曖昧性問題を機械学習で解決しよう</a>の記事の中で、
Lambda上でMeCabを動かすことについて以下のように触れられています。</p>

<blockquote><p>日本語を扱う自然言語処理ではMeCabを扱うことが多いですが、Lambda上でMeCabを動かすのは一手間必要なようです。</p></blockquote>

<p>確かにLambda上でMeCabを動かすのは一手間必要です。
しかし、参照している記事は少し古くて、今はもう少し手軽にできるようになっています。</p>

<p>ブコメでも言及しましたが、改めて記事として残しておこうと思います。</p>

<!-- More -->


<h2>ビルド方法(2017年版)</h2>

<p>結論から言うと <a href="https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/#comment-2550852533">Norio Kimura さんのコメント</a> 通りにビルドするのが、2017年12月現在一番楽な方法です。
(お返事すっかり忘れていてスイマセン・・・情報提供ありがとうございます)</p>

<blockquote><p>調べてみると、AWS Lambda では環境変数 LD_LIBRARY_PATH が既に設定されていて /var/task/lib を含んでいました。元記事で ./configure &ndash;prefix=$PROJECT_HOME/local ではなく ./configure &ndash;prefix=$PROJECT_HOME とすればライブラリとの動的リンクは何もしなくても実現できます。さらにコードが展開されるディレクトリ /var/task を固定値だと決め打ちして PROJECT_HOME を /var/task にして開発すれば MeCab に渡すパラメーターの設定（-d, -r）も不要になります。undocumented な仕様に２つも依存していて気持ち悪いですが、MeCab を呼ぶ側のコードを Lambda 用に変更する必要がなくなります。</p></blockquote>

<p>コメント中の元記事というのは、こちらの記事のことです。</p>

<ul>
<li><a href="https://dev.classmethod.jp/cloud/aws-lambda-with-mecab/">AWS Lambda で MeCab を動かす</a></li>
</ul>


<pre><code class="bash install.sh">export PROJECT_HOME=/var/task # LAMBDA_TASK_ROOT

# 1. プロジェクト用にディレクトリを作成
mkdir -p "$PROJECT_HOME"

# 2. MeCabのダウンロードとインストール
# googlecodeサービス終了に伴い、ダウンロードURLが元記事と変わっていることに注意
cd "$HOME"
curl -fsSL "https://drive.google.com/uc?export=download&amp;id=0B4y35FiV1wh7cENtOXlicTFaRUE" -o mecab.tar.gz
cd mecab-0.996
./configure --prefix="$PROJECT_HOME" --enable-utf8-only # ※ここでのprefix指定がポイント
make &amp;&amp; make install

# 3. 辞書のダウンロードとインストール
cd "$HOME"
curl -fsSL "https://drive.google.com/uc?export=download&amp;id=0B4y35FiV1wh7MWVlSDBCSXZMTXM" -o mecab-ipadic.tar.gz
tar zvxf mecab-ipadic.tar.gz
cd mecab-ipadic-2.7.0-20070801
export PATH=$PROJECT_HOME/bin:$PATH
./configure --prefix="$PROJECT_HOME" --enable-utf8-only # ※ここでのprefix指定がポイント
make &amp;&amp; make install

# 4. Python用MeCab-bindingをインストール
pip install -t "$PROJECT_HOME" -r mecab-python
</code></pre>

<h2>Lambda関数を書いてみる</h2>

<p>上記方法でMeCabをインストールすると<a href="https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/">AWS Lambda で MeCab を動かす(改)</a>で紹介したコードは以下のように簡略化できます。</p>

<pre><code class="python lambda_function.py"># coding=utf-8
import os
import settings

import logging
logger = logging.getLogger(__name__)
logger.setLevel(settings.LOG_LEVEL)

"""
# https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/ にあったpreload処理は不要になります。
# preload libmecab
import ctypes
libdir = os.path.join(os.getcwd(), 'local', 'lib')
libmecab = ctypes.cdll.LoadLibrary(os.path.join(libdir, 'libmecab.so'))
"""

import MeCab

# prepare Tagger
"""
# 辞書のパスの明示的な指定が不要になります。
dicdir = os.path.join(os.getcwd(), 'local', 'lib', 'mecab', 'dic', 'ipadic')
rcfile = os.path.join(os.getcwd(), 'local', 'etc', 'mecabrc')
default_tagger = MeCab.Tagger("-d{} -r{}".format(dicdir, rcfile))
unk_tagger = MeCab.Tagger("-d{} -r{} --unk-feature 未知語,*,*,*,*,*,*,*,*".format(dicdir, rcfile))
"""
default_tagger = MeCab.Tagger("")
unk_tagger = MeCab.Tagger("--unk-feature 未知語,*,*,*,*,*,*,*,*")

DEFAULT_STOPTAGS = ['BOS/EOS']

def lambda_handler(event, context):
    sentence = event.get('sentence', '').encode('utf-8')
    stoptags = event.get('stoptags', '').encode('utf-8').split(',') + DEFAULT_STOPTAGS
    unk_feature = event.get('unk_feature', False)

    tokens = []
    tagger = unk_tagger if unk_feature else default_tagger
    node = tagger.parseToNode(sentence)
    while node:
        feature = node.feature + ',*,*'
        part_of_speech = get_part_of_speech(feature)
        reading = get_reading(feature)
        base_form = get_base_form(feature)
        token = {
            "surface": node.surface.decode('utf-8'),
            "feature": node.feature.decode('utf-8'),
            "pos": part_of_speech.decode('utf-8'),
            "reading": reading.decode('utf-8'),
            "baseform": base_form.decode('utf-8'),
            "stat": node.stat,
        }

        if part_of_speech not in stoptags:
            tokens.append(token)
        node = node.next
    return {"tokens": tokens}

def get_part_of_speech(feature):
    return '-'.join([v for v in feature.split(',')[:4] if v != '*'])

def get_reading(feature):
    return feature.split(',')[7]

def get_base_form(feature):
    return feature.split(',')[6]
</code></pre>

<h2>解決した課題と未解決の課題</h2>

<p>この方法は undocumented な仕様に依存しているという課題がありましたが、一部は解決しています。</p>

<h3>環境変数 LD_LIBRARY_PATH の設定に依存</h3>

<p>これについては2017年12月現在ドキュメントに明示されています。</p>

<ul>
<li><a href="http://docs.aws.amazon.com/ja_jp/lambda/latest/dg/current-supported-versions.html#lambda-environment-variables">Lambda 関数で使用できる環境変数</a></li>
</ul>


<blockquote><p>/lib64、/usr/lib64、LAMBDA_TASK_ROOT、LAMBDA_TASK_ROOT/lib が含まれます。ヘルパーライブラリおよび関数コードの保存に使用されます。</p></blockquote>

<p>「zip ファイルが展開されるパス」と「zip ファイルが展開されるパス/lib」が含まれているので問題ありません。</p>

<p>また、<a href="https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/">前回の記事</a>を書いたときは環境変数の上書きは出来ませんでしたが、現在では可能になっています。</p>

<ul>
<li><a href="https://dev.classmethod.jp/cloud/aws/aws-lambda-env-variables/">【アップデート】AWS Lambdaで環境変数を使えるようになりました！！！</a></li>
</ul>


<h3>.zip ファイルが展開されるパスを決め打ち</h3>

<p>これに関してはドキュメントに明示的な記載を見つけることが出来ませんでした。
決め打ちが怖い人は <code>LAMBDA_TASK_ROOT</code> 環境変数を参照することをオススメします。</p>

<pre><code class="python lambda_function.py">root = os.environ.get("LAMBDA_TASK_ROOT", os.getcwd()) 
dicdir = os.path.join(root, 'lib', 'mecab', 'dic', 'ipadic')
rcfile = os.path.join(root, 'etc', 'mecabrc')
default_tagger = MeCab.Tagger("-d{} -r{}".format(dicdir, rcfile))
unk_tagger = MeCab.Tagger("-d{} -r{} --unk-feature 未知語,*,*,*,*,*,*,*,*".format(dicdir, rcfile))
</code></pre>

<h2>まとめ</h2>

<p>MeCabをAWS Lambdaで動かす(2017年版)最新版をお伝えしました。
通常のインストール方法との差はprefixの指定だけなので、
今までMeCabを利用していた人にとってはさほど高いハードルではないと思います。</p>

<p>とはいえ、依然としてLambda関数ビルド専用のLinux環境を用意する煩雑さはあります。
オフィシャルに提供されているAMIに加え、
<a href="https://github.com/lambci/docker-lambda">lambci/docker-lambda</a>Dockerイメージを使うという手もありますが、
Goのクロスコンパイルの簡単さはやはり魅力的ですね・・・。</p>

<h2>オマケ</h2>

<p><a href="https://shogo82148.github.io/Grongish/">グロンギ語語翻訳機</a> はこの方法でMeCabをLambda上で動かし、
API Gateway を用いてAPIとして公開しています。
実装例として遊んでみて下さい。</p>

<h2>参考</h2>

<ul>
<li><a href="https://dev.classmethod.jp/cloud/aws-lambda-with-mecab/">AWS Lambda で MeCab を動かす</a></li>
<li><a href="https://dev.classmethod.jp/cloud/improved-aws-lambda-with-mecab/">【改】AWS Lambda で MeCab を動かす</a></li>
<li><a href="https://qiita.com/norioxkimura/items/5ba3699cec54070566dc">AWS Lambda で JNI を利用する（MeCab を例として）</a></li>
<li><a href="http://docs.aws.amazon.com/ja_jp/lambda/latest/dg/current-supported-versions.html">Lambda 実行環境と利用できるライブラリ</a></li>
<li><a href="https://github.com/lambci/docker-lambda">lambci/docker-lambda</a></li>
<li><a href="https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/">AWS Lambda で MeCab を動かす(改)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AWS Lambda で MeCab を動かす(改)]]></title>
    <link href="https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda/"/>
    <updated>2016-02-10T14:52:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/02/10/mecab-in-lambda</id>
    <content type="html"><![CDATA[<p>MeCabのPythonバインディングをいじってた関係で、MeCabについてインターネットをさまよっていたら、
<a href="http://dev.classmethod.jp/cloud/aws-lambda-with-mecab/">AWS Lambda で MeCab を動かす</a>という記事を見つけました。
Lambdaの計算リソースで形態素解析できるのは楽しいですねー。
ただ実装にまだまだ改善できそうな部分があったので修正してみました。</p>

<p><strong>2017/12/06追記</strong>
Norio Kimuraさんのコメントを受けて、<a href="https://shogo82148.github.io/blog/2017/12/06/mecab-in-lambda/">MeCabをAWS Lambdaで動かす(2017年版)</a>を書きました。
以下の手順でも動きますが、少し簡単に出来るようになっています。</p>

<!-- More -->


<h2>問題点</h2>

<p>第一に<strong>「外部プロセスを起動しているので遅い」</strong>という点です。
外部プロセスの起動は非常に重くて数百msかかります。
MeCabは非常に高速で数msもあれば解析が終わるのに、もったいないですよね。</p>

<p>第二に<strong>「OSコマンドインジェクションの危険性がある」</strong>という点です。
解析対象の文字列をコマンドライン引数として渡しており、この際シェルを経由しています。
そのため、<code>{"sentence": "$(ls)"}</code>のような文字列を渡すと、シェルがコマンドとして実行してしまいます。
API Gatewayなどで外部に公開した場合、第三者が何でもし放題な状態になってしまいます。</p>

<h2>頑張ってMeCabをライブラリとして呼ぶ</h2>

<p>全ての元凶は外部プロセス起動にあるので、頑張ってMeCabをライブラリとして呼んでみましょう。
そもそもなんで外部プロセス起動をしていたかというと、
<code>LD_LIBRARY_PATH</code>が正しく設定されていないため<code>import MeCab</code>時に<code>libmecab.so</code>を発見できないからです。
なんとかならないものかと探したところ、Stack Overflowにそれっぽい記事がありました。</p>

<ul>
<li><a href="http://stackoverflow.com/questions/6543847/setting-ld-library-path-from-inside-python">Setting LD_LIBRARY_PATH from inside Python</a></li>
</ul>


<p>「環境変数を設定してから自分自身をexecし直す方法」と「<code>ctypes</code>を使って絶対パス指定で読み込む方法」が紹介されています。
前者の方がvoteは多いですがLambdaでこれをやるのは大変そうなので、後者で試してみます。</p>

<pre><code class="python lambda_function.py"># preload libmecab
import os
import ctypes
libdir = os.path.join(os.getcwd(), 'local', 'lib')
libmecab = ctypes.cdll.LoadLibrary(os.path.join(libdir, 'libmecab.so'))
</code></pre>

<p>一度読み込んでしまったライブラリは再利用されるため、
<code>import MeCab</code>はここで読み込んだライブラリにリンクされます(importの順番が重要なの闇な感じがする)。
<code>LD_LIBRARY_PATH</code>が正しく設定されている必要はありません。</p>

<p>さて、これで<code>lambda_function.py</code>と<code>tokenizer.py</code>が分かれている必要がなくなったので、二つを合体してみましょう。</p>

<pre><code class="python lambda_function.py"># coding=utf-8
import os
import settings

import logging
logger = logging.getLogger(__name__)
logger.setLevel(settings.LOG_LEVEL)

# preload libmecab
import ctypes
libdir = os.path.join(os.getcwd(), 'local', 'lib')
libmecab = ctypes.cdll.LoadLibrary(os.path.join(libdir, 'libmecab.so'))

import MeCab

# prepare Tagger
dicdir = os.path.join(os.getcwd(), 'local', 'lib', 'mecab', 'dic', 'ipadic')
rcfile = os.path.join(os.getcwd(), 'local', 'etc', 'mecabrc')
default_tagger = MeCab.Tagger("-d{} -r{}".format(dicdir, rcfile))
unk_tagger = MeCab.Tagger("-d{} -r{} --unk-feature 未知語,*,*,*,*,*,*,*,*".format(dicdir, rcfile))

DEFAULT_STOPTAGS = ['BOS/EOS']

def lambda_handler(event, context):
    sentence = event.get('sentence', '').encode('utf-8')
    stoptags = event.get('stoptags', '').encode('utf-8').split(',') + DEFAULT_STOPTAGS
    unk_feature = event.get('unk_feature', False)

    tokens = []
    tagger = unk_tagger if unk_feature else default_tagger
    node = tagger.parseToNode(sentence)
    while node:
        feature = node.feature + ',*,*'
        part_of_speech = get_part_of_speech(feature)
        reading = get_reading(feature)
        base_form = get_base_form(feature)
        token = {
            "surface": node.surface.decode('utf-8'),
            "feature": node.feature.decode('utf-8'),
            "pos": part_of_speech.decode('utf-8'),
            "reading": reading.decode('utf-8'),
            "baseform": base_form.decode('utf-8'),
            "stat": node.stat,
        }

        if part_of_speech not in stoptags:
            tokens.append(token)
        node = node.next
    return {"tokens": tokens}

def get_part_of_speech(feature):
    return '-'.join([v for v in feature.split(',')[:4] if v != '*'])

def get_reading(feature):
    return feature.split(',')[7]

def get_base_form(feature):
    return feature.split(',')[6]
</code></pre>

<h2>試してみる</h2>

<p><a href="https://github.com/shogo82148/aws-lambda-ja-tokenizer">forkして上記の修正をいれたレポジトリ</a>を用意したので、READMEにしたがってzipファイルを作り、Lambdaに登録しましょう。
雑なテストですが、Testボタンを5回押しみてログを見てみました。</p>

<p>まずは元記事にあったオリジナルのコードから。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Duration </th>
<th style="text-align:center;"> Billing Duration </th>
<th style="text-align:center;"> Memory Size </th>
<th style="text-align:center;"> Max Memory Used </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 280.76 ms </td>
<td style="text-align:center;"> 300 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 29 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 310.00 ms </td>
<td style="text-align:center;"> 400 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 29 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 205.99 ms </td>
<td style="text-align:center;"> 300 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 30 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 205.74 ms </td>
<td style="text-align:center;"> 300 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 30 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 213.96 ms </td>
<td style="text-align:center;"> 300 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 30 MB </td>
</tr>
</tbody>
</table>


<p>外部プロセスを起動しないように修正したバージョンです。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Duration </th>
<th style="text-align:left;"> Billing Duration </th>
<th style="text-align:center;"> Memory Size </th>
<th style="text-align:center;"> Max Memory Used </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 0.74 ms </td>
<td style="text-align:left;"> 100 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 11 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 0.74 ms </td>
<td style="text-align:left;"> 100 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 11 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 0.70 ms </td>
<td style="text-align:left;"> 100 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 11 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 0.69 ms </td>
<td style="text-align:left;"> 100 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 11 MB </td>
</tr>
<tr>
<td style="text-align:center;"> 0.73 ms </td>
<td style="text-align:left;"> 100 ms </td>
<td style="text-align:center;"> 128 MB </td>
<td style="text-align:center;"> 11 MB </td>
</tr>
</tbody>
</table>


<p>速くなった！！！</p>

<h2>まとめ</h2>

<ul>
<li>AWS Lambdaでは外部プロセス起動は案外重たいのでなるべく避ける</li>
<li>深遠な理由により外部プロセス起動する場合でもシェルは使わない方が無難</li>
<li><code>LD_LIBRARY_PATH</code>の設定が必要なときは、<code>ctypes.cdll.LoadLibrary</code>を使って直接読みこめばなんとかなる</li>
</ul>


<p>外部ライブラリを読み込めるのは、いろいろ遊べそうですね・・・</p>

<h2>追記(2016-02-15)</h2>

<p><a href="https://github.com/KunihikoKido/aws-lambda-ja-tokenizer/pull/1">pullreq送って</a>取り込んでもらいました。</p>

<ul>
<li><a href="http://dev.classmethod.jp/cloud/improved-aws-lambda-with-mecab/">【改】AWS Lambda で MeCab を動かす</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MeCabをPython3から使う(続報)]]></title>
    <link href="https://shogo82148.github.io/blog/2015/12/20/mecab-in-python3-final/"/>
    <updated>2015-12-20T01:03:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/12/20/mecab-in-python3-final</id>
    <content type="html"><![CDATA[<p>Python3からMeCabを扱おうとして挫折していたのですが
(<a href="http://shogo82148.github.io/blog/2015/06/02/mecab-in-python3/">MeCabをPython3から使う(中間報告)</a>)、
改めて調査して、上手くいかなかった原因が分かったのでご報告します。</p>

<!-- More -->


<h2>おさらい</h2>

<p>Python3で以下のようにMeCabを使おうとすると</p>

<pre><code class="python">import MeCab
tagger = MeCab.Tagger('')
text = u'MeCabで遊んでみよう!'
node = tagger.parseToNode(text)
while node:
    print(node.surface + '\t' + node.feature)
    node = node.next
</code></pre>

<p>surfaceが全く読み取れないという現象に遭遇していました。</p>

<pre><code class="plain">BOS/EOS,*,*,*,*,*,*,*,*
名詞,一般,*,*,*,*,*
助詞,格助詞,一般,*,*,*,で,デ,デ
動詞,自立,*,*,五段・バ行,連用タ接続,遊ぶ,アソン,アソン
助詞,接続助詞,*,*,*,*,で,デ,デ
Traceback (most recent call last):
  File "m.py", line 10, in &lt;module&gt;
  print( node.surface + '\t' + node.feature )
  UnicodeDecodeError: 'utf-8' codec can't decode byte 0xa3 in position 1: invalid start byte
</code></pre>

<h2>解決策</h2>

<p>詳しい原因なんてどうでもいいからMeCabを使いたい人向けに、最初に解決方法を書いておきます。
以下のように本当に解析したい対象を解析する前に、一度<code>parse</code>をしておけばOKです。</p>

<pre><code class="python">import MeCab
tagger = MeCab.Tagger('')

tagger.parse('') # これ重要！！！！

text = u'MeCabで遊んでみよう!'
node = tagger.parseToNode(text)
while node:
    print(node.surface + '\t' + node.feature)
    node = node.next
</code></pre>

<p>解析結果を全く使わずに捨てていて無駄のように思えますが、この一行が重要です！
これを入れると以下のように正常に解析ができます。</p>

<pre><code class="plain">        BOS/EOS,*,*,*,*,*,*,*,*
MeCab   名詞,一般,*,*,*,*,*
で      助詞,格助詞,一般,*,*,*,で,デ,デ
遊ん    動詞,自立,*,*,五段・バ行,連用タ接続,遊ぶ,アソン,アソン
で      助詞,接続助詞,*,*,*,*,で,デ,デ
みよ    動詞,非自立,*,*,一段,未然ウ接続,みる,ミヨ,ミヨ
う      助動詞,*,*,*,不変化型,基本形,う,ウ,ウ
!       名詞,サ変接続,*,*,*,*,*
        BOS/EOS,*,*,*,*,*,*,*,*
</code></pre>

<p>解析を行うメソッドであれば<code>parseToNode</code>でも構いません。</p>

<h2>原因</h2>

<p>結果が壊れる直接的な原因は<a href="http://shogo82148.github.io/blog/2012/12/15/mecab-python/">MeCabをPythonから使う注意点とか</a>で紹介したように、
解析対象の文字列がPythonの管理下から外れGCされてしまったからです。
高速化のために余計なメモリーアロケーションを避けており、メモリ管理は利用者の責任というわけです。</p>

<p>なんとかならないものかと、よくソースコードを追ってみると<code>MECAB_ALLOCATE_SENTENCE</code>というフラグをONにすれば
<a href="https://github.com/taku910/mecab/blob/6b392e3960a4f5562e18742cb390ae1e22353d2a/mecab/src/tagger.cpp#L769-L775">メモリ管理をMeCabに任せることができる</a>ということがわかりました。
これはTaggerを作るときの引数から指定でき、<code>-C</code>もしくは<code>--allocate-sentence</code>というオプションがこのフラグに対応します。
これを有効にすれば解決だ！と思ったのですが、実は各種言語バインディングからMeCabを利用する場合は<a href="https://github.com/taku910/mecab/blob/6b392e3960a4f5562e18742cb390ae1e22353d2a/mecab/swig/MeCab.i#L102">デフォルトで有効になっています</a>。</p>

<p>何故だ・・・とさらにコードを追ってみると<code>parseToNode</code>の実装が<a href="https://github.com/taku910/mecab/blob/6b392e3960a4f5562e18742cb390ae1e22353d2a/mecab/src/tagger.cpp#L602-L611">以下のようになっていること</a>がわかりました。</p>

<pre><code class="c">const Node *TaggerImpl::parseToNode(const char *str, size_t len) {
  Lattice *lattice = mutable_lattice();
  lattice-&gt;set_sentence(str, len); // このなかでMECAB_ALLOCATE_SENTENCEフラグが立ってるか確認している
  initRequestType();               // このなかでMECAB_ALLOCATE_SENTENCEフラグを立ててる
  if (!parse(lattice)) {
    set_what(lattice-&gt;what());
    return 0;
  }
  return lattice-&gt;bos_node();
}
</code></pre>

<p><strong>MECAB_ALLOCATE_SENTENCEフラグを立てる前に、立っているかを確認しています。</strong></p>

<p>解析対象の文字列を渡す前に<code>initRequestType()</code>を呼んで<code>MECAB_ALLOCATE_SENTENCE</code>フラグを立てれば良いのですが、
残念ながら<code>initRequestType()</code>も<code>mutable_lattice()</code>もprivateなメソッドなのでPythonから直接呼ぶことはできません。
そこで<code>parse()</code>を使って<code>initRequestType()</code>を間接的に呼び出せば問題解決というわけです。</p>

<h2>別解</h2>

<p><code>mutable_lattice()</code>は触れなくても、自分で作ったlatticeなら自由にいじれるので、
以下のようにlatticeをPython側で作るのも手ですね。</p>

<pre><code class="python">lattice = MeCab.Lattice()
import MeCab
tagger = MeCab.Tagger('')
lattice = MeCab.Lattice()
text = u'MeCabで遊んでみよう!'
lattice.set_sentence(text)
tagger.parse(lattice)
node = lattice.bos_node()
while node:
    print(node.surface+"\t"+node.feature)
    node = node.next
</code></pre>

<p>いずれの方法でもnodeからlatticeやtaggerへの参照がない(実際はあるけどPythonはそのことを知らない)ので、
解析結果を読んでいる最中にlatticeやtaggerがGCで回収されないよう注意しましょう。</p>

<h2>追記(2015-12-20)</h2>

<p>MeCab自体の問題っぽいので、MeCabにpullreq送って直してもらおうとソースいじってたけど、<a href="https://github.com/taku910/mecab/issues/5">すでにpatchあった</a>。
<a href="https://github.com/taku910/mecab/compare/master...shogo82148:request-type">patchを取り込んだブランチを用意した</a>ので、
GCされて困っている方はgit cloneしてお試し下さい。</p>

<h2>追記その2(2016-02-08)</h2>

<p>なんとか取り込んでもらおうと<a href="https://github.com/taku910/mecab/pull/24">Pull Request</a>にしてマージしてもらいました。
まだリリースはされていませんが、2016-02-08現在のmasterブランチをビルドすれば、ガーベージコレクションの問題はなくなるはずです。
<a href="https://twitter.com/chezou/status/696306806394474496">Twitterで作者に聞いてくれた</a>人がいたみたいで、僕のpulllreq以外もたくさんマージされたようです。
よかったよかった。リリースを心待ちにしています。
(が、<a href="https://github.com/taku910/mecab/pull/16">Python3対応のpullreq</a>はマージされていない・・・一応試してみてから+1しておこうかな)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tweepyの2.3.0が出ました]]></title>
    <link href="https://shogo82148.github.io/blog/2014/04/27/tweepy-2-dot-3-0-released/"/>
    <updated>2014-04-27T21:51:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2014/04/27/tweepy-2-dot-3-0-released</id>
    <content type="html"><![CDATA[<p>Tweepyの2.3.0が出ました。
「<a href="http://shogo82148.github.io/blog/2014/04/18/tweepy-will-application-only-auth/">Tweepy が Application-only Authentication に対応します</a>」僕のprも取り込まれていて、
Application-only Authentication が標準で使えるようになりました。
というわけで、早速遊んでみます。</p>

<h2>Application-only Authenticationで遊ぶ</h2>

<p>使い方は「<a href="http://shogo82148.github.io/blog/2013/05/09/application-only-authentication-with-tweepy/">tweepyでApplication-only Authenticationしてみた</a>」のときとほぼ同じ。
Tweepy本体に取り込んでもらったので、名前空間がちょこっと変わったくらいです。
Consumer Key と Consumer Secretだけ設定すればいいので、簡単に使えます。</p>

<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import tweepy
import codecs
import sys

sys.stdin = codecs.getreader('utf-8')(sys.stdin)
sys.stdout = codecs.getwriter('utf-8')(sys.stdout)

CONSUMER_KEY = 'YOUR CONSUMER KEY'
CONSUMER_SECRET = 'YOUR CONSUMER SECRET'

def main():
    user_id = "JO_RI"
    auth = tweepy.AppAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
    api = tweepy.API(auth)

    arg = {'id': user_id, 'include_rts': 1}
    user_statuses = tweepy.Cursor(api.user_timeline, **arg).items(3200)
    for user_status in user_statuses:
        print user_status.text

if __name__ == "__main__":
    main()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tweepy が Application-only authentication に対応します]]></title>
    <link href="https://shogo82148.github.io/blog/2014/04/18/tweepy-will-application-only-auth/"/>
    <updated>2014-04-18T06:37:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2014/04/18/tweepy-will-application-only-auth</id>
    <content type="html"><![CDATA[<p>以前 「<a href="http://shogo82148.github.io/blog/2013/05/09/application-only-authentication-with-tweepy/">tweepyでApplication-only Authenticationしてみた</a>」で
書いたTweepyのAuthHandlerを本体に取り込んでもらいました。
リリースタイミングとかよくわかってないですが、次のリリースとかでApplication-only Authenticationを簡単に使えるようになります、たぶん。</p>

<p>(2014-04-27追記)
このprを取り込んだTweepy 2.3.0がリリースされました。早速遊んでみたのでこちらもどうぞ><a href="http://shogo82148.github.io/blog/2014/04/27/tweepy-2-dot-3-0-released/">Tweepyの2.3.0が出ました</a></p>

<!-- More -->


<h2>取り込まれるまでの経緯</h2>

<ul>
<li>「Application-only Authentication 対応しないの？」って質問は去年からあった(<a href="https://github.com/tweepy/tweepy/issues/318">tweepy#318</a>)</li>
<li>先日「ここに動くコード載ってるよ」と<a href="https://github.com/tweepy/tweepy/issues/318#issuecomment-40291735">僕の記事が紹介される</a></li>
<li>昨日の夕方「コントリビュートしてみない？」とブログやgithub経由で頼まれる</li>
<li>やるしか無い！と思って昨日のうちにpr作成</li>
<li>朝起きたら取り込まれてた</li>
</ul>


<p>日本語なんてマイナーな言語で記事が書いてあっても、読んでくれる人は読んでくれるんですね。
Tweepy は僕も何度か使ったことがあるので Issue とかみて開発状況をチェックしていたんですが、
見覚えのある名前が見えたときはびっくりしました。</p>

<p>ちょっとしたコードでも公開しておくといいことがあるよ、というお話でした。
最近ここも全然更新してないので、もっとアウトプットしていかないと・・・。</p>
]]></content>
  </entry>
  
</feed>
