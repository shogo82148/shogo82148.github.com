<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mysql | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-12-06T05:42:49+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ぼくのかんがえたさいきょうのcontext対応版go-mysql-driverをマージしてもらった]]></title>
    <link href="https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context/"/>
    <updated>2017-06-16T07:11:15+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/go-sql-driver/mysql">go-sql-driver</a>に<code>context.Context</code>対応するプルリクエスト
<a href="https://github.com/go-sql-driver/mysql/pull/608">go-sql-driver/mysql#608</a>
を送って取り込んでもらいました！！
現時点ではまだ正式リリースされていませんが、次のリリース(version 1.4)から使えるようにはずです。
masterブランチではすでに使えるようになっているので、引き続き人柱募集中です。</p>

<p>コネクションプーリングを実装していて、自分も「<code>context.Context</code>サポートしたい！」というかたのために、
実装の概要をメモとして残しておきます。</p>

<!-- More -->


<h2>おおまかな仕組み</h2>

<ul>
<li>「<strong>contextの監視のみを行うgoroutine</strong>(以下、watcher goroutine)」をあらかじめ起動しておく</li>
<li>「<strong>やりたい処理を実際に実行するgoroutine</strong>(以下、executor goritune)」とchannelを経由して<code>context.Context</code>をやり取りする</li>
</ul>


<p>watcher goroutineがこの実装で一番重要な部分です。</p>

<h3>watcher goroutine の実装</h3>

<p>一番重要な watcher goroutine の実装例から見てみましょう
(実際には細かい最適化などが入るため、マージされたコードとは異なります)。</p>

<pre><code class="go">func (mc *mysqlConn) startWatcher() {
    // executor goritune と `context.Context` のやり取りをするための channel
    watcher := make(chan context.Context, 1)
    mc.watcher = watcher

    // executor goritune で処理が完了したことを知るための channel
    finished := make(chan struct{})
    mc.finished = finished

    // コネクションがCloseされたことを知らせるための channel
    mc.closech = make(chan struct{})

    // ここから watcher goroutine 本体
    go func() {
        for {
            // executor goritune から `context.Context` を待ち受ける
            var ctx context.Context
            select {
            case ctx = &lt;-watcher:
            case &lt;-mc.closech:
                // コネクションが Close されたので watcher gorutine を終了する
                return
            }

            // `context.Context` を監視する
            select {
            case &lt;-ctx.Done():
                // executor goritune を強制終了する
                mc.cancel(ctx.Err())
            case &lt;-finished:
                // 正常に処理が終了したので何もしない
            case &lt;-mc.closech:
                // コネクションが Close されたので watcher gorutine を終了する
                return
            }
        }
    }()
}
</code></pre>

<p><code>watcher</code>, <code>finished</code>, <code>closech</code> の3つの channel を経由して
executor goroutine と通信を行います。</p>

<h3>executor goroutine の実装</h3>

<p>executor goritune の実装例は以下のようになります。</p>

<pre><code class="go">// 何かやる
func (mc *mysqlConn) DoSomething(ctx context.Context) error {
    // watcher gorutineにctxを渡して監視してもらう
    if err := mc.watchCancel(ctx); err != nil {
        return err
    }

    // doSomthing()が実際に行いたい処理
    if err := mc.doSomthing(); err != nil {
        // キャンセルされたのか、ネットワークエラーで切断されたのか、を確認する
        if cerr := mc.canceled(); cerr != nil {
            return cerr
        }
        return err
    }

    // watcher gorutineに処理が終了したことを通知する
    mc.finish()

    return nil
}
</code></pre>

<p><code>mc.doSomthing()</code> が実際に行いたい処理なのですが、これに <code>ctx</code> を渡していないのがポイントです。
watcher goroutine に <code>ctx</code> の監視を任せているので、executor goroutine 側では監視しなくてもいいのです。</p>

<h3>executor goritune と watcher goroutine 間の通信</h3>

<p>executor goritune と watcher goroutine 間の通信は主に
<code>watcher</code> channel と <code>finished</code> channel が担当します。</p>

<pre><code class="go">func (mc *mysqlConn) watchCancel(ctx context.Context) error {
    // 実際の処理が始まるまえに、 `ctx` が終了していないか確認
    select {
    default:
    case &lt;-ctx.Done():
        return ctx.Err()
    }

    // watcher goroutineに渡す
    mc.watcher &lt;- ctx

    return nil
}

func (mc *mysqlConn) finish() {
    select {
    case mc.finished &lt;- struct{}{}:
    case &lt;-mc.closech:
    }
}
</code></pre>

<h3>キャンセルの実装</h3>

<p><code>context.Context</code>がキャンセルされたときに、executor goroutineを強制終了する処理は、
コネクションを強制的に <code>Close</code> することで行っています。
ちょっと強引な気はしますが、キャンセルされるような状況に陥った時点で正常な通信なんて出来ていないので、
まあいいかと、このような実装になっています。
もっと賢いキャンセルの方法があるかもしれませんが、キャンセルされない場合のほうが圧倒的に多いので、
余計なオーバーヘッドは避けたいというのもあります。</p>

<pre><code class="go">// キャンセルを実行する
func (mc *mysqlConn) cancel(err error) {
    // **コネクションを実際にCloseする前** にエラー内容を記録する
    mc.mu.Lock()
    mc.canceledErr = err
    mc.mu.Unlock()

    // 強制切断
    mc.cleanup()
}

// キャンセルされたか確認用
func (mc *mysqlConn) canceled() error {
    mc.mu.Lock()
    defer mc.mu.Unlock()
    return mc.canceledErr
}

func (mc *mysqlConn) cleanup() {
    // closeが2回以上実行されないようガード
    if atomic.SwapInt32(&amp;mc.closed, 1) != 0 {
        return
    }

    // (executor|watcher) goroutineに終了を通知
    close(mc.closech)

    // コネクションを切断
    mc.netConn.Close()
}
</code></pre>

<p>これらの関数は (executor|watcher) 両方の goroutine から呼ばれる可能性があるため、
以下の二点が非常に重要です。</p>

<ul>
<li>cancelでは <strong>コネクションを実際にCloseする前</strong> にエラー内容を記録する

<ul>
<li>これが逆だと executor がキャンセルを見逃してしまう場合がある</li>
</ul>
</li>
<li>sync package や sync/atomic package を使って <strong>goroutine-safe に書く</strong></li>
</ul>


<h2>FAQ(よくあるであろう質問)</h2>

<p>こっちの実装の方がいいんじゃないの？と実装中に自問自答した内容を
FAQと称して残しておきます。</p>

<h3>close(watcher)していないのはなぜ？</h3>

<p>最初は watcher goroutine の実装は以下のようになっていて、
<code>close(watcher)</code> で watcher goroutine を終了させようかと考えてました。</p>

<pre><code class="go">for ctx := range watcher {
    // context.Context監視処理
}
</code></pre>

<p>しかしこの実装では <code>mc.watcher &lt;- ctx</code> のところで <code>close</code> されていないかを毎回確認する必要があり、
channelを使うメリットが薄れてしまうので廃案となりました。</p>

<h3>close(finished)していないのはなぜ？</h3>

<p>監視の終了に <code>close(finished)</code> を使うという案も考えました。
しかしこの実装が廃案になったのには大きく二つの理由があります。</p>

<p>一つ目は「監視の終了は同期していなければならない」からです。
<code>close(finished)</code> を使った方法では executor goroutine が監視の終了を通知しても、
watcher goroutine が実際に監視を終了するタイミングは goroutine スケジューラの気分次第で遅れてしまう可能性があります。
すると watcher goroutine がクエリキャンセルしたときには、 executor goroutine では既に次のクエリが実行さており、
間違ったクエリをキャンセルしてしまうという事故が起こりえます。</p>

<p><code>finished &lt;- struct{}{}</code> を使った方法ならこれは起こりません。
executor goroutine が監視の終了を通知するのと、
watcher goroutine が実際に監視を終了するのとが同期しているので、
確実にキャンセルしたいクエリだけをキャンセルできます。</p>

<p>実際、PostgreSQLのGo driver実装は、最初 <code>close(finished)</code> で実装されていたものが、
<code>finished &lt;- struct{}{}</code> に置き換えられています(実装時には知らなくて、この記事を書いているときに知った)。</p>

<ul>
<li><a href="https://github.com/lib/pq/pull/535">Add context methods lib/pq#535</a></li>
<li><a href="https://github.com/lib/pq/pull/578">Fix race condition in query cancellation lib/pq#578</a></li>
</ul>


<p>二つ目は「channelの再利用ができない」という理由です。
一度 <code>close</code> した channel は <code>open</code> することはできないので、新規に channel を作る必要があります。
これにはメモリ確保が必要になるので、パフォーマンス面で不利になります。</p>

<h3>QueryContextの中でfinishを直接呼んでいないのはなぜ？</h3>

<p>QueryContext の実装をよく見てみると <code>rows.finish = mc.finish</code> しているだけで、
QueryContext の中では <code>finish</code> を呼んでいません。</p>

<ul>
<li><a href="https://github.com/go-sql-driver/mysql/blob/a825be04c652d01442384e9dcdf2cdc3f1eda67f/connection_go18.go#L87">QueryContext</a></li>
</ul>


<p>これはなぜかというと <code>QueryContext</code> の実行が終了した後、
rows の読み取り中に、<code>context.Context</code> がキャンセルされる場合があるからです。
たとえば以下のコードで、<code>rows.Err()</code> は <code>context.Canceled</code> になっているべきです。</p>

<pre><code class="go">ctx, cancel := context.WithCancel(context.Background())
rows, _ := dbt.db.QueryContext(ctx, "SELECT v FROM test")
rows.Next()
if err := rows.Scan(&amp;v); err != nil {
    panic(err)
}

cancel()
time.Sleep(100 * time.Millisecond)

rows.Next()
// rows.Err() は context.Canceled になっているべき
if err := rows.Err(); err != context.Canceled {
    panic(err)
}
</code></pre>

<p>この挙動は net/http を参考にしています。</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "net/http/httptest"
    "time"
)

func main() {
    log.SetFlags(log.LstdFlags | log.Lshortfile)

    // 1秒わざとレスポンスを返さないサーバー
    ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Context-Type", "text/plain")
        w.WriteHeader(200)
        fmt.Fprint(w, "Hello, ")
        w.(http.Flusher).Flush()
        time.Sleep(time.Second)
        fmt.Fprint(w, "client\n")
    }))
    defer ts.Close()

    req, err := http.NewRequest("GET", ts.URL, nil)
    if err != nil {
        log.Fatal(err)
    }

    // 0.5秒後にキャンセル
    ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
    go func() {
        time.Sleep(500 * time.Millisecond)
        cancel()
    }()
    defer cancel()

    req = req.WithContext(ctx)
    res, err := http.DefaultClient.Do(req)
    if err != nil {
        log.Fatal(err)
    }

    // ioutil.ReadAll は "context canceled" か "context deadline exceeded" で失敗する
    greeting, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%s", greeting)
}
</code></pre>

<h3>BeginTxの中ではfinishを直接呼んでいるのはなぜ？</h3>

<p><code>BeginTx</code> では <code>finish()</code> を呼んでいます。
<code>BeginTx</code>終了後にトランザクションがキャンセルされる場合を考えると、
<code>QueryContext</code> と同様に <code>tx.finish = mc.finish</code> となりそうですが、そうはなっていません。</p>

<p>これは database/sql が代わりに監視してくれていて、
<code>context.Context</code> がキャンセルされると自動的にRollbackしてくれるからです。</p>

<ul>
<li><a href="https://github.com/golang/go/blob/go1.8.3/src/database/sql/sql.go#L1435-L1447">Tx.awaitDone() (database/sql)</a></li>
</ul>


<p>実は rows にも同様の監視処理が入っているので勝手に <code>Close</code> してくれます。
しかし、packetの読み書きを <code>context.Context</code> 対応にする必要があり、
実装コスト・実行コストが大きそうだったので手を付けていません。</p>

<h2>まとめ</h2>

<p>executor goroutine と watcher goroutine を使った <code>context.Context</code> 対応の実装例を紹介しました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis、PostgreSQL、MySQLで近傍検索]]></title>
    <link href="https://shogo82148.github.io/blog/2017/03/28/database-gis/"/>
    <updated>2017-03-28T19:59:49+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/03/28/database-gis</id>
    <content type="html"><![CDATA[<p>「<a href="http://techblog.kayac.com/serverside-geohash">サーバーで付近の情報を通知するサービスのつくり方</a>」
という、Geohashを使って近傍検索を実現する記事をみつけました。
最近<a href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/">Redisに関する記事</a>を書いた関係で、
この記事をみて「GeohashはRedisと一緒に使うともっと便利だよ！」と思わず宣伝したくなったのですが、
MySQL5.7でInnoDBに空間インデックス(Spatial Index)のサポートが入ったので
「MySQLでももっと簡単にできるのでは？」と思い、
RedisやMySQLを含めたいろんなDBで近傍検索を実現する方法を調べてみました。</p>

<p>以前、<a href="https://shogo82148.github.io/blog/2012/08/02/fireworks/">スマートフォンのセンサを活用して花火の打ち上げ場所を推定するアプリ</a>を作った関係で、
地球上での距離計算の実装も気になったので、それについても調査してみました。</p>

<!-- More -->


<h2>関連知識</h2>

<h3>GeoHash</h3>

<p><a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%82%AA%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5">Geohash（ジオハッシュ）</a>
は緯度・経度を短い文字列に変換する方法です。
距離が近い2地点のGeohashは似たような文字列になるという特徴があります(一部例外あり)。
この特徴を利用すると、文字列検索だけで近傍検索が実現できます。</p>

<h3>地球上の二点間の距離</h3>

<p>地球は完全な球体ではなく、回転楕円体であることが知られています。
地球の形がわからないと緯度・経度などを決められないので、
<a href="https://ja.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E6%A5%95%E5%86%86%E4%BD%93">地球楕円体</a>が定義されています。
近似方法によっていくつか種類があるのですが、GPSなどで使われているWGS84がよく使われているようです。</p>

<p>国土地理院が提供している<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/main.html">測量計算サイト</a>では
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/bl2stf.html">距離と方位角の計算</a>を使って緯度・経度から距離を計算できます。
回転楕円体上の距離の厳密解は求められない(要出典)ので、
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/algorithm/bl2st/bl2st.htm">数値計算</a>によって求めることになります。
計算式を見て分かる通り非常に複雑なので、なんらかの近似をしている実装がほとんどです。</p>

<h2>各種DBでの実現方法</h2>

<h3>Redis</h3>

<p>Redisでは3.2から<a href="https://redis.io/commands#geo">GEO</a>関連の機能をサポートしています。
ソート済みセットにGeohashを組み合わせて実現しています。</p>

<p>簡単に試してみました。データは以下の記事から拝借したものを使用します。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/ilo/20090212/1234448136">MySQLで指定した緯度経度から半径nメートル内検索っぽいのを実現するSQL</a></li>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<p><a href="https://redis.io/commands/geoadd"><code>GEOADD</code></a>でデータ挿入です。
ちなみにデータを削除する<code>GEODEL</code>は用意されていないとのこと。
中身はソート済みセットなので、<a href="https://redis.io/commands/zrem">ZREM</a>でいいんですね。</p>

<pre><code class="plain">$ cat command.txt
GEOADD geotable 139.777254 35.713768 上野駅         139.774029 35.711846 西郷隆盛像
GEOADD geotable 139.774744 35.712737 上野の森美術館 139.770872 35.712351 不忍池弁財天
GEOADD geotable 139.775696 35.716293 野口英世博士像 139.775803 35.715420 国立西洋美術館
GEOADD geotable 139.776544 35.716319 国立科学博物館 139.772776 35.717186 東京都美術館
GEOADD geotable 139.776462 35.718883 東京国立博物館 139.794547 35.715280 花やしき
GEOADD geotable 139.792692 35.710635 雷門
$ redis-cli &lt; command.txt
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 1
</code></pre>

<p><code>GEOHASH</code>で各地点のGeohashを取得できます。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEOHASH geotable 上野駅 西郷隆盛像 上野の森美術館
1) "xn77htqxy10"
2) "xn77hthkdf0"
3) "xn77htkcg80"
</code></pre>

<p><code>GEORADIUS</code>で近傍検索ができます。
上野駅から半径300m以内の地点を求める例です。
データに日本語を使ったので非常にわかりにくいですが、
上野駅から近い順に「上野駅」「国立西洋美術館」「上野の森美術館」「国立科学博物館」の距離と座標を返してくれました。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEORADIUS geotable 139.777254 35.713768 300 m WITHCOORD WITHDIST ASC
1) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe9\xa7\x85"
   2) "0.1203"
   3) 1) "139.77725297212600708"
      2) "35.71376868735887911"
2) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe8\xa5\xbf\xe6\xb4\x8b\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "225.4920"
   3) 1) "139.77580457925796509"
      2) "35.71541879083360271"
3) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe3\x81\xae\xe6\xa3\xae\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "254.1580"
   3) 1) "139.77474242448806763"
      2) "35.71273705584702896"
4) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe7\xa7\x91\xe5\xad\xa6\xe5\x8d\x9a\xe7\x89\xa9\xe9\xa4\xa8"
   2) "290.8339"
   3) 1) "139.77654486894607544"
      2) "35.71631861684517872"
</code></pre>

<p>上野駅と上野駅の距離は当然0mなはずですが、ちょっとだけズレてます。
これはソート済みセットの制約で緯度・経度それぞれ53bitを26bitにまるめているからです(たぶん)。
距離の計算は<a href="https://github.com/antirez/redis/blob/4.0/src/geohash_helper.c#L52">半径6372797.560856mの完全な球体</a>で近似し、
<a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>というのを使っています。</p>

<p>ちなみに扱える緯度・経度には以下の制限があり、極付近の座標は扱えません。</p>

<ul>
<li>経度 -180度から180度</li>
<li>緯度 -85.05112878度から85.05112878度</li>
</ul>


<p>これは Spherical Mercator(球面メルカトル図法) の制限らしいです。
Google Maps, OpenStreetMap, Bing 等でよく見る地図は平面ですが、本来の地球は丸いので、うまく平面にマッピングする必要があります。
このときにどうしても本来の地形から歪んでしまうわけですが、
極付近では歪みが無限大になってしまいうまく平面の地図にできないのです。</p>

<p>ただ、Redis自体は平面へのマッピングをしないので、別にこの制限要らな気もします。
まあ、コーナーケースなので他にも問題がありそうですし、
そもそも北極・南極向けにサービス作らないので気にしないでおきましょう。</p>

<h3>PostgreSQL</h3>

<p>日本語で書かれた先行事例を見つけたので、PostgreSQLの紹介から。
以下の記事にあるように、PostGISというオプション機能をインストールすると簡単に実現できます。</p>

<ul>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<pre><code class="sql">-- PostGISを有効化
CREATE EXTENSION postgis;

-- テーブルの作成
CREATE TABLE geotable (
    id   SERIAL NOT NULL PRIMARY KEY,
    name varchar (255) NOT NULL,
    geom geography(POINT, 4326) NOT NULL
);

-- データの挿入
INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeographyFromText('SRID=4326;POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeographyFromText('SRID=4326;POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeographyFromText('SRID=4326;POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeographyFromText('SRID=4326;POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeographyFromText('SRID=4326;POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeographyFromText('SRID=4326;POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeographyFromText('SRID=4326;POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeographyFromText('SRID=4326;POINT(139.776462 35.718883)')),
('花やしき', ST_GeographyFromText('SRID=4326;POINT(139.794547 35.71528)')),
('雷門', ST_GeographyFromText('SRID=4326;POINT(139.792692 35.710635)'));

-- 空間インデックスの作成
CREATE INDEX gist_geotable on geotable USING GIST (geom);
</code></pre>

<p><code>ST_GeoHash</code>でGeohashを求めることができます。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom) FROM geotable;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |      st_geohash
-----------------------+-----------------------------+----------------------
 上野駅             | POINT(139.777254 35.713768) | xn77htqxy0fu2t0y69sv
 西郷隆盛像       | POINT(139.774029 35.711846) | xn77hthkdfw51p8cmr68
 上野の森美術館 | POINT(139.774744 35.712737) | xn77htkcg8enm86bp3j7
 不忍池弁財天    | POINT(139.770872 35.712351) | xn77ht4p92sp8jdqkjzf
 野口英世博士像 | POINT(139.775696 35.716293) | xn77htvw3z9495yr4dxd
 国立西洋美術館 | POINT(139.775803 35.71542)  | xn77htv9kkbffr4ptjcy
 国立科学博物館 | POINT(139.776544 35.716319) | xn77htynts3mer092t8v
 東京都美術館    | POINT(139.772776 35.717186) | xn77hw57twp9x63n6vus
 東京国立博物館 | POINT(139.776462 35.718883) | xn77hwqjedkhwdmmwp0n
 花やしき          | POINT(139.794547 35.71528)  | xn77jjg2949rgdfxbrjp
 雷門                | POINT(139.792692 35.710635) | xn77jhcvtbf5mdcexf85
(11 rows)
</code></pre>

<p>近傍検索には<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_DWithin.html"><code>ST_DWithin</code></a>を使います。
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance.html"><code>ST_Distance</code></a>や
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Sphere.html"><code>ST_Distance_Sphere</code></a>、
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Spheroid.html"><code>ST_Distance_Spheroid</code></a>等
を使って距離を計算して絞り込むことも出来ますが、これらの関数はインデックスを使ってくれません。
<code>ST_DWithin</code>は
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/using_postgis_dbmanagement.html#id286995989">GiSTインデックス</a>
を利用してくれるので高速に処理してくれます。</p>

<pre><code class="sql">SELECT
    name,
    ST_AsText(geom),
    ST_Distance('SRID=4326;POINT(139.777254 35.713768)', geom) as dist
FROM geotable
WHERE ST_DWithin(geom, ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)'), 300.0)
ORDER BY dist;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |     dist
-----------------------+-----------------------------+---------------
 上野駅             | POINT(139.777254 35.713768) |             0
 国立西洋美術館 | POINT(139.775803 35.71542)  | 225.468916585
 上野の森美術館 | POINT(139.774744 35.712737) | 254.308127877
 国立科学博物館 | POINT(139.776544 35.716319) | 290.242707221
</code></pre>

<p><code>ST_</code>で始まる関数は<a href="http://www.opengeospatial.org/standards/sfs">OpenGIS</a>やSQL/MMで標準化されているものらしいです。</p>

<h3>MySQL</h3>

<p>MySQLに関しては以下の記事を見つけました。
この記事が書かれた頃はMyISAMでしか空間インデックスをサポートしていませんでしたが、
5.7からInnoDBでもサポートされるようになったので、
InnoDBでも同様のことができるはずです。</p>

<ul>
<li><a href="http://qiita.com/kochizufan/items/a68b30ba74849483f75c">mysql空間テーブルの作り方</a></li>
</ul>


<p>MySQL5.7で入った機能についてはこちらを参照。
空間インデックス以外にも大量に変更があるので、アップグレードする人は確認をおすすめします。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B01LCJRCYE&linkId=ac9d8d9e348bd97dc858337c94e82696"></iframe>


<p>MySQLもPostgreSQLもOpenGISに準拠する方針みたいなので、
PostgreSQLと同じ感じでSQLが書けると信じたいところですが、
当然ながらそうは行きません。</p>

<p>一番大きな違いは<code>geography</code>型には対応しておらず<code>geometry</code>型しか使えないということです。
<code>geography</code>型は測地系の情報を持っている(つまり地球が回転楕円体だということを知っている)のですが、
<code>geometry</code>型は測地系の情報が無いため、平面しか扱えません。</p>

<pre><code class="sql">CREATE DATABASE test; -- 5.6以前は勝手に作ってくれたけど、5.7からは無いらしい
USE test;
CREATE TABLE IF NOT EXISTS `geotable` (
  `id`   int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR (255) NOT NULL,
  `geom` geometry NOT NULL,
  PRIMARY KEY (`id`),
  SPATIAL KEY `geom` (`geom`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
</code></pre>

<p>座標の指定も<code>ST_GeographyFromText</code>ではなく<code>ST_GeomFromText</code>を使います。</p>

<pre><code class="sql">INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeomFromText('POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeomFromText('POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeomFromText('POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeomFromText('POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeomFromText('POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeomFromText('POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeomFromText('POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeomFromText('POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeomFromText('POINT(139.776462 35.718883)')),
('花やしき', ST_GeomFromText('POINT(139.794547 35.71528)')),
('雷門', ST_GeomFromText('POINT(139.792692 35.710635)'));
</code></pre>

<p>PostgreSQLと同様にGeohashを求める<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-geohash-functions.html"><code>ST_GeoHash</code>があります</a>が、
桁数を指定する必要があるという違いがあります。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom, 11) FROM geotable;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+----------------------+
| name                  | ST_AsText(geom)             | ST_GeoHash(geom, 11) |
+-----------------------+-----------------------------+----------------------+
| 上野駅                | POINT(139.777254 35.713768) | xn77htqxy0f          |
| 西郷隆盛像            | POINT(139.774029 35.711846) | xn77hthkdfw          |
| 上野の森美術館        | POINT(139.774744 35.712737) | xn77htkcg8e          |
| 不忍池弁財天          | POINT(139.770872 35.712351) | xn77ht4p92s          |
| 野口英世博士像        | POINT(139.775696 35.716293) | xn77htvw3z9          |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | xn77htv9kkb          |
| 国立科学博物館        | POINT(139.776544 35.716319) | xn77htynts3          |
| 東京都美術館          | POINT(139.772776 35.717186) | xn77hw57twp          |
| 東京国立博物館        | POINT(139.776462 35.718883) | xn77hwqjedk          |
| 花やしき              | POINT(139.794547 35.71528)  | xn77jjg2949          |
| 雷門                  | POINT(139.792692 35.710635) | xn77jhcvtbf          |
+-----------------------+-----------------------------+----------------------+
11 rows in set (0.00 sec)
</code></pre>

<p>MySQLにも距離を求める<code>ST_Distance</code>はあるのですが、これは平面専用です。
地球上での距離を求めるには<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-convenience-functions.html"><code>ST_Distance_Sphere</code>を使います</a>。
MySQL5.7から追加された関数で、これを使うと半径6370986mの球体で近似したときの距離を計算できます。</p>

<p>そして残念なことにPostgreSQLにはあった<code>ST_DWithin</code>はMySQLにはありません。
<code>ST_Distance_Sphere</code>を使えばクエリは書けるのですが、インデックスを使ってくれないので非効率です。
そのため、矩形の範囲指定で大雑把に絞り込んだあとで<code>ST_Distance_Sphere</code>を使って詳細に絞り込むことになります。</p>

<pre><code class="sql">SET @ueno = ST_GeomFromText('POINT(139.777254 35.713768)');
SELECT
    name,
    ST_AsText(geom),
    ST_Distance_Sphere(@ueno, geom) AS dist
FROM geotable
WHERE ST_Distance_Sphere(@ueno, geom) &lt;= 300
AND ST_Within(geom, ST_Buffer(@ueno, DEGREES(300/(6370986*COS(RADIANS(ST_Y(@ueno))))), ST_Buffer_Strategy('point_square')))
ORDER BY dist;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+--------------------+
| name                  | ST_AsText(geom)             | dist               |
+-----------------------+-----------------------------+--------------------+
| 上野駅                | POINT(139.777254 35.713768) |                  0 |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | 225.62014319497658 |
| 上野の森美術館        | POINT(139.774744 35.712737) | 253.96163316266237 |
| 国立科学博物館        | POINT(139.776544 35.716319) | 290.81011310408957 |
+-----------------------+-----------------------------+--------------------+
4 rows in set (0.00 sec)
</code></pre>

<p>緯度によって経度1度あたりの長さが違うので、矩形選択の範囲に補正を入れてあります。
本当は緯度の補正は無くても良いはずですが、広めならいいだろ！ってことで雑に書いています。
本番で使いたい人は補正＆バリデーション頑張ってください(特に極の辺りで大変なことになるので)。</p>

<h3>その他DB</h3>

<p>力尽きたので簡単に。</p>

<p>SQLiteは<a href="https://www.gaia-gis.it/fossil/libspatialite/index">SpatiaLite</a>という拡張モジュールで空間データを扱えるようです。</p>

<p>全文検索エンジンの<a href="http://groonga.org/ja/">Groonga</a>も近傍検索に対応していて、
距離の計算方法は以下の3つから選べるようです。
(<a href="http://groonga.org/ja/docs/reference/functions/geo_distance.html"><code>geo_distance</code></a>)</p>

<ul>
<li><code>rectangle</code>: 方形近似して距離を計算</li>
<li><code>sphere</code>: <a href="https://github.com/groonga/groonga/blob/v7.0.0/lib/grn_geo.h#L42">半径6357303m</a>の完全な球体と仮定して計算</li>
<li><code>ellipsoid</code>: WGS84地球楕円体を<a href="http://yamadarake.jp/trdi/report000001.html">ヒュベニの距離計算式</a>で近似</li>
</ul>


<p>ヒュベニの距離計算式というのが出てきましたが、<code>ellipsoid</code>で使っているのは簡易版で、
<a href="http://www.amano-tec.com/apps/paceruler.html">本来のヒュベニの距離計算式</a>は非常に複雑で難しい・・・。</p>

<h2>まとめ</h2>

<p>Redis、PostgreSQL、MySQLで近傍検索をやってみました。</p>

<ul>
<li>Redisは近傍検索だけならお手軽</li>
<li>PostgreSQL+PostGISは今回触った中では最強。地理データを真面目に扱うならいいかも</li>
<li>MySQLは5.6以前よりは扱いやすくなったものの、空間インデックスを効果的に使うには一工夫必要</li>
</ul>


<p>PostgreSQL+PostGISと比べると、どうしてもMySQL5.7は見劣りしますね。
しかし、検索をSQLで書けるという利点は大きいので、利用を検討する価値はあると思います。</p>

<p>ところで、大体のDBで地球を完全な球で近似する実装が入ってるんですが、
半径が微妙に違うんですよね。</p>

<ul>
<li>Redis: 6 372 797.560 856m</li>
<li>PostgreSQL: 6 370 986m</li>
<li>MySQL: 6 370 986m</li>
<li>Groonga: 6 357 303m</li>
<li>赤道半径: 6 378 137m</li>
<li>極半径: 6 356 752.314 245m</li>
</ul>


<p>0.24%しか違わないので、実用上は全く問題ないんですが、
出典がよくわからないし気になります。</p>
]]></content>
  </entry>
  
</feed>
