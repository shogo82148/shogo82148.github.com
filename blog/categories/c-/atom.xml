<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2014-10-17T00:39:06+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[初期化なしのusing文ってOK？]]></title>
    <link href="http://shogo82148.github.io/blog/2014/05/27/using-statement-without-instantiating/"/>
    <updated>2014-05-27T13:48:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/05/27/using-statement-without-instantiating</id>
    <content type="html"><![CDATA[<p>C# の using ステートメント、普通は変数の初期化とか new とかをまとめてやるものだと思ってたんですが、
某プロジェクトでusing文をこんな感じで使っているのを見かけました。</p>

<p>``` csharp
var hoge = new Hoge();
using(hoge) { // using( var hoge = new Hoge() ) { ならよく見る</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<p>見慣れない書き方だったので、本当にリソース解放が行われているのか不安・・・。
リソース解放が行われているのか調べてみました。</p>

<!-- More -->


<h2>まずは結論</h2>

<ul>
<li>リソース解放自体は行われているので、ちゃんと書いてあれば問題なし</li>
<li>しかしエラーをコンパイル時に見つけられない場合があるので非推奨</li>
</ul>


<h2>逆アセンブルして調べてみた</h2>

<p>コンパイル結果見ればちゃんとリソース解放されているかわかるよね！
ってことでバイナリを逆アセンブルして調べてみました。</p>

<h3>サンプルコード</h3>

<p>検証に使ったのはこんなコード。</p>

<p>``` csharp
using System;
using System.IO;</p>

<p>namespace UsingTest
{</p>

<pre><code>class MainClass
{
    public static void Main (string[] args)
    {
        var sr = new StreamReader ("hoge.txt");
        Console.WriteLine ("Hoge: {0}", sr.ReadLine ());
    }
}
</code></pre>

<p>}
```</p>

<p>僕はMac使いに転向したので、Monoを使います。
<code>mcs</code>を使ってコンパイル、<code>monodis</code> ってのを使うとILを見れるらしいです。
Windowsだったら .NET Framework SDK に <code>ildasm</code> ってのが付属してるので、それで見れるはず。</p>

<p><code>bash
mcs UsingTest.cs
monodis UsingTest.exe
</code></p>

<p>標準出力にILが吐かれます。</p>

<p>``` plain
.assembly extern mscorlib
// ... 中略 ...
.namespace UsingTest
{
  .class private auto ansi beforefieldinit MainClass</p>

<pre><code> extends [mscorlib]System.Object
</code></pre>

<p>  {</p>

<pre><code>// method line 1
.method public hidebysig specialname rtspecialname
       instance default void '.ctor' ()  cil managed
{
    // Method begins at RVA 0x2050
// Code size 7 (0x7)
.maxstack 8
IL_0000:  ldarg.0
IL_0001:  call instance void object::'.ctor'()
IL_0006:  ret
} // end of method MainClass::.ctor

// method line 2
.method public static hidebysig
       default void Main (string[] args)  cil managed
{
    // Method begins at RVA 0x2058
.entrypoint
// Code size 29 (0x1d)
.maxstack 2
.locals init (
    class [mscorlib]System.IO.StreamReader  V_0)
    IL_0000:  nop
    IL_0001:  ldstr "hoge.txt"
    IL_0006:  newobj instance void class [mscorlib]System.IO.StreamReader::'.ctor'(string)
    IL_000b:  stloc.0
    IL_000c:  ldstr "Hoge: {0}"
    IL_0011:  ldloc.0
    IL_0012:  callvirt instance string class [mscorlib]System.IO.TextReader::ReadLine()
    IL_0017:  call void class [mscorlib]System.Console::WriteLine(string, object)
    IL_001c:  ret
} // end of method MainClass::Main
</code></pre>

<p>  } // end of class UsingTest.MainClass
}
```</p>

<p>Disposeが呼ばれてない！
リソース解放されてないぞ！！</p>

<h3>usingと一緒に初期化してみる</h3>

<p>usingステートメントを使って解放処理をしてみます。</p>

<p>``` csharp
using (var sr = new StreamReader ("hoge.txt")) {</p>

<pre><code>Console.WriteLine ("Hoge: {0}", sr.ReadLine ());
</code></pre>

<p>}
```</p>

<p>``` plain
// Code size 49 (0x31)
.maxstack 2
.locals init (</p>

<pre><code>class [mscorlib]System.IO.StreamReader  V_0)
</code></pre>

<p>IL_0000:  nop
IL_0001:  ldstr "hoge.txt"
IL_0006:  newobj instance void class [mscorlib]System.IO.StreamReader::'.ctor'(string)
IL_000b:  stloc.0
.try { // 0
  L_000c:  nop
  IL_000d:  ldstr "Hoge: {0}"
  IL_0012:  ldloc.0
  IL_0013:  callvirt instance string class [mscorlib]System.IO.TextReader::ReadLine()
  IL_0018:  call void class [mscorlib]System.Console::WriteLine(string, object)
  IL_001d:  nop
  IL_001e:  leave IL_0030</p>

<p>} // end .try 0
finally { // 0
  IL_0023:  ldloc.0
  IL_0024:  brfalse IL_002f</p>

<p>  IL_0029:  ldloc.0
  IL_002a:  callvirt instance void class [mscorlib]System.IDisposable::Dispose()
  IL_002f:  endfinally
} // end handler 0
IL_0030:  ret
} // end of method MainClass::Main
```</p>

<p>自動的に try-finall節が作られ、その中でDisposeが呼ばれています。(たぶん。ILよくわかんないけど)</p>

<h3>usingでは初期化しない</h3>

<p>次にusingの外で初期化</p>

<p>``` csharp
var sr = new StreamReader ("hoge.txt");
using (sr) {</p>

<pre><code>Console.WriteLine ("Hoge: {0}", sr.ReadLine ());
</code></pre>

<p>}
```</p>

<p>``` plain
// Code size 51 (0x33)
.locals init (</p>

<pre><code>class [mscorlib]System.IO.StreamReader V_0,
class [mscorlib]System.IO.StreamReader V_1)
</code></pre>

<p>IL_0000:  nop
IL_0001:  ldstr "hoge.txt"
IL_0006:  newobj instance void class [mscorlib]System.IO.StreamReader::'.ctor'(string)
IL_000b:  stloc.0
IL_000c:  ldloc.0
IL_000d:  stloc.1
.try { // 0
  IL_000e:  nop
  IL_000f:  ldstr "Hoge: {0}"
  IL_0014:  ldloc.0
  IL_0015:  callvirt instance string class [mscorlib]System.IO.TextReader::ReadLine()
  IL_001a:  call void class [mscorlib]System.Console::WriteLine(string, object)
  IL_001f:  nop
  IL_0020:  leave IL_0032</p>

<p>} // end .try 0
finally  { // 0
  IL_0025:  ldloc.1
  IL_0026:  brfalse IL_0031</p>

<p>  IL_002b:  ldloc.1
  IL_002c:  callvirt instance void class [mscorlib]System.IDisposable::Dispose()
  IL_0031:  endfinally
} // end handler 0
IL_0032:  ret
```</p>

<p>お、ちゃんとDispose呼ばれてるみたい！
リソース解放はされてますね。</p>

<p>上のILをよく見ると、ローカル変数が２つ定義されています。
どうやらusingの中と外では同じ<code>sr</code>を指定しても別変数として扱われているようです。
そのためにコピーするコードが追加されているので、コードサイズが2byteほど増えてます。</p>

<h3>ブロックの外でインタンスを使う</h3>

<p><code>sr</code> のスコープは<code>Main</code>メソッドの中全体なので、usingのあとに<code>sr</code> をいじってもコンパイルは通ります。</p>

<p>``` csharp
var sr = new StreamReader ("hoge.txt");
using (sr) {</p>

<pre><code>Console.WriteLine ("Hoge: {0}", sr.ReadLine ());
</code></pre>

<p>}
Console.WriteLine ("Hoge: {0}", sr.ReadLine ()); // 例外を吐いて死ぬ
```</p>

<p>しかし、最後の行で例外を吐いて死にます。
使えるけど使うと死ぬインスタンスが残ってるの気持ち悪いですね・・・。</p>

<h2>再び結論</h2>

<p>ちゃんと Dispose は呼ばれるので、usingを抜けたところでリソース解放は行われます。
(たった2byteだけど)意味の無いILが生成されたり、コンパイル時のチェックがされなかったり、
あんまりいいことが無いので積極的に使う理由はないですね。</p>

<h2>SEE ALSO</h2>

<p>ちゃんとドキュメントに書いてあった。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/yh598w02.aspx">using ステートメント (C# リファレンス)</a></li>
</ul>


<blockquote><p>リソース オブジェクトをインスタンス化して、変数を using ステートメントに渡すことは可能ですが、これはベスト プラクティスではありません。
You can instantiate the resource object and then pass the variable to the using statement, but this is not a best practice.</p></blockquote>
]]></content>
  </entry>
  
</feed>
