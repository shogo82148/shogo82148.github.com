<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AjaxIME | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/ajaxime/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2014-10-22T23:55:32+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavascriptでIME]]></title>
    <link href="http://shogo82148.github.io/blog/2012/03/28/igoime/"/>
    <updated>2012-03-28T22:00:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/03/28/igoime</id>
    <content type="html"><![CDATA[<p>この前いじった<a href="http://shogo82148.github.com/AjaxIME">Chrome17対応版AjaxIME</a>は
実際の変換を行うのに本家<a href="http://ajaxime.chasen.org/">AjaxIME</a>が提供している変換サーバをそのまま使用しています。
そのため、すべての入力内容は本家サーバに送信されてしまいます。
どんな入力をしたのか作者さんにバレバレです。
この送信内容、暗号化すらされていないので、作者以外の人に見られる可能性もあります。
自分の書いた文章が勝手にインターネットに送信されているっていうのはあんまり嬉しくないですね。
ローカルのみで完結するのが理想です。</p>

<p>本家サーバはどうやら<a href="http://chasen.org/~taku/software/mecab-skkserv/">mecab-skkserv</a>と同じエンジンを使っているようです。
このバックエンドで動いているのは実は<a href="http://mecab.googlecode.com/svn/trunk/mecab/doc/index.html">MeCab</a>。
ということは、MeCabと互換性のある<a href="https://github.com/shogo82148/igo-javascript">igo-javascript</a>でも同じことができるはず・・・！
これはならブラウザ上ですべてが完結する！</p>

<p>はい、そういうことで作ってみました。</p>

<ul>
<li><a href="http://shogo82148.github.com/IgoIME/">IgoIME</a></li>
</ul>


<p>使い方は本家と一緒です。Alt-o (Ctrl-9)でモード切替。
ローマ字で日本語を入力することができます。</p>

<p>日本語入力をするためには変換候補をいくつか出力する必要がありますが、
本来Igoにはその機能はありません。
そのため、複数候補を出す部分だけ独自実装してあります。
しかし、まだなんか変換候補が怪しいですね・・・。
長い文章を入力したのに一文字しか結果が帰ってこないことがあります。
なんでだろう・・・・</p>

<p>まだまだ改良が必要なようです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascriptでの関数宣言]]></title>
    <link href="http://shogo82148.github.io/blog/2012/03/23/javascript-function/"/>
    <updated>2012-03-23T18:22:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2012/03/23/javascript-function</id>
    <content type="html"><![CDATA[<h2>Chrome17対応版AjaxIME</h2>

<p>Ajaxを使ってIMEを実現した<a href="http://ajaxime.chasen.org/">AjaxIME</a>がFireFoxでは動くのに最新版のChromeで動かない。
動くように少しいじってみた。</p>

<ul>
<li><a href="http://shogo82148.github.com/AjaxIME/">Chrome17対応版AjaxIME</a></li>
</ul>


<!-- more -->


<h2>原因</h2>

<p>Chromeで動かなかった原因はここ。</p>

<p>``` javascript
if(typeof getComputedStyle == 'undefined') {</p>

<pre><code>function getComputedStyle() {
    //中身は省略
}
</code></pre>

<p>}
```</p>

<p>FireFoxやChromeには getComputedStyle という関数が定義されているけど、
IEには定義されていない。
if文で有無を判定して、無い場合は動作をエミュレートする関数を定義している。</p>

<p>実行の様子をデバッガで追って見ると、Chromeではエミュレートする必要が無いのになぜか自前で定義した関数が呼び出されていた。
どうやら、Chromeでは 自作 getComputedStyle 関数が if文の中にあったとしてもコード読み込み時に作成されてしまうみたい。
FireFox だと if文の中が実行されない場合には作成されない。</p>

<p>結果だけ書くと、次のように書きなおしたら動いた。</p>

<p>``` javascript
if(typeof getComputedStyle == 'undefined') {</p>

<pre><code>getComputedStyle = function() {
    //中身は省略
}
</code></pre>

<p>}
```</p>

<p>あと Chrome だと、Input要素にフォーカスがあたった時に余計な装飾がついてしまうので、CSS上書きして抑制。
IE8でTextRangeが使えない問題は「<a href="http://d.hatena.ne.jp/kanehama/20100330/1269946922">IE8でのTextRange.moveToPoint()</a>」を参考にして解決。
IE7のエミュレートモードにしているだけで、根本的な解決にはなってないけど、まあIEだしいいでしょ。</p>

<h2>どっちが正しいの？</h2>

<p>とりあえず問題は解決したんだけど、FireFoxとChromeで動作が違うけど、どちらの動作が正しいの？
気になったので調べてみた。</p>

<p>「<a href="http://alpha.mixi.co.jp/blog/?p=4958">mixi Engineers' Blog >> 詳細 ECMA-262-3 第5章 関数</a>」に関数の定義法についてわかりやすい解説が載っていた。
結論からいうと、一番初めの書き方は「誤り」で実際の動作は実装依存、つまり FireFox の動作も Chrome の動作も正しいとのこと。</p>

<h2>関数定義と関数式</h2>

<p>関数の定義法は大きく分けて、次のような関数定義と関数式に分かれている。
関数式は更に名前なしと名前付きがある。</p>

<p>```javascript
//関数定義
function foo() {
}</p>

<p>//名前なしの関数式
var foo = function() {
};</p>

<p>//名前付きの関数式
var foo = function _foo() {
};
```</p>

<p>普通の関数定義と無名関数があるのは知っててけど、単なるシュガーシンタックスみたいなものかと思った。
mixiのブログによると全くの別物。
関数定義と関数式の大きな違いは、実行時に呼び出し可能になっているかどうか。
関数定義は実行時に呼び出し可能になっているから、定義と呼び出しの順番は関係ない。</p>

<p><code>javascript
foo(); //OK
function foo() {
}
foo(); //OK
</code></p>

<p>関数式は実行されるまで呼び出し可能にはならないから、定義より前で呼び出すことはできない。</p>

<p><code>javascript
foo(); //ERROR!
foo = function() {
};
foo(); //OK
</code></p>

<p>関数定義は実行の前に評価する必要があるからif文の中に入れちゃダメ。
他にも関数名が使える範囲に違いがあるみたいだけど、詳しいことはmixiのブログ参照。</p>

<h2>まとめ</h2>

<p>関数定義と関数式の違いは重要なので覚えておこう！</p>

<p>ところで、なぜAjaxIMEをいじっているかというと・・・ふふふ・・・</p>
]]></content>
  </entry>
  
</feed>
