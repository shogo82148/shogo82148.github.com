<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl golang | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/perl-golang/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2015-09-28T07:38:44+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PerlからGolangを呼び出す]]></title>
    <link href="http://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter/"/>
    <updated>2015-08-30T22:52:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter</id>
    <content type="html"><![CDATA[<p>GoのコードをPerlから呼び出せるようにする<a href="https://github.com/shogo82148/go2xs">go2xs</a>を書いてみました。</p>

<!-- More -->


<h2>使い方</h2>

<p>Perlから使いたい関数に以下のようにgo2xsで始まるコメントを付けておきます。</p>

<p>``` go hoge
package main</p>

<p>//go2xs hello
func hello(str string) string {
  return "Hello " + str
}
```</p>

<p><a href="https://github.com/shogo82148/go2xs">go2xs</a>をgo getして、xsのグルーコードを作成。
その後通常のPerlモジュールと同じ手順でコンパイルします。
Go 1.5から入ったShared Libraryの機能を使っているのでGo 1.5が必要です。</p>

<p><code>bash
go get https://github.com/shogo82148/go2xs/cli/go2xs
go2xs -name hoge hoge.go
perl Makefile.PL
make
</code></p>

<p>あとは普通に呼び出すだけ。</p>

<p><code>
perl -Mblib -Mhoge -e 'print hoge::hello("World")'
Hello World
</code></p>

<h2>制限事項</h2>

<p>今はまだ、整数・浮動小数点型・文字列しか扱えません。</p>

<p>あとGoのShared Libraryを複数回読み込むことができないっぽい？ (ref. https://github.com/golang/go/issues/11100 )
ので、go2xsを使ったコードを二つ以上useすると死にます。</p>

<h2>FFI::Rawを使う方法</h2>

<p>go2xsはGoをShared Libraryとしてコンパイルしているだけなので、go2xsを使わなくても頑張れば呼び出すことができます。
<a href="http://qiita.com/yanolab/items/1e0dd7fd27f19f697285">Golang で Shared Library を出力する。</a>で紹介されているこちらのコードで試してみます。</p>

<p>``` go libgofib.go
package main</p>

<p>import (
  "C"
  "log"
)</p>

<p>//export fib
func fib(n int) int {
  if (n &lt; 2) { return n }
  return fib(n - 2) + fib(n - 1)
}</p>

<p>func init() {
  log.Println("Loaded!!")
}</p>

<p>func main() {
}
```</p>

<p>ビルドしてShared Libraryを作ってみます。</p>

<p><code>bash
build -buildmode=c-shared -o libgofib.so libgofib.go
</code></p>

<p>PerlからShared Libraryを呼び出すには<a href="https://metacpan.org/pod/FFI::Raw">FFI::Raw</a>を使うのがお手軽のようです。</p>

<p>``` perl test.pl
use FFI::Raw;</p>

<p>my $fib = FFI::Raw->new(</p>

<pre><code>'libfib.so', 'fib',
FFI::Raw::int, # 戻り値
FFI::Raw::int, # 引数
</code></pre>

<p>);</p>

<p>print $format->call(32);
```</p>

<h2>文字列の受け渡しをしてみる</h2>

<p>FFI::Rawを使った方法はお手軽ですが、文字列の受け渡しをしようとすると色々と面倒です。</p>

<h3>素朴に実装してみる</h3>

<p>Golangの<code>string</code>はPerlでそのまま扱えないので、<code>C.GoString</code>と<code>C.CString</code>を使い一度C言語の文字列形式を経由してから相互変換する必要があります。</p>

<p>``` go libgofmt.go
import "C"</p>

<p>import (
  f "go/format"
)</p>

<p>//export format
func format(src <em>C.char) </em>C.char {
  gosrc := C.GoString(src)
  dst, _ := f.Source([]byte(gosrc))
  return C.CString(string(dst))
}</p>

<p>func main() {
}
```</p>

<p>``` perl test.pl
use FFI::Raw;</p>

<p>my $format = FFI::Raw->new(</p>

<pre><code>'libgofmt.so', 'format',
FFI::Raw::str, # 戻り値
FFI::Raw::str,  # 引数1
</code></pre>

<p>);</p>

<p>print $format->call(&lt;&lt;"EOF");
package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
```</p>

<p>なんとなく動いてよさ気な感じがしますが、
実はこのコード、メモリーリークしてます。
<code>C.CString</code>で作ったC言語の文字列はGolangの管理から外れるのでGCで回収されません。
そのため、どこかで<code>free</code>を実行して開放する必要があります。</p>

<h3>strcpyで頑張る</h3>

<p>Golang側でバッファを確保するとPerlに戻った時にバッファ開放ができないので、
Perl側で結果を格納するバッファを確保してみます。</p>

<p>``` go libgofmt.go
package main</p>

<p>/*</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>*/
import "C"</p>

<p>import (
  f "go/format"
  "unsafe"
)</p>

<p>//export format
func format(dst <em>C.char, src </em>C.char) {
  gosrc := C.GoString(src)
  godst, _ := f.Source([]byte(gosrc))
  cs := C.CString(string(godst))
  defer C.free(unsafe.Pointer(cs))
  C.strcpy(dst, cs)
}</p>

<p>func main() {
}
```</p>

<p>``` perl test.pl
use FFI::Raw;</p>

<p>my $format = FFI::Raw->new(
  'libgofmt.so', 'format',
  FFI::Raw::void, # 戻り値
  FFI::Raw::str,
  FFI::Raw::ptr,
);</p>

<p>while(1) {
  my $hoge;
  my $coderef = sub { $hoge = shift };
  my $callback = FFI::Raw::callback($coderef, FFI::Raw::void, FFI::Raw::str);
  $format->call(&lt;&lt;"EOF", $callback);
package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
}
```</p>

<p>この方式なら作ったShared Libraryを他の言語からも呼びやすいので無難かも？
ただし、まだまだ実装が不十分で、このコードはバッファオーバーランの危険があります。
しっかり実装するなら、最初の一回でバッファのサイズだけ計算、次の呼び出しで結果取得・・・のようなフローを踏む必要があります。</p>

<h3>コールバック</h3>

<p>結果の保存をコールバック関数の呼び出しで行えば、Golang側でfreeを実行するタイミングが分かるので、メモリーリークを防ぐことができます。
ただし、Goからは関数ポインタを呼び出すことはできないので、gcoでグルーコードを書いてあげる必要があります。</p>

<p>``` go libgofmt.go
package main</p>

<p>/*</p>

<h1>include &lt;stdlib.h></h1>

<p>typedef void (<em>callbackFunc) (const char</em>);</p>

<p>void bridge_callback(callbackFunc f, const char<em> str);
</em>/
import "C"</p>

<p>import (
  f "go/format"
  "unsafe"
  )</p>

<p>//export format
func format(src *C.char, dstCallback unsafe.Pointer) {
  gosrc := C.GoString(src)
  godst, _ := f.Source([]byte(gosrc))
  cs := C.CString(string(godst))
  defer C.free(unsafe.Pointer(cs))
  C.bridge_callback(C.callbackFunc(dstCallback), cs)
}</p>

<p>func main() {
}
```</p>

<p>``` c libgofmt.c
typedef void (<em>callbackFunc) (const char</em>);</p>

<p>void bridge_callback(callbackFunc f, const char* str) {</p>

<pre><code>f(str);
</code></pre>

<p>}
```</p>

<p>``` perl test.pl
use FFI::Raw;</p>

<p>my $format = FFI::Raw->new(</p>

<pre><code>'libgofmt.so', 'format',
FFI::Raw::void, # 戻り値
FFI::Raw::str, FFI::Raw::ptr,
</code></pre>

<p>);</p>

<p>while(1) {</p>

<pre><code>my $hoge;
my $coderef = sub { $hoge = shift };
my $callback = FFI::Raw::callback($coderef, FFI::Raw::void, FFI::Raw::str);
$format-&gt;call(&lt;&lt;"EOF", $callback);
</code></pre>

<p>package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
}
```</p>

<h2>まとめ</h2>

<p>GoのShared Libraryの呼び出しは数値型だけを相手にしていれば比較的簡単ですが、文字列を扱おうとすると少し面倒です。
go2xsを使うとそこら辺が簡単になります。
あんましライブラリ作ったことないですが、文字列の受け渡しをするときには、一般的にはどんな感じのインターフェースにするべきなんですかね？</p>

<p>GoのShared Libraryまだまだ出たばかりで、複数回読み込めなかったりと問題はありますが、
Goの機能を他の言語から呼び出せるのは便利ですね。
今後に期待です。</p>
]]></content>
  </entry>
  
</feed>
