<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl golang | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/perl-golang/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2016-11-24T18:41:51+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PerlからGolangを呼び出す]]></title>
    <link href="https://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter/"/>
    <updated>2015-08-30T22:52:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/08/30/golang-to-perl-xs-converter</id>
    <content type="html"><![CDATA[<p>GoのコードをPerlから呼び出せるようにする<a href="https://github.com/shogo82148/go2xs">go2xs</a>を書いてみました。</p>

<!-- More -->


<h2>使い方</h2>

<p>Perlから使いたい関数に以下のようにgo2xsで始まるコメントを付けておきます。</p>

<pre><code class="go hoge">package main

//go2xs hello
func hello(str string) string {
  return "Hello " + str
}
</code></pre>

<p><a href="https://github.com/shogo82148/go2xs">go2xs</a>をgo getして、xsのグルーコードを作成。
その後通常のPerlモジュールと同じ手順でコンパイルします。
Go 1.5から入ったShared Libraryの機能を使っているのでGo 1.5が必要です。</p>

<pre><code class="bash">go get https://github.com/shogo82148/go2xs/cli/go2xs
go2xs -name hoge hoge.go
perl Makefile.PL
make
</code></pre>

<p>あとは普通に呼び出すだけ。</p>

<pre><code>perl -Mblib -Mhoge -e 'print hoge::hello("World")'
Hello World
</code></pre>

<h2>制限事項</h2>

<p>今はまだ、整数・浮動小数点型・文字列しか扱えません。</p>

<p>あとGoのShared Libraryを複数回読み込むことができないっぽい？ (ref. <a href="https://github.com/golang/go/issues/11100">https://github.com/golang/go/issues/11100</a> )
ので、go2xsを使ったコードを二つ以上useすると死にます。</p>

<h2>FFI::Rawを使う方法</h2>

<p>go2xsはGoをShared Libraryとしてコンパイルしているだけなので、go2xsを使わなくても頑張れば呼び出すことができます。
<a href="http://qiita.com/yanolab/items/1e0dd7fd27f19f697285">Golang で Shared Library を出力する。</a>で紹介されているこちらのコードで試してみます。</p>

<pre><code class="go libgofib.go">package main

import (
  "C"
  "log"
)

//export fib
func fib(n int) int {
  if (n &lt; 2) { return n }
  return fib(n - 2) + fib(n - 1)
}

func init() {
  log.Println("Loaded!!")
}

func main() {
}
</code></pre>

<p>ビルドしてShared Libraryを作ってみます。</p>

<pre><code class="bash">build -buildmode=c-shared -o libgofib.so libgofib.go
</code></pre>

<p>PerlからShared Libraryを呼び出すには<a href="https://metacpan.org/pod/FFI::Raw">FFI::Raw</a>を使うのがお手軽のようです。</p>

<pre><code class="perl test.pl">use FFI::Raw;

my $fib = FFI::Raw-&gt;new(
    'libfib.so', 'fib',
    FFI::Raw::int, # 戻り値
    FFI::Raw::int, # 引数
);

print $format-&gt;call(32);
</code></pre>

<h2>文字列の受け渡しをしてみる</h2>

<p>FFI::Rawを使った方法はお手軽ですが、文字列の受け渡しをしようとすると色々と面倒です。</p>

<h3>素朴に実装してみる</h3>

<p>Golangの<code>string</code>はPerlでそのまま扱えないので、<code>C.GoString</code>と<code>C.CString</code>を使い一度C言語の文字列形式を経由してから相互変換する必要があります。</p>

<pre><code class="go libgofmt.go">import "C"

import (
  f "go/format"
)

//export format
func format(src *C.char) *C.char {
  gosrc := C.GoString(src)
  dst, _ := f.Source([]byte(gosrc))
  return C.CString(string(dst))
}

func main() {
}
</code></pre>

<pre><code class="perl test.pl">use FFI::Raw;

my $format = FFI::Raw-&gt;new(
    'libgofmt.so', 'format',
    FFI::Raw::str, # 戻り値
    FFI::Raw::str,  # 引数1
);

print $format-&gt;call(&lt;&lt;"EOF");
package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
</code></pre>

<p>なんとなく動いてよさ気な感じがしますが、
実はこのコード、メモリーリークしてます。
<code>C.CString</code>で作ったC言語の文字列はGolangの管理から外れるのでGCで回収されません。
そのため、どこかで<code>free</code>を実行して開放する必要があります。</p>

<h3>strcpyで頑張る</h3>

<p>Golang側でバッファを確保するとPerlに戻った時にバッファ開放ができないので、
Perl側で結果を格納するバッファを確保してみます。</p>

<pre><code class="go libgofmt.go">package main

/*
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
*/
import "C"

import (
  f "go/format"
  "unsafe"
)

//export format
func format(dst *C.char, src *C.char) {
  gosrc := C.GoString(src)
  godst, _ := f.Source([]byte(gosrc))
  cs := C.CString(string(godst))
  defer C.free(unsafe.Pointer(cs))
  C.strcpy(dst, cs)
}

func main() {
}
</code></pre>

<pre><code class="perl test.pl">use FFI::Raw;

my $format = FFI::Raw-&gt;new(
  'libgofmt.so', 'format',
  FFI::Raw::void, # 戻り値
  FFI::Raw::str,
  FFI::Raw::ptr,
);

while(1) {
  my $hoge;
  my $coderef = sub { $hoge = shift };
  my $callback = FFI::Raw::callback($coderef, FFI::Raw::void, FFI::Raw::str);
  $format-&gt;call(&lt;&lt;"EOF", $callback);
package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
}
</code></pre>

<p>この方式なら作ったShared Libraryを他の言語からも呼びやすいので無難かも？
ただし、まだまだ実装が不十分で、このコードはバッファオーバーランの危険があります。
しっかり実装するなら、最初の一回でバッファのサイズだけ計算、次の呼び出しで結果取得・・・のようなフローを踏む必要があります。</p>

<h3>コールバック</h3>

<p>結果の保存をコールバック関数の呼び出しで行えば、Golang側でfreeを実行するタイミングが分かるので、メモリーリークを防ぐことができます。
ただし、Goからは関数ポインタを呼び出すことはできないので、gcoでグルーコードを書いてあげる必要があります。</p>

<pre><code class="go libgofmt.go">package main

/*
#include &lt;stdlib.h&gt;
typedef void (*callbackFunc) (const char*);

void bridge_callback(callbackFunc f, const char* str);
*/
import "C"

import (
  f "go/format"
  "unsafe"
  )

//export format
func format(src *C.char, dstCallback unsafe.Pointer) {
  gosrc := C.GoString(src)
  godst, _ := f.Source([]byte(gosrc))
  cs := C.CString(string(godst))
  defer C.free(unsafe.Pointer(cs))
  C.bridge_callback(C.callbackFunc(dstCallback), cs)
}

func main() {
}
</code></pre>

<pre><code class="c libgofmt.c">typedef void (*callbackFunc) (const char*);

void bridge_callback(callbackFunc f, const char* str) {
    f(str);
}
</code></pre>

<pre><code class="perl test.pl">use FFI::Raw;

my $format = FFI::Raw-&gt;new(
    'libgofmt.so', 'format',
    FFI::Raw::void, # 戻り値
    FFI::Raw::str, FFI::Raw::ptr,
);

while(1) {
    my $hoge;
    my $coderef = sub { $hoge = shift };
    my $callback = FFI::Raw::callback($coderef, FFI::Raw::void, FFI::Raw::str);
    $format-&gt;call(&lt;&lt;"EOF", $callback);
package main
import   "fmt"
func main(   )   {
fmt.Println("hogehoge") }
EOF
}
</code></pre>

<h2>まとめ</h2>

<p>GoのShared Libraryの呼び出しは数値型だけを相手にしていれば比較的簡単ですが、文字列を扱おうとすると少し面倒です。
go2xsを使うとそこら辺が簡単になります。
あんましライブラリ作ったことないですが、文字列の受け渡しをするときには、一般的にはどんな感じのインターフェースにするべきなんですかね？</p>

<p>GoのShared Libraryまだまだ出たばかりで、複数回読み込めなかったりと問題はありますが、
Goの機能を他の言語から呼び出せるのは便利ですね。
今後に期待です。</p>
]]></content>
  </entry>
  
</feed>
