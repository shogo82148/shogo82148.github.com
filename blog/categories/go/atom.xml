<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2015-09-28T23:14:30+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AnySan::Provider::Slackとape-slackを書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack/"/>
    <updated>2015-09-28T22:11:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack</id>
    <content type="html"><![CDATA[<p>先週、今のプロジェクトでのメインのコミュニケーションツールをIRCからSlack切り替えました。
それにともないIRCに済んでいたボットたちもお引越しする必要があったので、
ボットとSlackをつなぐためのライブラリを書きました。</p>

<ul>
<li><a href="https://metacpan.org/release/AnySan-Provider-Slack">AnySan::Provider::Slack</a></li>
<li><a href="https://github.com/shogo82148/ape-slack">ape-slack</a></li>
</ul>


<p>Perlとgoのボットが住んでいるのでそれぞれの言語で実装してあります。</p>

<!-- More -->


<h2>AnySan::Provider::Slack</h2>

<p>Perlの<a href="https://metacpan.org/pod/AnySan">AnySan</a>用のモジュールです。</p>

<p>``` perl
use AnySan;
use AnySan::Provider::Slack;
my $slack = slack</p>

<pre><code>token =&gt; 'YOUR SLACK API TOKEN',
channels =&gt; {
    'general' =&gt; {},
};
</code></pre>

<p>$slack->send_message('slack message', channel => 'C024BE91L');
AnySan->run;
```</p>

<p>AnySanを使うだけでも便利なんですが、
今のプロジェクトではAnySanを対話形式で使いやすくするように<a href="http://www.songmu.jp/riji/entry/2013-09-09-unazusan.html">UnazuSan</a>を使っています。
UnazuSanはIRC前提で書かれていて、AnySan::Provider::Slackをインストールしてもそのままは使えません。</p>

<p>UnazuSanを置き換えるもの面倒なので、イベントの名前を書き換えて投げ直すことで、
SlackのメッセージをIRCに見せかける方法をとっています。
また<a href="https://beatsync.net/main/log20150926.html">SlackのOutgoing Webhookで@つきのmentionを捕まえる</a>にもあるように、
Slackのメンションは &lt;@U08DGJVJ7&gt;のような形式になってしまい、UnazuSanは自分へのメッセージとして扱ってくれません。
これをUnazuSanが解釈できる形式に置き換えるのがポイントです。</p>

<p>``` perl
use 5.010;
use warnings;
use utf8;
use Encode qw/encode_utf8/;
use UnazuSan;
use AnySan;
use AnySan::Provider::Slack;</p>

<p>my $unazu_san = UnazuSan->new(</p>

<pre><code>host       =&gt; 'example.com',
password   =&gt; 'xxxxxxxxxxx',
enable_ssl =&gt; 1,
join_channels =&gt; [qw/arcade/],
respond_all   =&gt; 1,
</code></pre>

<p>);</p>

<p>my $slack = slack(</p>

<pre><code>token    =&gt; 'YOUR SLACK TOKEN',
channels =&gt; {},
as_user =&gt; 1,
</code></pre>

<p>);</p>

<p>AnySan->register_listener(</p>

<pre><code>slack =&gt; {
    event =&gt; 'message',
    cb =&gt; sub {
        my $receive = shift;
        # fake irc privmsg
        $receive-&gt;{event} = 'privmsg';
        $receive-&gt;{message} =~ s/&lt;\@xxxxx&gt;:/unazusan:/;
        AnySan-&gt;broadcast_message($receive);
    },
}
</code></pre>

<p>);</p>

<p>$unazu_san->on_command(</p>

<pre><code>help =&gt; sub {
    my ($receive, @args) = @_;
    $receive-&gt;reply('help '. ($args[0] || ''));
}
</code></pre>

<p>);</p>

<p>$unazu_san->run;
```</p>

<h2>ape-slack</h2>

<p><a href="https://github.com/m0t0k1ch1/ape">ape</a>のSlack対応版です。
SlackRTM APIを使ってイベントを受け取ります。</p>

<p>GoはWebSocketも比較的カンタンに使えるので、実はape-slackを使わなくても以下のようなコードだけでSlackRTM APIを使えてしまいます。</p>

<p>``` go
import (
  "encoding/json"
  "fmt"
  "net/http"
  "net/url"</p>

<p>  "golang.org/x/net/websocket"
)</p>

<p>func main() {
  resp, _ := http.PostForm("https://slack.com/api/rtm.start", url.Values{"token": {"YOUR SLACK TOKEN"}})
  var r struct {</p>

<pre><code>Url   string `json:"url"`
</code></pre>

<p>  }</p>

<p>  json.NewDecoder(resp.Body).Decode(&amp;r)</p>

<p>  ws := websocket.Dial(r.Url, "", "https://slack.com/")</p>

<p>  for {</p>

<pre><code>var data map[string]interface{}
websocket.JSON.Receive(ws, &amp;data)
fmt.Println(data)
</code></pre>

<p>  }
}
```</p>

<p>Outgoing Webhookを使うとSlackから呼んでもらえるようセキュリティの設定が必要で面倒ですが、
WebSocketならインターネッツに繋がった環境なら大抵そのままつながります。
Outgoing WebhookならチャンネルにJOINしていなくてもイベントを受け取れたりして便利ですが、
ちょっとしたボットならこちらの方がお手軽ですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go言語でPerlのテストを早くする]]></title>
    <link href="http://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang/"/>
    <updated>2015-09-19T21:49:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2015/06/20/test-mysqld-multi/">Test::mysqld::Multiというモジュールを書いてみた</a>みたいな涙ぐましい努力により5分で終わるようになったテストですが、
プロジェクトのコードも増えて人も増えた影響で、
テスト時間が約7分まで伸び、テストのキューに10個近く並んで順番待ちさせられるという状況になってしまいした。</p>

<p>この状況を解決すべく <a href="https://github.com/shogo82148/go-prove">go-prove</a> というものを書いてみたので、そのご紹介です。</p>

<h2>proveが遅い理由</h2>

<p>proveがテストの結果を読むところがブロッキングI/Oになっているらしく、そのせいで遅くなっているらしいです。</p>

<ul>
<li><a href="https://github.com/Perl-Toolchain-Gang/Test-Harness/issues/30">Perl-Toolchain-Gang/Test-Harness#30</a></li>
</ul>


<p>実際に<a href="https://github.com/Perl-Toolchain-Gang/Test-Harness/blob/a278e504794c649c61f2c362841eec1a9735a3d0/lib/TAP/Parser/Iterator/Process.pm#L245">結果読んでいるところ</a>はこの辺ですかね。
selectとか使っていてなるべくブロッキングしないような作りにはなっていそうですが、どこかでブロッキングしてしまっているようです。
今のプロジェクトだと32コアのCPUで32並列で動かしてもCPUを100%使い切ることができませんでした。</p>

<h2>Shunme</h2>

<p>ググるとShunmeというプロジェクトでproveの問題を解決しようという試みが行われているようです。</p>

<ul>
<li><a href="http://code-stylistics.net/archives/shunme.html">Shunmeというperl用のテストハーネスモジュールを書き始めました</a></li>
<li><a href="https://github.com/magnolia-k/p5-Shunme">magnolia-k/p5-Shunme</a></li>
</ul>


<p>しかし残念ながらproveのプラグイン機構はサポートしておらず、Formatterの指定オプションもないようです。
今のプロジェクトではプラグインでMySQLを立てたり、JUnitでテスト結果をフォーマットしたりということをしているので、そのままは使えなさそう。
ちょっと改造するにはソースコードの理解が大変そうなので断念。
「(逆に遅くなるときも有ります)」というところも気になりますね・・・。</p>

<h2>go-prove</h2>

<p>いろいろテストの実行方法を調べてはみましたが、どの方法も並行処理に苦労している模様。
テストファイル自体はただのPerlのスクリプトなので、実行して集計する部分は別にPerlにこだわる必要ないのでは？
並行処理といえば今ならGolangでしょ！ってことでproveのGo実装を書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-prove">go-prove</a></li>
</ul>


<p>例えば以下のようなテストをかいて、</p>

<p>``` perl t/macopy.t
use Test::More;</p>

<p>ok "macopy";</p>

<p>done_testing;
```</p>

<p>go-proveコマンドと実行すると、JUnit形式でテスト結果が出力されます。</p>

<p>```
$ go-prove
2015/09/19 21:45:44 start t/macopy.t
2015/09/19 21:45:44 finish t/macopy.t
<testsuites></p>

<pre><code>    &lt;testsuite tests="1" failures="0" time="0.225" name="t_macopy_t"&gt;
            &lt;properties&gt;&lt;/properties&gt;
            &lt;testcase classname="t_macopy_t" name="" time="0.225"&gt;&lt;/testcase&gt;
    &lt;/testsuite&gt;
</code></pre>

<p></testsuites>
```</p>

<p><code>go-prove -j 32</code>とするとgoroutineを32個生成して、32並列でテストを実行してくれます。
I/Oの処理をGolangのランタイムがよしなにやってくれるので、楽ちんです。</p>

<p>また、今のプロジェクトではApp::Prove::Plugin::MySQLPoolを使っているので、それ相当の機能を<code>go-prove -plugin mysqld</code>で使えるようにしました。
プラグインを有効にするとMySQLサーバを立ち上げて、その接続先情報を<code>GO_PROVE_MYSQLD</code>環境変数に設定してくれます。</p>

<p>実際にプロジェクトのコードで試してみたところ7分かかっていたテストが4分を切るようになりました。
CPUの使用率も100%近くになって、有効活用できているようです。</p>

<h2>まとめ</h2>

<ul>
<li>Perl製のproveは並列実行に弱い</li>
<li>Goで書きなおしてCPUをフル活用できるようになった</li>
</ul>


<p>早くはなるものの、既存のテストコードに手を加える必要があってちょっと怖いかなと思ったので、プロジェクトへの組み込みはやってません。
まあ本番環境で走るものではないので、ある程度動くことが確認できたら置き換えてみたいですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[go-webtailってのを書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2015/06/21/go-webtail/"/>
    <updated>2015-06-21T23:28:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/06/21/go-webtail</id>
    <content type="html"><![CDATA[<p>Rubyで書かれた<a href="https://github.com/r7kamura/webtail">webtail</a>のGo移植を書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-webtail">go-webtail</a></li>
</ul>


<!-- More -->


<p>オリジナルのwebtailはRubyなので、Rubyistではない僕が使おうとするとまずRubyの実行環境からそろえないといけなくてつらい。
ワンバイナリでダウンロードするだけで使えるやつが欲しいなあと常々思っていたのでGolangです。
htmlやjavasctiptの部分もバイナリに含まれているので、インストールも簡単です。</p>

<p>引数無しで実行すると8080ポートで待ち受けて、標準入力から読み込んだ結果をWebsocketで読めるようにしてくれます。</p>

<p><code>bash
go get github.com/shogo82148/go-webtail/cmd/webtail # インストール
echo hogehoge | webtail
</code></p>

<p>ファイルもtailできます。</p>

<p><code>bash
webtail hoge.log fuga.log
</code></p>

<p>それぞれ、<code>http://localhost:8080/hoge.log</code>と<code>http://localhost:8080/fuga.log</code>で見れるようになります。</p>

<h1>mirageと一緒につかう</h1>

<p><a href="https://github.com/acidlemon/mirage">mirage</a>は待ち受けポートを複数設定できます。
(SEE ALSO <a href="http://tech.kayac.com/archive/mirage_for_docker.html">Dockerで非エンジニアでも開発環境を上げ下げできる、mirageというツールを作りました</a>)
その一つをwebtailに割り当てて以下のようにDockerfileに書いておけば、非(サーバサイド)エンジニアでも開発環境のログが見れるようになります。
(見れても理解できるのか？って疑問もあるけど、まあ、全く見れないよりは・・・)</p>

<p>```
ADD webtail /
CMD ./docker_run.sh 2>&amp;1 | /webtail --prefix webtail</p>

<h1>ブラウザで見れる代わりにdocker logsで見れなくなるのでこっちのほうがいいかも</h1>

<p>CMD ./docker_run.sh 2>&amp;1 | tee hoge.log | /webtail --prefix webtail
```</p>

<p>残念ながらwebsocket対応はしていないので、<a href="https://github.com/shogo82148/mirage/tree/feature/websocket">websoket対応にしたmirage</a>が必要です。
<code>httputil.NewSingleHostReverseProxy</code>互換の<a href="github.com/methane/rproxy">rproxy</a>ってのを使ったら簡単にwebsocket対応ができて素晴らしいですね。
(mirage自身に手を加える必要があるなら、mirageにこういう機能をつけるべきだったのでは説はある)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[map[string]Hoge or map[string]*Hoge ?]]></title>
    <link href="http://shogo82148.github.io/blog/2015/02/22/should-i-use-a-pointer-in-go/"/>
    <updated>2015-02-22T02:14:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/02/22/should-i-use-a-pointer-in-go</id>
    <content type="html"><![CDATA[<p>Go言語でポインタを使うべきか使わないべきか問題。
「ケース・バイ・ケースなので、状況に応じて使い分けましょう！」という結論が出るのは目に見えているので、
具体例について検証してみた結果を書いておきます。</p>

<!-- More -->


<h2>背景</h2>

<p>他の人のコードレビューを見ていたら、
レビュアーが「コピーをしないで済むのでstructの受け渡しにはポインタ使ったほうがいいと思います！」とコメントしていて、
そうなのか？と思ったのですがあんまり自信がなかったので検証してみました。
コメントがついていたのは以下のようなコード。</p>

<p>``` go
package hoge</p>

<p>import (</p>

<pre><code>"strconv"
</code></pre>

<p>)</p>

<p>type Hoge struct {</p>

<pre><code>A int
B int
C int
</code></pre>

<p>}</p>

<p>func NewHogeMapStruct() map[string]Hoge {</p>

<pre><code>m := make(map[string]Hoge)
for i := 0; i &lt; 10000; i++ {
    m[strconv.Itoa(i)] = Hoge{i, i, i}
}
return m
</code></pre>

<p>}
```</p>

<p>ポイントは以下の点です。</p>

<ul>
<li>受け渡すstructはintが3つ程度の小さなもの</li>
<li>mapに入れて返す</li>
</ul>


<h2>benchmarkを使って検証する</h2>

<p>ポインタを使わない版と使う版を両方作ってベンチマークをとってみます。</p>

<p>``` go
package hoge</p>

<p>import (</p>

<pre><code>"strconv"
</code></pre>

<p>)</p>

<p>type Hoge struct {</p>

<pre><code>A int
B int
C int
</code></pre>

<p>}</p>

<p>// ポインタ使わない版
func NewHogeMapStruct() map[string]Hoge {</p>

<pre><code>m := make(map[string]Hoge)
for i := 0; i &lt; 10000; i++ {
    m[strconv.Itoa(i)] = Hoge{i, i, i}
}
return m
</code></pre>

<p>}</p>

<p>// ポインタ使う版
func NewHogeMapPointer() map[string]*Hoge {</p>

<pre><code>m := make(map[string]*Hoge)
for i := 0; i &lt; 10000; i++ {
    m[strconv.Itoa(i)] = &amp;Hoge{i, i, i}
}
return m
</code></pre>

<p>}
```</p>

<p>ベンチマークはこれらの関数をただ呼び出すだけのシンプルなもの。</p>

<p>``` go
package hoge</p>

<p>import (</p>

<pre><code>"strconv"
"testing"
</code></pre>

<p>)</p>

<p>func BenchmarkStruct(b *testing.B) {</p>

<pre><code>for i := 0; i &lt; b.N; i++ {
    NewHogeMapStruct()
}
</code></pre>

<p>}</p>

<p>func BenchmarkPointer(b *testing.B) {</p>

<pre><code>for i := 0; i &lt; b.N; i++ {
    NewHogeMapPointer()
}
</code></pre>

<p>}
```</p>

<p><code>go test -benchmem -bench .</code> すると以下のような結果が得られました。</p>

<p><code>plain
PASS
BenchmarkStruct      500       3238732 ns/op     1662087 B/op      10615 allocs/op
BenchmarkPointer     500       3485712 ns/op     1372074 B/op      20593 allocs/op
ok      github.com/shogo82148/pointer-test  4.067s
</code></p>

<p>ポインタを使わないほうが若干速いですね。
メモリのアロケーション回数はポインタ使う版の半分です。</p>

<p>ポインタ使わない版は速度・メモリアロケーション回数は減ったものの、
必要なバイト数は増えています。
おそらく、これから値が入る予定のメモリ領域を予め確保しており、
その分のメモリを多めに食っているのでしょう。
ポインタ使う版では構造体の中身を入れる分は必要になったときにnewするので、
使用するメモリは最小限で済みます。</p>

<h2>アセンブリを見てみてみる</h2>

<p>go tool を使うとアセンブリが見れるらしい。
<code>go tool 6g -S hoge.go</code> を実行してアセンブリも眺めてみます。</p>

<p><code>plain
--- prog list "NewHogeMapStruct" ---
0000 (hoge.go:13) TEXT    NewHogeMapStruct+0(SB),$72-8
0001 (hoge.go:13) FUNCDATA $0,gcargs·0+0(SB)
0002 (hoge.go:13) FUNCDATA $1,gclocals·0+0(SB)
0003 (hoge.go:13) TYPE    ~anon0+0(FP){map[string]"".Hoge},$8
0004 (hoge.go:13) TYPE    m+-8(SP){map[string]"".Hoge},$8
0005 (hoge.go:13) TYPE    i+-16(SP){int},$8
0006 (hoge.go:14) MOVQ    $type.map[string]"".Hoge+0(SB),(SP)
0007 (hoge.go:14) MOVQ    $0,8(SP)
0008 (hoge.go:14) PCDATA  $0,$24
0009 (hoge.go:14) CALL    ,runtime.makemap+0(SB)
0010 (hoge.go:14) PCDATA  $0,$-1
0011 (hoge.go:14) MOVQ    16(SP),BX
0012 (hoge.go:14) MOVQ    BX,m+-8(SP)
0013 (hoge.go:15) MOVQ    $0,AX
0014 (hoge.go:15) JMP     ,16
0015 (hoge.go:15) INCQ    ,AX
0016 (hoge.go:15) CMPQ    AX,$10000
0017 (hoge.go:15) JGE     $0,40
0018 (hoge.go:16) MOVQ    AX,i+-16(SP)
0019 (hoge.go:16) MOVQ    AX,(SP)
0020 (hoge.go:16) CALL    ,strconv.Itoa+0(SB)
0021 (hoge.go:16) MOVQ    i+-16(SP),DX
0022 (hoge.go:16) MOVQ    8(SP),SI
0023 (hoge.go:16) MOVQ    16(SP),BP
0024 (hoge.go:16) MOVQ    statictmp_0002+0(SB),BX
0025 (hoge.go:16) MOVQ    statictmp_0002+8(SB),BX
0026 (hoge.go:16) MOVQ    statictmp_0002+16(SB),BX
0027 (hoge.go:16) MOVQ    $type.map[string]"".Hoge+0(SB),(SP)
0028 (hoge.go:16) MOVQ    m+-8(SP),BX
0029 (hoge.go:16) MOVQ    BX,8(SP)
0030 (hoge.go:16) MOVQ    SI,16(SP)
0031 (hoge.go:16) MOVQ    BP,24(SP)
0032 (hoge.go:16) MOVQ    DX,32(SP)
0033 (hoge.go:16) MOVQ    DX,40(SP)
0034 (hoge.go:16) MOVQ    DX,48(SP)
0035 (hoge.go:16) PCDATA  $0,$56
0036 (hoge.go:16) CALL    ,runtime.mapassign1+0(SB)
0037 (hoge.go:16) MOVQ    i+-16(SP),AX
0038 (hoge.go:16) PCDATA  $0,$-1
0039 (hoge.go:15) JMP     ,15
0040 (hoge.go:18) MOVQ    m+-8(SP),BX
0041 (hoge.go:18) MOVQ    BX,~anon0+0(FP)
0042 (hoge.go:18) RET     ,
</code></p>

<p><code>plain
--- prog list "NewHogeMapPointer" ---
0043 (hoge.go:21) TEXT    NewHogeMapPointer+0(SB),$72-8
0044 (hoge.go:21) FUNCDATA $0,gcargs·1+0(SB)
0045 (hoge.go:21) FUNCDATA $1,gclocals·1+0(SB)
0046 (hoge.go:21) TYPE    ~anon0+0(FP){map[string]*"".Hoge},$8
0047 (hoge.go:21) TYPE    m+-24(SP){map[string]*"".Hoge},$8
0048 (hoge.go:21) TYPE    i+-32(SP){int},$8
0049 (hoge.go:21) TYPE    autotmp_0003+-16(SP){string},$16
0050 (hoge.go:22) MOVQ    $type.map[string]*"".Hoge+0(SB),(SP)
0051 (hoge.go:22) MOVQ    $0,8(SP)
0052 (hoge.go:22) PCDATA  $0,$24
0053 (hoge.go:22) CALL    ,runtime.makemap+0(SB)
0054 (hoge.go:22) PCDATA  $0,$-1
0055 (hoge.go:22) MOVQ    16(SP),BX
0056 (hoge.go:22) MOVQ    BX,m+-24(SP)
0057 (hoge.go:23) MOVQ    $0,AX
0058 (hoge.go:23) JMP     ,60
0059 (hoge.go:23) INCQ    ,AX
0060 (hoge.go:23) CMPQ    AX,$10000
0061 (hoge.go:23) JGE     $0,94
0062 (hoge.go:24) MOVQ    AX,i+-32(SP)
0063 (hoge.go:24) MOVQ    AX,(SP)
0064 (hoge.go:24) CALL    ,strconv.Itoa+0(SB)
0065 (hoge.go:24) MOVQ    8(SP),BX
0066 (hoge.go:24) MOVQ    BX,autotmp_0003+-16(SP)
0067 (hoge.go:24) MOVQ    16(SP),BX
0068 (hoge.go:24) MOVQ    BX,autotmp_0003+-8(SP)
0069 (hoge.go:24) MOVQ    $type."".Hoge+0(SB),(SP)
0070 (hoge.go:24) PCDATA  $0,$16
0071 (hoge.go:24) CALL    ,runtime.new+0(SB)
0072 (hoge.go:24) MOVQ    i+-32(SP),CX
0073 (hoge.go:24) PCDATA  $0,$-1
0074 (hoge.go:24) MOVQ    8(SP),AX
0075 (hoge.go:24) NOP     ,
0076 (hoge.go:24) MOVQ    CX,(AX)
0077 (hoge.go:24) NOP     ,
0078 (hoge.go:24) MOVQ    CX,8(AX)
0079 (hoge.go:24) NOP     ,
0080 (hoge.go:24) MOVQ    CX,16(AX)
0081 (hoge.go:24) MOVQ    $type.map[string]*"".Hoge+0(SB),(SP)
0082 (hoge.go:24) MOVQ    m+-24(SP),BX
0083 (hoge.go:24) MOVQ    BX,8(SP)
0084 (hoge.go:24) MOVQ    autotmp_0003+-16(SP),BX
0085 (hoge.go:24) MOVQ    BX,16(SP)
0086 (hoge.go:24) MOVQ    autotmp_0003+-8(SP),BX
0087 (hoge.go:24) MOVQ    BX,24(SP)
0088 (hoge.go:24) MOVQ    AX,32(SP)
0089 (hoge.go:24) PCDATA  $0,$40
0090 (hoge.go:24) CALL    ,runtime.mapassign1+0(SB)
0091 (hoge.go:24) MOVQ    i+-32(SP),AX
0092 (hoge.go:24) PCDATA  $0,$-1
0093 (hoge.go:23) JMP     ,59
0094 (hoge.go:26) MOVQ    m+-24(SP),BX
0095 (hoge.go:26) MOVQ    BX,~anon0+0(FP)
0096 (hoge.go:26) RET     ,
</code></p>

<p>メモリアロケーションが起きているのはおそらく <code>runtime.new</code> と <code>strconv.Itoa</code> を呼び出している部分でしょう。
ポインタ使う版では両方とも呼び出していますが、ポインタ使わない版では<code>strconv.Itoa</code>の呼び出しだけです。
ポインタ使う版ではmapのkeyとvalueのメモリ領域をそれぞれ確保が必要なのに対して、
ポインタ使わない版ではvalueのためのメモリ領域を<code>new(map[string]Hoge)</code>の時点で一括確保するので、
メモリアロケーションが少なくて済むということですね。</p>

<h2>結論</h2>

<p>今回の場合構造体のサイズが小さいく、コピーのコスト&lt;アロケーションのコストであったため、
速度的にはポインタを使わない方が有利でした。
しかし、<code>map</code>は値の入っていない要素分を予め確保するので、
メモリ使用量的にはポインタを使う方が有利でした。
結局は速度とメモリ使用量のトレードオフということです。</p>

<p>実際のコードでは、キーの個数は60個程度で呼び出される頻度もそんなに多くなく、
速度もメモリも十分に足りるので、正直どっちでも良かった気がします。
ポインタを使わないほうがタイプ数がちょっと減ってコード書くときに少し嬉しいくらいですかね。</p>

<h2>結論の結論</h2>

<p>ケース・バイ・ケースなので、状況に応じて使い分けましょう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Androidのバイナリファイルを解析するgoのライブラリ]]></title>
    <link href="http://shogo82148.github.io/blog/2014/05/07/androidbinary/"/>
    <updated>2014-05-07T13:29:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/05/07/androidbinary</id>
    <content type="html"><![CDATA[<p>Androidのアプリの実態はzipファイルなのでunzipすれば簡単に中身を見ることができるわけですが、
開いてもバイナリファイルが入っているだけでよくわかりません。
AndroidSDKに付属しているaaptというツールを使えば読めるんだけどインストールが大変で苦しんでいる人がいたので、
お手軽に解析できるgolangのライブラリを書いてみました。</p>

<!-- More -->


<h2>使い方</h2>

<h3>go getしてくる</h3>

<p><a href="https://github.com/shogo82148/androidbinary">githubのレポジトリ</a> からダウンロードしてきます。</p>

<p><code>bash
go get github.com/shogo82148/androidbinary
</code></p>

<h3>AndroidManifest.xmlを解析する</h3>

<p><code>io.ReaderAt</code>インターフェースを満たすオブジェクトを<code>androidbinary.NewXMLFile</code>に渡すと解析してくれます。</p>

<p><code>go
f, _ := os.Open("AndroidManifest.xml")
xmlFile, _ := androidbinary.NewXMLFile(f)
reader := xmlFile.Reader()
// reader を読むと普通のXMLファイルとして読める
</code></p>

<h3>resources.arscを解析する</h3>

<p>アプリ名などの設定はAndroidManifest.xmlには直接書かれておらず、
リソースファイルに書いてあることがほとんどです(開発者がよほどものぐさでなければ)。
リソースの情報はapk内のresources.arscに書かれているので、
このファイルを読む機能もついてます。</p>

<p>``` go
f, _ := os.Open("resources.arsc")
tableFile, _ := androidbinary.NewTableFile(f)</p>

<p>// ID 0x7F040000 に対応するリソースを読む
config := &amp;androidbinary.ResTableConfig{}
val, _ := tableFile.GetResource(androidbinary.ResId(0x7f040000), config)
```</p>

<p>アプリ名はロケールによって変わったりするので、
<code>config</code>で設定できます。
例えば日本語の名前を取得したい場合はこんな感じ。</p>

<p><code>go
// ID 0x7F040000 に対応するリソース(日本語)を読む
config := &amp;androidbinary.ResTableConfig{}
config.Language[0] = 'j'
config.Language[1] = 'a'
val, _ := tableFile.GetResource(androidbinary.ResId(0x7f040000), config)
</code></p>

<h3>サンプルコード</h3>

<p>apkを解析してアプリの日本語名を取得する例。</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>"archive/zip"
"bytes"
"encoding/xml"
"fmt"
"github.com/shogo82148/androidbinary"
"io/ioutil"
"strconv"
</code></pre>

<p>)</p>

<p>type XMLManifest struct {</p>

<pre><code>XMLName      xml.Name          `xml:"manifest"`
Applications []*XMLApplication `xml:"application"`
</code></pre>

<p>}</p>

<p>type XMLApplication struct {</p>

<pre><code>XMLName xml.Name `xml:"application"`
Label   string   `xml:"http://schemas.android.com/apk/res/android label,attr"`
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>r, _ := zip.OpenReader("sample.apk")
defer r.Close()

// read manifest and resource
var xmlFile *androidbinary.XMLFile
var tableFile *androidbinary.TableFile
for _, f := range r.File {
    switch f.Name {
    case "AndroidManifest.xml":
        rc, _ := f.Open()
        buf, _ := ioutil.ReadAll(rc)
        xmlFile, _ = androidbinary.NewXMLFile(bytes.NewReader(buf))
        rc.Close()
    case "resources.arsc":
        rc, _ := f.Open()
        buf, _ := ioutil.ReadAll(rc)
        tableFile, _ = androidbinary.NewTableFile(bytes.NewReader(buf))
        rc.Close()
    }
}

// parse xml
decoder := xml.NewDecoder(xmlFile.Reader())
xmlManifest := &amp;XMLManifest{}
decoder.Decode(xmlManifest)

// get application label
labelId, _ := strconv.ParseInt(xmlManifest.Applications[0].Label[3:], 16, 32)
config := &amp;androidbinary.ResTableConfig{}
config.Language[0] = 'j'
config.Language[1] = 'a'
label, _ := tableFile.GetResource(androidbinary.ResId(labelId), config)
fmt.Println("Application Name:", label)
</code></pre>

<p>}
```</p>

<p>エラー処理とか完全に省いているので上手く補ってください。</p>

<h2>制限事項</h2>

<p>GW中頑張ったけど途中で力尽きたので、今のところ以下のような制限があります。</p>

<ul>
<li>リソース名を扱えない

<ul>
<li>普通AndroidManifest.xmlにリソースを埋め込むときは<code>@string/app_name</code>みたいな名前を埋め込みますが、リソースファイルとの連携機能がないため<code>@0x7F04000000</code>のような数値を返します</li>
<li>resources.arsc からリソース名を読み取ったり、リソース名からリソースを取得する機能はありません</li>
</ul>
</li>
<li>configの設定が一部しか対応していない

<ul>
<li>ロケール、画面サイズ、SDKバージョン等にしか対応してません</li>
<li>IMEの設定や画面の細かいオプションとかも指定はできるけど、<code>GetResource</code>が解釈してくれないので誤った結果を返すかも</li>
</ul>
</li>
<li>リソースタイプ

<ul>
<li>文字列、整数、ブーリアン値にしか対応してません</li>
<li>string-array とかいうのとかあったりするけど、そんなの知らない</li>
</ul>
</li>
</ul>


<p>いろいろ制限はありますが、アプリ名を読み取ったり、パーミッションを解析するくらいはできるんじゃないですかね。
golang初心者なのでイケてないところがあったら教えて下さい。</p>

<h2>参考</h2>

<ul>
<li><a href="http://dsas.blog.klab.org/archives/52011424.html">エンコードされた AndroidManifest.xml を読む</a></li>
<li><a href="https://gist.github.com/cielavenir/4365521">ruby_apk Android::Resource can relate string pool (partially)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
