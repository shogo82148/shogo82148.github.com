<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2016-03-15T14:17:31+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ngrokみたいなHTTPプロキシを書いてみた]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/14/http2-over-websocket/"/>
    <updated>2016-03-14T22:59:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/14/http2-over-websocket</id>
    <content type="html"><![CDATA[<p>開発中のWebアプリをみんなに試してほしいけど、
サーバなんてなくて開発環境がローカルにしか無くて公開できないということは、
開発初期段階だとよくあることだと思います。
もちろん本格的にやるならテスト用にサーバを建てるべきですが、
小さなものなら<a href="https://ngrok.com/">ngrok</a>を使うと簡単です。
<a href="https://ngrok.com/">ngrok</a>の公開サーバへのHTTPリクエストをローカルにリレーして、
ローカルのサーバをお手がるに公開できるサービスです。</p>

<p>びっくりするほど簡単に公開できて便利ですが、
一応oAuthで制限とかかけたいなーとかカスタマイズしてみたくなってきたので、
似たようなものを自作できないかといろいろ遊んでみました。</p>

<p>その結果、HTTP2 over Websocketみたいな謎なものが出来上がってしまったというお話です。</p>

<!-- More -->


<h2>HTTP2 over Websocketというアイデア</h2>

<p><a href="https://ngrok.com/">ngrok</a>っぽいものを実現するためには、
サーバが受け取ったHTTPリクエストをローカルの環境に転送する必要があります。
ご存知のとおり通常のHTTPではサーバ側からのプッシュ配信が難しいので、Websocketを使うのが良さそうです。
しかし、複数のコネクションで並列にやってくるHTTPリクエストを、一本のWebsocketに束ねる必要があり、
上手く制御するのは大変そうです。</p>

<p>さて、HTTP2は一つのTCPコネクションで複数のリクエストを並行処理する仕様があります。
「複数のリクエストを一本に束ねる」という点ではなんか似ているので、なんだか流用できそうな気がしてきました。
Golangならきっと上手いこと<code>interface</code>を実装すれば、なんとかできるのではとやってみました。</p>

<h2>実装</h2>

<p>HTTP2は暗号化や複雑なフロー制御を行っていますが、
外から見れば<code>net.Conn</code>インターフェースに読み書きしている何かに過ぎません。
そして、<code>websocket.Conn</code>も<code>net.Conn</code>を実装しているので、そのままHTTP2のライブラリに渡せるはずです。</p>

<p>そうしてできたのが以下のサーバです。</p>

<p>``` go server.go
package main</p>

<p>import (</p>

<pre><code>"errors"
"log"
"net/http"
"net/http/httputil"
"sync"

"golang.org/x/net/http2"
"golang.org/x/net/websocket"
</code></pre>

<p>)</p>

<p>type transport struct {</p>

<pre><code>m      sync.Mutex
t      http.RoundTripper
closed chan struct{}
</code></pre>

<p>}</p>

<p>var t *transport</p>

<p>func main() {</p>

<pre><code>t = &amp;transport{}
s := websocket.Server{Handler: websocket.Handler(Handler)}
http.Handle("/", s)
go http.ListenAndServe(":3000", nil)
http.ListenAndServe(":3001", &amp;httputil.ReverseProxy{
    Transport: t,
    Director: func(req *http.Request) {
    },
})
</code></pre>

<p>}</p>

<p>func Handler(ws *websocket.Conn) {</p>

<pre><code>log.Println("start new connection")
t2 := &amp;http2.Transport{}
conn, err := t2.NewClientConn(ws)
if err != nil {
    log.Println(err)
    return
}

t.m.Lock()
if t.t != nil {
    t.m.Unlock()
    log.Println("already connected.")
    return
}
t.t = conn
t.m.Unlock()
&lt;-t.closed
log.Println("close connection")
</code></pre>

<p>}</p>

<p>func (t <em>transport) RoundTrip(req </em>http.Request) (*http.Response, error) {</p>

<pre><code>t.m.Lock()
t2 := t.t
t.m.Unlock()
if t2 == nil {
    return nil, errors.New("connection not found")
}
res, err := t2.RoundTrip(req)
if err != nil {
    log.Println(err)
    t.m.Lock()
    t.t = nil
    t.m.Unlock()
    t.closed &lt;- struct{}{}
    return nil, err
}
return res, nil
</code></pre>

<p>}
```</p>

<p>複数Websocketのコネクションが張られた場合の処理が少し煩雑ですが、思いのほか短くかけました。
3001番ポートに来たリクエストをWebsocket経由で転送します。
Websocketは3000番ポートで待ち受けです。</p>

<p>これにアクセスするためのクライアントがこちら。</p>

<p>``` go client.go
package main</p>

<p>import (</p>

<pre><code>"log"
"net/http/httputil"
"net/url"

"golang.org/x/net/http2"
"golang.org/x/net/websocket"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>origin := "http://localhost:3000/"
u := "ws://localhost:3000/"
ws, err := websocket.Dial(u, "", origin)
if err != nil {
    log.Fatal(err)
}

target, _ := url.Parse("http://localhost:8000/")

s := &amp;http2.Server{}
s.ServeConn(ws, &amp;http2.ServeConnOpts{
    Handler: httputil.NewSingleHostReverseProxy(target),
})
</code></pre>

<p>}
```</p>

<p>Websocket経由でリクエストを受け付け、それを8000番ポートに転送します。
こちらも非常に短くかけました。
サーバーとクライアントを立ち上げて<code>http://localhost:3001/</code>にアクセスすると、
<code>http://localhost:8000/</code>の内容が見れるはずです。</p>

<h2>ngrok1.xについて</h2>

<p>ところでngrokの旧バージョンはソースコードが公開されているから、こっちを使ったほうが早い？
でも、開発中止って書かれてて不安になる。</p>

<ul>
<li><a href="https://github.com/inconshreveable/ngrok">ngrok1.x</a></li>
</ul>


<h2>まとめ</h2>

<p>ローカルのサーバをお手軽に公開するためのngrokというサービスを紹介しました。
自作のためのアイデアとして、http2 over websocketを試してみました。</p>

<p>設定の読み込みとかエラー処理とかセキュリティ周りとかいろいろ足りてない部分はありますが、
たったあれだけのコードで、ヘッダの圧縮転送、リクエストの並行処理等のHTTP2の機能が使えるのは面白いですね。</p>

<p>もうちょっと手を加えて多少は使えるものにしてみたいですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx-omniauth-adapterのGolangポート作った]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter/"/>
    <updated>2016-03-10T12:51:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter</id>
    <content type="html"><![CDATA[<p>「<a href="http://techlife.cookpad.com/entry/2015/10/16/080000">nginx で omniauth を利用してアクセス制御を行う</a>」という記事で、
<a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>の存在を知ったので、
Golangで<a href="https://github.com/sorah/nginx_omniauth_adapter">nginx_omniauth_adapter</a>と似たようなものを作ってみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-nginx-oauth2-adapter">shogo82148/go-nginx-oauth2-adapter</a></li>
</ul>


<!-- More -->


<h2>背景</h2>

<p><a href="https://github.com/typester/gate">typester/gate</a>は単体でも動くようになっていますが、
例えばIP制限などちょっと高度なことをしたい場合には結局nginxを前段に置く必要があります。
nginxとgateの設定を同時にいじる必要があって煩雑だと感じていました。</p>

<p>そんな中「<a href="http://techlife.cookpad.com/entry/2015/10/16/080000">nginx で omniauth を利用してアクセス制御を行う</a>」という記事で、
<a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>の存在を知りました。
gateが認証＋Proxyをやってしまうのに対して、認証だけRubyのomniauthモジュールで行いProxyはnginxに任せるという方法です。</p>

<p>以前から記事の存在は知っていたのですが、Rubyの実行環境をそろえるのが億劫で手を出せずにいました。
小さなアプリなので自分の慣れた言語で実装しても大したことないのではと思い、Goで実装してみることにしました。</p>

<h2>使い方</h2>

<p><code>go get</code>で落として来れます。
最低限client_idとclient_secretの指定が必要です。
nginx_omniauth_adapterと同じ環境変数名で設定できるほか、YAML形式の設定ファイルを読みこませることができます。
YAMLの形式はREADMEを参照してください。</p>

<p><code>bash
$ go get github.com/shogo82148/go-nginx-oauth2-adapter/cli/go-nginx-oauth2-adapter
$ export NGX_OMNIAUTH_GOOGLE_KEY=YOUR_CLIENT_ID
$ export NGX_OMNIAUTH_GOOGLE_SECRET=YOUR_CLIENT_SECRET
$ go-nginx-oauth2-adapter
$ go-nginx-oauth2-adapter -c conf.yaml # 設定ファイルでの指定も可能
</code></p>

<p>PerlでHTTPサーバ書いているひとにはおなじみのServer::Starterにも対応しているので、
それ経由で立ち上げておくと設定の更新・プログラム自身の更新等が楽になると思います。</p>

<p><code>bash
start_server --port 18081 -- go-nginx-oauth2-adapter -c conf.yaml
</code></p>

<p>nginx側の設定は<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter/blob/master/examples/nginx/nginx-site.conf">examples</a>ディレクトリを参照してください。
ヘッダ名・パス名等を合わせてあるので、nginx_omniauth_adapterと同じ設定で動くはずです。</p>

<p>また、<a href="https://h2o.examp1e.net/">h2o</a>の設定はプログラマブルだからh2oでもちゃんと設定ファイルを書けば動くのではと考え、
<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter/blob/master/examples/h2o/oauth.rb">h2oの設定</a>も書いてみました。
mrubyからproxyに渡るリクエストを書き換える方法がない(？)っぽいので、アプリ側で認証情報をとることはできないですが、一応制限はできます。
basic認証の実装を見る限りremote-userヘッダだけは渡せるようなので、これを使えばなんとかなるかもしれないですが、未確認です。
(Ruby慣れてないからってGoで実装したけど、結局Rubyを書いていて面白い)</p>

<h2>nginx_omniauth_adapterとの違い</h2>

<p>厳密に同じ挙動を実装するのが面倒だったため、挙動に若干の違いがあります。
一番大きなものは認証後のリダイレクト先です。</p>

<p>nginx_omniauth_adapterは認証後、一度adapterのURLにリダイレクトしてから、アプリサーバの<code>/_auth/callback</code>にリダイレクトします。
それに対してgo-nginx-oauth2-adapterは認証後、アプリサーバの<code>/_auth/callback</code>に直接リダイレクトします。
この違いのため、Google Developers Consoleの「承認済みのリダイレクト URI」に設定するべきURIが異なることに注意してください。
nginx_omniauth_adapterはadapter自身のURI、go-nginx-oauth2-adapterはアプリサーバの<code>/_auth/callbak</code>を指定します。</p>

<p>この挙動のため、go-nginx-oauth2-adapterはアプリの追加のたびにnginxの設定に加え「承認済みのリダイレクト URI」に正しいURIを追加する必要があります。
もちろん設定箇所がGoogle Developers Consoleではないだけで、nginx_omniauth_adapterもリダイレクト先の設定は必要です。
GoogleでもFacebookでも認証できるようにしたいという場合、nginx_omniauth_adapterは設定を一箇所変えればOKですが、go-nginx-oauth2-adapterは各サービスに登録し直す必要があります。
現状、認証に使うサービスをユーザが選ぶ仕組みがないので、そのまま放置してあります。</p>

<h2>まとめ</h2>

<p><a href="https://github.com/sorah/nginx_omniauth_adapter">nginx_omniauth_adapter</a>のGolangポート
<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter">shogo82148/go-nginx-oauth2-adapter</a>を紹介しました。</p>

<p>adapter自身の公開設定をしなくて良い分簡単にセットアップできます。
nginx_omniauth_adapter互換ですぐに乗り換えもできるので、ぜひお気軽にお試し下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goでデプロイ神社書いてみた]]></title>
    <link href="http://shogo82148.github.io/blog/2015/12/13/go-deploy-shrine/"/>
    <updated>2015-12-13T10:51:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/12/13/go-deploy-shrine</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/advent-calendar/2015/go2">Go その2 Advent Calendar 2015</a>の13日目の記事です。</p>

<ul>
<li><a href="http://qiita.com/advent-calendar/2015/go">その1</a></li>
<li><a href="http://qiita.com/advent-calendar/2015/go2">その2</a></li>
<li><a href="http://qiita.com/advent-calendar/2015/go3">その3</a></li>
</ul>


<p>六曜を知ることができる便利コマンドを作ってみたお話です。</p>

<!-- More -->


<h2>Deploy神社とは</h2>

<p><a href="https://twitter.com/Maco_Tasu">Maco_Tasu</a>が作ったいつdeployしたら安全かを教えてくれる便利APIです。
詳しくは作者ブログ記事をどうぞ。(<a href="http://macotasu.hatenablog.jp/entry/2014/11/13/214337">Deploy神社APIを作った- 眠すぎて明日が見えない</a>)</p>

<p>便利APIなのですが、依存している外部APIが利用できなくなってしまったため、Deploy神社自体が利用できなくなっています。</p>

<h2>作ってみた</h2>

<p>デプロイする時間が分からないと不便なので、Go実装を作ってみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-deploy-shrine">shogo82148/go-deploy-shrine</a></li>
</ul>


<p><code>go get</code>してきてお祈りを捧げればデプロイするべき時間を教えてくれます。</p>

<p><code>bash
$ go get github.com/shogo82148/go-deploy-shrine/cli/pray
$ pray
今日は旧暦の11月3日(先勝)です。deployは午前中に済ませましょう。
</code></p>

<p><a href="http://www.weblio.jp/content/%E5%85%88%E5%8B%9D">先勝 - Weblio</a></p>

<blockquote><p>六曜の一。急用や訴訟などによいとされ，早く事を行うのがよく，午前は吉，午後は凶という日。先勝日。せんかち。さきがち。</p></blockquote>

<p>今日12月13日は先勝で午前中にデプロイするのが良いようです。便利ですね。</p>

<h2>六曜とは</h2>

<p>むかしのカレンダーには暦注と呼ばれる「今日の運勢」みたいなものが記載されていたらしいです。
六曜はその暦注のひとつで、現在のカレンダーにも記載されることの多い影響力の大きなものです。</p>

<p>詳しくはWikipediaで。</p>

<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E5%85%AD%E6%9B%9C">六曜 - Wikipedia</a></li>
</ul>


<p>旧暦の(月＋日)を6で割った余りから簡単に求めることができます。</p>

<ul>
<li>0: 大安</li>
<li>1: 赤口</li>
<li>2: 先勝</li>
<li>3: 友引</li>
<li>4: 先負</li>
<li>5: 仏滅</li>
</ul>


<h2>旧暦とは</h2>

<p>旧暦の月日を求めることができれば六曜は簡単に出せるのですが、
日本における旧暦である<a href="https://ja.wikipedia.org/wiki/%E5%A4%A9%E4%BF%9D%E6%9A%A6">天保暦</a>は月の満ち欠けと太陽の動きを元にした暦法であり、
月と太陽の動きを正確に予測する必要があります。</p>

<p>Go版デプロイ神社では「日の出・日の入りの計算―天体の出没時刻の求め方」で紹介されていた計算式を用いています</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4805206349" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>


<h2>2033年旧暦閏月問題</h2>

<p>天保暦をそのまま当てはめると2033年に月を決定できない問題が知られています。
日本カレンダー暦文化振興協会というところが「閏11月を推奨する」との見解を2015年8月に出しています。</p>

<ul>
<li><a href="http://www.rekibunkyo.or.jp/year2033problem.html">2033年旧暦閏月問題の見解</a></li>
</ul>


<p>Go版デプロイ神社では時憲暦方式を採用したつもりです。</p>

<h2>せめてGoっぽい話題を</h2>

<p>引数に日付を渡すとその日の六曜をかえしてくれます。
いろんな形式に対応していて、以下はすべて2006年1月2日の六曜を返します。</p>

<p><code>bash
$ pray 20060102
$ pray 1/2/2006
$ pray 2-Jan-06
$ pray 2-Jan-2006
$ pray 2/Jan/2006
$ pray 'Jan 2 2006'
2006-01-02は旧暦の12月3日(友引)です。昼のdeployはさけましょう。するなら朝晩が吉です。
</code></p>

<p>引数の解析には <a href="https://github.com/tkuchiki/parsetime">tkuchiki/parsetime</a>を使っています。
たいていの日時フォーマットなら解析してくれる便利ライブラリです。</p>

<h2>最後に</h2>

<p>暦法とか天文学とかよくわかってない人間が作ったプログラムなので、結果の保証はできません。
今月の旧暦は<a href="http://keisan.casio.jp/exec/system/1186108192">六曜計算 - 高精度計算サイト</a>の計算結果と一致することは確認していますが、
他の日でも正しい結果を返すかどうかは未検証です。</p>

<p>Go版デプロイ神社を信じてのデプロイして事故っても、責任は負いかねますのでご了承ください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AnySan::Provider::Slackとape-slackを書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack/"/>
    <updated>2015-09-28T22:11:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/09/28/anysan-provider-slack-and-ape-slack</id>
    <content type="html"><![CDATA[<p>先週、今のプロジェクトでのメインのコミュニケーションツールをIRCからSlack切り替えました。
それにともないIRCに済んでいたボットたちもお引越しする必要があったので、
ボットとSlackをつなぐためのライブラリを書きました。</p>

<ul>
<li><a href="https://metacpan.org/release/AnySan-Provider-Slack">AnySan::Provider::Slack</a></li>
<li><a href="https://github.com/shogo82148/ape-slack">ape-slack</a></li>
</ul>


<p>Perlとgoのボットが住んでいるのでそれぞれの言語で実装してあります。</p>

<!-- More -->


<h2>AnySan::Provider::Slack</h2>

<p>Perlの<a href="https://metacpan.org/pod/AnySan">AnySan</a>用のモジュールです。</p>

<p>``` perl
use AnySan;
use AnySan::Provider::Slack;
my $slack = slack</p>

<pre><code>token =&gt; 'YOUR SLACK API TOKEN',
channels =&gt; {
    'general' =&gt; {},
};
</code></pre>

<p>$slack->send_message('slack message', channel => 'C024BE91L');
AnySan->run;
```</p>

<p>AnySanを使うだけでも便利なんですが、
今のプロジェクトではAnySanを対話形式で使いやすくするように<a href="http://www.songmu.jp/riji/entry/2013-09-09-unazusan.html">UnazuSan</a>を使っています。
UnazuSanはIRC前提で書かれていて、AnySan::Provider::Slackをインストールしてもそのままは使えません。</p>

<p>UnazuSanを置き換えるもの面倒なので、イベントの名前を書き換えて投げ直すことで、
SlackのメッセージをIRCに見せかける方法をとっています。
また<a href="https://beatsync.net/main/log20150926.html">SlackのOutgoing Webhookで@つきのmentionを捕まえる</a>にもあるように、
Slackのメンションは &lt;@U08DGJVJ7&gt;のような形式になってしまい、UnazuSanは自分へのメッセージとして扱ってくれません。
これをUnazuSanが解釈できる形式に置き換えるのがポイントです。</p>

<p>``` perl
use 5.010;
use warnings;
use utf8;
use Encode qw/encode_utf8/;
use UnazuSan;
use AnySan;
use AnySan::Provider::Slack;</p>

<p>my $unazu_san = UnazuSan->new(</p>

<pre><code>host       =&gt; 'example.com',
password   =&gt; 'xxxxxxxxxxx',
enable_ssl =&gt; 1,
join_channels =&gt; [qw/arcade/],
respond_all   =&gt; 1,
</code></pre>

<p>);</p>

<p>my $slack = slack(</p>

<pre><code>token    =&gt; 'YOUR SLACK TOKEN',
channels =&gt; {},
as_user =&gt; 1,
</code></pre>

<p>);</p>

<p>AnySan->register_listener(</p>

<pre><code>slack =&gt; {
    event =&gt; 'message',
    cb =&gt; sub {
        my $receive = shift;
        # fake irc privmsg
        $receive-&gt;{event} = 'privmsg';
        $receive-&gt;{message} =~ s/&lt;\@xxxxx&gt;:/unazusan:/;
        AnySan-&gt;broadcast_message($receive);
    },
}
</code></pre>

<p>);</p>

<p>$unazu_san->on_command(</p>

<pre><code>help =&gt; sub {
    my ($receive, @args) = @_;
    $receive-&gt;reply('help '. ($args[0] || ''));
}
</code></pre>

<p>);</p>

<p>$unazu_san->run;
```</p>

<h2>ape-slack</h2>

<p><a href="https://github.com/m0t0k1ch1/ape">ape</a>のSlack対応版です。
SlackRTM APIを使ってイベントを受け取ります。</p>

<p>GoはWebSocketも比較的カンタンに使えるので、実はape-slackを使わなくても以下のようなコードだけでSlackRTM APIを使えてしまいます。</p>

<p>``` go
import (
  "encoding/json"
  "fmt"
  "net/http"
  "net/url"</p>

<p>  "golang.org/x/net/websocket"
)</p>

<p>func main() {
  resp, _ := http.PostForm("https://slack.com/api/rtm.start", url.Values{"token": {"YOUR SLACK TOKEN"}})
  var r struct {</p>

<pre><code>Url   string `json:"url"`
</code></pre>

<p>  }</p>

<p>  json.NewDecoder(resp.Body).Decode(&amp;r)</p>

<p>  ws := websocket.Dial(r.Url, "", "https://slack.com/")</p>

<p>  for {</p>

<pre><code>var data map[string]interface{}
websocket.JSON.Receive(ws, &amp;data)
fmt.Println(data)
</code></pre>

<p>  }
}
```</p>

<p>Outgoing Webhookを使うとSlackから呼んでもらえるようセキュリティの設定が必要で面倒ですが、
WebSocketならインターネッツに繋がった環境なら大抵そのままつながります。
Outgoing WebhookならチャンネルにJOINしていなくてもイベントを受け取れたりして便利ですが、
ちょっとしたボットならこちらの方がお手軽ですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go言語でPerlのテストを早くする]]></title>
    <link href="http://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang/"/>
    <updated>2015-09-19T21:49:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2015/06/20/test-mysqld-multi/">Test::mysqld::Multiというモジュールを書いてみた</a>みたいな涙ぐましい努力により5分で終わるようになったテストですが、
プロジェクトのコードも増えて人も増えた影響で、
テスト時間が約7分まで伸び、テストのキューに10個近く並んで順番待ちさせられるという状況になってしまいした。</p>

<p>この状況を解決すべく <a href="https://github.com/shogo82148/go-prove">go-prove</a> というものを書いてみたので、そのご紹介です。</p>

<h2>proveが遅い理由</h2>

<p>proveがテストの結果を読むところがブロッキングI/Oになっているらしく、そのせいで遅くなっているらしいです。</p>

<ul>
<li><a href="https://github.com/Perl-Toolchain-Gang/Test-Harness/issues/30">Perl-Toolchain-Gang/Test-Harness#30</a></li>
</ul>


<p>実際に<a href="https://github.com/Perl-Toolchain-Gang/Test-Harness/blob/a278e504794c649c61f2c362841eec1a9735a3d0/lib/TAP/Parser/Iterator/Process.pm#L245">結果読んでいるところ</a>はこの辺ですかね。
selectとか使っていてなるべくブロッキングしないような作りにはなっていそうですが、どこかでブロッキングしてしまっているようです。
今のプロジェクトだと32コアのCPUで32並列で動かしてもCPUを100%使い切ることができませんでした。</p>

<h2>Shunme</h2>

<p>ググるとShunmeというプロジェクトでproveの問題を解決しようという試みが行われているようです。</p>

<ul>
<li><a href="http://code-stylistics.net/archives/shunme.html">Shunmeというperl用のテストハーネスモジュールを書き始めました</a></li>
<li><a href="https://github.com/magnolia-k/p5-Shunme">magnolia-k/p5-Shunme</a></li>
</ul>


<p>しかし残念ながらproveのプラグイン機構はサポートしておらず、Formatterの指定オプションもないようです。
今のプロジェクトではプラグインでMySQLを立てたり、JUnitでテスト結果をフォーマットしたりということをしているので、そのままは使えなさそう。
ちょっと改造するにはソースコードの理解が大変そうなので断念。
「(逆に遅くなるときも有ります)」というところも気になりますね・・・。</p>

<h2>go-prove</h2>

<p>いろいろテストの実行方法を調べてはみましたが、どの方法も並行処理に苦労している模様。
テストファイル自体はただのPerlのスクリプトなので、実行して集計する部分は別にPerlにこだわる必要ないのでは？
並行処理といえば今ならGolangでしょ！ってことでproveのGo実装を書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-prove">go-prove</a></li>
</ul>


<p>例えば以下のようなテストをかいて、</p>

<p>``` perl t/macopy.t
use Test::More;</p>

<p>ok "macopy";</p>

<p>done_testing;
```</p>

<p>go-proveコマンドと実行すると、JUnit形式でテスト結果が出力されます。</p>

<p>```
$ go-prove
2015/09/19 21:45:44 start t/macopy.t
2015/09/19 21:45:44 finish t/macopy.t
<testsuites></p>

<pre><code>    &lt;testsuite tests="1" failures="0" time="0.225" name="t_macopy_t"&gt;
            &lt;properties&gt;&lt;/properties&gt;
            &lt;testcase classname="t_macopy_t" name="" time="0.225"&gt;&lt;/testcase&gt;
    &lt;/testsuite&gt;
</code></pre>

<p></testsuites>
```</p>

<p><code>go-prove -j 32</code>とするとgoroutineを32個生成して、32並列でテストを実行してくれます。
I/Oの処理をGolangのランタイムがよしなにやってくれるので、楽ちんです。</p>

<p>また、今のプロジェクトではApp::Prove::Plugin::MySQLPoolを使っているので、それ相当の機能を<code>go-prove -plugin mysqld</code>で使えるようにしました。
プラグインを有効にするとMySQLサーバを立ち上げて、その接続先情報を<code>GO_PROVE_MYSQLD</code>環境変数に設定してくれます。</p>

<p>実際にプロジェクトのコードで試してみたところ7分かかっていたテストが4分を切るようになりました。
CPUの使用率も100%近くになって、有効活用できているようです。</p>

<h2>まとめ</h2>

<ul>
<li>Perl製のproveは並列実行に弱い</li>
<li>Goで書きなおしてCPUをフル活用できるようになった</li>
</ul>


<p>早くはなるものの、既存のテストコードに手を加える必要があってちょっと怖いかなと思ったので、プロジェクトへの組み込みはやってません。
まあ本番環境で走るものではないので、ある程度動くことが確認できたら置き換えてみたいですね。</p>
]]></content>
  </entry>
  
</feed>
