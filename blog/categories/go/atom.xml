<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2016-04-13T04:24:36+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[net/httpで安全に静的ファイルを返す]]></title>
    <link href="http://shogo82148.github.io/blog/2016/04/13/serving-static-files-in-golang/"/>
    <updated>2016-04-13T02:29:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/04/13/serving-static-files-in-golang</id>
    <content type="html"><![CDATA[<p><a href="http://konboi.hatenablog.com/entry/2016/04/12/121105">net/httpで静的ファイルを返す</a>で、
<code>http.ServeFile</code>を使っていてアレ？と思ったのでちょっと詳しく調べてみました。
(<code>http.FileServer</code>を使うものだと思ってたため)</p>

<p>結論だけ先に書いておくと</p>

<ul>
<li>やはり、特に理由がなければ<code>http.FileServer</code>を使ったほうが良さそう</li>
<li>どうしても<code>http.ServeFile</code>を使う場合は定数でパス指定をする</li>
<li>「自作パスルータを使っている」かつ「Go 1.6.1 未満を使っている」場合はとくに要注意</li>
</ul>


<!-- More -->


<h2>ディレクトリトラバーサル脆弱性</h2>

<p>紹介されているのは以下のコードです。</p>

<p><code>go
http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) {
  http.ServeFile(w, r, r.URL.Path[1:])
})
</code></p>

<p>しかし、参照先の「<a href="http://stackoverflow.com/questions/25945538/go-golang-to-serve-a-specific-html-file">Go Golang to serve a specific html file</a>」には
<strong>Actually, do not do that.</strong> (やっちゃいけない)とコメントされています。
<a href="https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%83%88%E3%83%A9%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB">ディレクトリトラバーサル</a>により
脆弱性の原因となってしまう可能性があるためです。</p>

<p>脆弱性再現のために、以下の様なコードを書いてGo1.5でコンパイルして実行してみました。</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>"net/http"
"strings"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>http.ListenAndServe(":3000", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    if strings.HasPrefix(r.URL.Path, "/static/") {
        http.ServeFile(w, r, r.URL.Path[1:])
    } else {
        http.NotFound(w, r)
    }
}))
</code></pre>

<p>}
```</p>

<p><code>..</code>を含んだパスをリクエストしてみます。(実行した場所によって<code>..</code>の数は変わるので適宜調整してみてください)</p>

<p>``` plain
$ curl -v http://localhost:3000/static/../../../.ssh/id_rsa
* About to connect() to localhost port 3000 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 3000 (#0)</p>

<blockquote><p>GET /static/../../../.ssh/id_rsa HTTP/1.1
User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.19.1 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2
Host: localhost:3000
Accept: <em>/</em></p>

<p>&lt; HTTP/1.1 200 OK
&lt; Accept-Ranges: bytes
&lt; Content-Length: 1679
&lt; Content-Type: text/plain; charset=utf-8
&lt; Last-Modified: Fri, 13 Jun 2014 04:57:05 GMT
&lt; Date: Tue, 12 Apr 2016 17:53:19 GMT
&lt;
-----BEGIN RSA PRIVATE KEY-----
(中略)
-----END RSA PRIVATE KEY-----
* Connection #0 to host localhost left intact
* Closing connection #0
```</p></blockquote>

<p>macのcurlで試したらクライアント側で相対パスを解決した状態でリクエストが飛んでしまって上手く行きませんでした。
オプションで外す方法がよくわかなかったので、<code>telnet</code>で叩いてみた例も載せておきます。</p>

<p>``` plain
$ telnet localhost 3000
Trying ::1...
Connected to localhost.
Escape character is '<sup>]'.</sup>
GET /static/../../../.ssh/id_rsa HTTP/1.0</p>

<p>HTTP/1.0 200 OK
Accept-Ranges: bytes
Content-Length: 1679
Content-Type: text/plain; charset=utf-8
Last-Modified: Fri, 13 Jun 2014 04:57:05 GMT
Date: Tue, 12 Apr 2016 18:02:56 GMT</p>

<p>-----BEGIN RSA PRIVATE KEY-----
(中略)
-----END RSA PRIVATE KEY-----
Connection closed by foreign host.
```</p>

<p>ああ、僕の秘密鍵が・・・。</p>

<h2>脆弱性を回避する</h2>

<h3>Go1.6以降を使う</h3>

<p>Go1.6以降では修正されており、
同じコードをGo1.6でコンパイルしてcurlで叩くと400が帰ってきます。</p>

<p>``` plain
$ curl -v http://localhost:3000/static/../../../.ssh/id_rsa
* About to connect() to localhost port 3000 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 3000 (#0)</p>

<blockquote><p>GET /static/../../../.ssh/id_rsa HTTP/1.1
User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.19.1 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2
Host: localhost:3000
Accept: <em>/</em></p>

<p>&lt; HTTP/1.1 400 Bad Request
&lt; Content-Type: text/plain; charset=utf-8
&lt; X-Content-Type-Options: nosniff
&lt; Date: Tue, 12 Apr 2016 18:12:46 GMT
&lt; Content-Length: 17
&lt;
invalid URL path
* Connection #0 to host localhost left intact
* Closing connection #0
```</p></blockquote>

<h3><code>http.ServeMux</code>を使う</h3>

<p><code>http.ServeMux</code>にはパスの正規化機能が組み込まれており、
正規化されていないURLにアクセスが来た場合は自動的リダイレクトしてくれるようです。
HTTPハンドラに渡ってくるときには、必ず相対パスが含まれていない状態になっています。
(これに最初は気が付かず、脆弱性が再現しないので困ってた。)</p>

<p>``` go
package main</p>

<p>import "net/http"</p>

<p>func main() {
  // 内部でhttp.ServeMuxを使ってくれる
  http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) {</p>

<pre><code>// r.URLには相対パスが含まれない形で渡ってくる
http.ServeFile(w, r, r.URL.Path[1:])
</code></pre>

<p>  })
  http.ListenAndServe(":3000", nil)
}
```</p>

<p>相対パスを含んだリクエストを投げてもアクセスはできません。</p>

<p>``` plain
$ curl -v http://localhost:3000/static/../../../.ssh/id_rsa
* About to connect() to localhost port 3000 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 3000 (#0)</p>

<blockquote><p>GET /static/../../../.ssh/id_rsa HTTP/1.1
User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.19.1 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2
Host: localhost:3000
Accept: <em>/</em></p>

<p>&lt; HTTP/1.1 301 Moved Permanently
&lt; Location: /.ssh/id_rsa
&lt; Date: Tue, 12 Apr 2016 18:14:49 GMT
&lt; Content-Length: 47
&lt; Content-Type: text/html; charset=utf-8
&lt;
<a href="http://shogo82148.github.io/.ssh/id_rsa">Moved Permanently</a>.</p></blockquote>

<ul>
<li>Connection #0 to host localhost left intact</li>
<li>Closing connection #0
```</li>
</ul>


<h3><code>http.FileServer</code>を使う</h3>

<p><code>http.Dir</code>と<code>http.FileServer</code>を使うとルートディレクトリを指定でき、
その外へはアクセスできなくなるので想定外のファイルが見えてしまうことはありません。</p>

<p>``` go
package main</p>

<p>import (
  "net/http"
  "strings"
)</p>

<p>func main() {
  fileServer := http.StripPrefix("/static/", http.FileServer(http.Dir("static")))
  http.ListenAndServe(":3000", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {</p>

<pre><code>if strings.HasPrefix(r.URL.Path, "/static/") {
  fileServer.ServeHTTP(w, r)
} else {
  http.NotFound(w, r)
}
</code></pre>

<p>  }))
}
```</p>

<p>相対パスを含んだURLにアクセスしても404になって見れません。</p>

<p>``` plain
$ curl -v http://localhost:3000/static/../../../.ssh/id_rsa
* About to connect() to localhost port 3000 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 3000 (#0)</p>

<blockquote><p>GET /static/../../../.ssh/id_rsa HTTP/1.1
User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.19.1 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2
Host: localhost:3000
Accept: <em>/</em></p>

<p>&lt; HTTP/1.1 404 Not Found
&lt; Content-Type: text/plain; charset=utf-8
&lt; X-Content-Type-Options: nosniff
&lt; Date: Tue, 12 Apr 2016 18:39:34 GMT
&lt; Content-Length: 19
&lt;
404 page not found
* Connection #0 to host localhost left intact
* Closing connection #0
```</p></blockquote>

<h3><code>http.ServeFile</code>に定数を渡す</h3>

<p>どうしても特定のファイルを指定したい場合は、<code>http.ServeFile</code>に渡すファイルパスを定数で指定するべきです。
例えば、「<a href="http://stackoverflow.com/questions/25945538/go-golang-to-serve-a-specific-html-file">Go Golang to serve a specific html file</a>」の質問者が上げている例を
正しく書きなおすと以下のようになると思います。</p>

<blockquote><p><code>http.Handle("/", http.FileServer(http.Dir("static")))</code>
Serves the html file in static directory.</p>

<p>Is there any way in Go that we can specify the html file to serve?</p>

<p>Something like render_template in Flask</p>

<p>I want to do something like:</p>

<p><code>http.Handle("/hello", http.FileServer(http.Dir("static/hello.html")))</code></p></blockquote>

<p>``` go
package main</p>

<p>import "net/http"</p>

<p>func main() {
  http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {</p>

<pre><code>http.ServeFile(w, r, "static/hello.html")
</code></pre>

<p>  })
  http.ListenAndServe(":3000", nil)
}
```</p>

<h2>まとめ</h2>

<p>まとめ再掲。</p>

<ul>
<li>やはり、特に理由がなければ<code>http.FileServer</code>を使ったほうが良さそう</li>
<li>どうしても<code>http.ServeFile</code>を使う場合は定数でパス指定をする</li>
<li>「自作パスルータを使っている」かつ「Go 1.6.1 未満を使っている」場合はとくに要注意</li>
</ul>


<h2>まとめのまとめ</h2>

<p><a href="https://golang.org/pkg/net/http/#example_FileServer">godocのexample</a>どおりにやるのが一番。</p>

<p>``` go
package main</p>

<p>import "net/http"</p>

<p>func main() {
  http.HandleFunc("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static"))))
  http.ListenAndServe(":3000", nil)
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlでもGoでも実行できるQuine書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/"/>
    <updated>2016-04-06T10:07:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/">昨日のPolyglot</a>を元にPerlでもGoでも実行できるQuine書いた。</p>

<!-- More -->


<p><code>
package main;import("fmt");var(q=`printf'package main;import("fmt");var(q%c%c%s%c/*%c);sub import{}sub var{$_%cshift%c~s!%c(.*)%c/\*!$1!gr;eval}%c__END__%c',61,96,$_,96,61,61,61,96,96,10,10;print&lt;DATA&gt;`/*=);sub import{}sub var{$_=shift=~s!`(.*)`/\*!$1!gr;eval}
__END__
*/);func main(){s:=`package main;import("fmt");var(q=%c%s%c/*=);sub import{}sub var{$_=shift=~s!%c(.*)%c/\*!$1!gr;eval}
__END__
*/);func main(){s:=%c%s%c;fmt.Printf(s,96,q,96,96,96,96,s,96)}
`;fmt.Printf(s,96,q,96,96,96,96,s,96)}
</code></p>

<p>Perlで実行してもGoで実行しても自分自身を出力します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数値と文字列がごちゃ混ぜになっているJSONをよしなにParseするやつ作った]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/23/go-weaktyping/"/>
    <updated>2016-03-23T20:44:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/23/go-weaktyping</id>
    <content type="html"><![CDATA[<p>Goは数値と文字列を厳格に区別しますが、他の言語もそうとは限りません。
例えばPerlは数値と文字列を自動変換してくれるので、気をつけていないといつの間にか数値が文字列になっていたりします。
その言語の中に閉じていいれば問題ないのですが、Goとやり取りしようとすると困ります。
そんなときに使えるライブラリを書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-weaktyping">shogo82148/go-weaktyping</a></li>
</ul>


<!-- More -->


<h2>背景</h2>

<p><code>map[string][]*string</code>を返してくるライブラリがあって、
そのままだと扱いにくいのでなんとか構造体にできないかと頭を悩ませていました。
JSONに一旦変換すれば楽かなーとも思ったのですが、一部フィールドを数値に変換する必要がありました。
JSONの数値と文字列を区別するため、JSONの文字列をGoの数値型に変換するのは厄介です。
タグに<code>json:",string"</code>と指定すると変換可能になりますが、逆にJSONの数値を受け付けなくなりますし、
JSONに変換すると文字列になってしまいます。
変換先の構造体は普通のJSONの操作にも使いたかったので、これでは困ります。
「数値も文字列もUnmarshalできて、Marshalするときには数値になる」ようなJSONライブラリが必要でした。</p>

<p><code>"encoding/json"</code>に代わる新しいJSONライブラリを・・・とも考えたのですが、
よく考えるとUnmarshal時の挙動は<code>"encoding/json".Unmarshaler</code>インターフェースを実装することでカスタマイズ可能です。
こうして作ったのが go-weaktyping です。</p>

<h2>使い方</h2>

<p>builtinの型の先頭を大文字にしたものを用意しているので、
適当にUnmarshalして欲しいところでbuiltinの型の代わりに指定するだけです。
以下は整数型をUnmarshalする例です。</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>"encoding/json"
"fmt"
"log"

"github.com/shogo82148/go-weaktyping"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>ptr := &amp;struct {
    Foo weaktyping.Int `json:"foo"`
}{}

if err := json.Unmarshal([]byte(`{"foo":123}`), ptr); err != nil {
    log.Fatal(err)
}
fmt.Println("Foo:", ptr.Foo)

if err := json.Unmarshal([]byte(`{"foo":"456"}`), ptr); err != nil {
    log.Fatal(err)
}
fmt.Println("Foo:", ptr.Foo)
</code></pre>

<p>}
```</p>

<p><code>{"foo":123}</code>が正常にUnmarshalできるのはもちろん、
通常はエラーになってしまう<code>{"foo":"456"}</code>のUnmarshalも問題なく行えます。
Marshal時は通常のint型と同様に振る舞います。</p>

<p>数値型だけでなく<code>weaktyping.String</code>も用意されていて、
通常はエラーになってしまう <code>{"foo":123}</code> も <code>struct { Foo weaktyping.String }{"123"}</code>にUnmarshal可能です。</p>

<p>その他使える型は <a href="https://godoc.org/github.com/shogo82148/go-weaktyping">godoc</a> をどうぞ。</p>

<h2>各種Boolたち</h2>

<p>builtinの<code>bool</code>に対応する<code>weaktyping.Bool</code>も実装してみたのですが、
何を持って真偽を判断するか難しい・・・。
例えば空のARRAYは真とみなすべきか、偽とみなすべきか。
普段触っている言語によって意見が分かれるのではないでしょうか。
(そもそも型が違うからエラーという人もいるだろうけど、そういうときは普通に<code>bool</code>を使いましょう)</p>

<p>JSONはもともとJavaScriptから派生した形式なので、JavaScriptに合わせるのが妥当かなと思い、
<code>weaktyping.Bool</code>の挙動はJavaScriptに合わせてあります。
「<a href="http://blog.mirakui.com/entry/20090604/truefalse">各言語におけるtrue/falseまとめ</a>」を参考に言語別のBoolも用意しています。</p>

<ul>
<li><code>Bool</code>/<code>JavaScriptBool</code>: <code>false</code>, <code>0</code>, <code>0.0</code>, <code>""</code>, <code>null</code> は偽、それ以外は真</li>
<li><code>RubyBool</code>: <code>false</code>, <code>null</code> は偽、それ以外は真</li>
<li><code>PHPBool</code>: <code>false</code>, <code>0</code>, <code>0.0</code>, <code>""</code>, <code>null</code>, <code>"0"</code>, <code>[]</code> は偽、それ以外は真</li>
<li><code>PerlBool</code>: <code>false</code>, <code>0</code>, <code>0.0</code>, <code>""</code>, <code>null</code>, <code>"0"</code> は偽、それ以外は真</li>
<li><code>PythonBool</code>: <code>false</code>, <code>0</code>, <code>0.0</code>, <code>""</code>, <code>null</code>, <code>[]</code>, <code>{}</code> は偽、それ以外は真</li>
</ul>


<p>ややこしい・・・なるべく使わない方がいいと思います。</p>

<h2>最後に</h2>

<p>これを作るきっかけになった問題ですが、reflectで解決しました。reflect最強。
go-weaktypingを使うとすべてのUnmarshal時に有効になってしまって怖いなと考えたためです。</p>

<p>今後もなるべく go-weaktyping を使わずに済むよう祈ってます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ngrokみたいなHTTPプロキシを書いてみた]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/14/http2-over-websocket/"/>
    <updated>2016-03-14T22:59:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/14/http2-over-websocket</id>
    <content type="html"><![CDATA[<p>開発中のWebアプリをみんなに試してほしいけど、
サーバなんてなくて開発環境がローカルにしか無くて公開できないということは、
開発初期段階だとよくあることだと思います。
もちろん本格的にやるならテスト用にサーバを建てるべきですが、
小さなものなら<a href="https://ngrok.com/">ngrok</a>を使うと簡単です。
<a href="https://ngrok.com/">ngrok</a>の公開サーバへのHTTPリクエストをローカルにリレーして、
ローカルのサーバをお手がるに公開できるサービスです。</p>

<p>びっくりするほど簡単に公開できて便利ですが、
一応oAuthで制限とかかけたいなーとかカスタマイズしてみたくなってきたので、
似たようなものを自作できないかといろいろ遊んでみました。</p>

<p>その結果、HTTP2 over Websocketみたいな謎なものが出来上がってしまったというお話です。</p>

<!-- More -->


<h2>HTTP2 over Websocketというアイデア</h2>

<p><a href="https://ngrok.com/">ngrok</a>っぽいものを実現するためには、
サーバが受け取ったHTTPリクエストをローカルの環境に転送する必要があります。
ご存知のとおり通常のHTTPではサーバ側からのプッシュ配信が難しいので、Websocketを使うのが良さそうです。
しかし、複数のコネクションで並列にやってくるHTTPリクエストを、一本のWebsocketに束ねる必要があり、
上手く制御するのは大変そうです。</p>

<p>さて、HTTP2は一つのTCPコネクションで複数のリクエストを並行処理する仕様があります。
「複数のリクエストを一本に束ねる」という点ではなんか似ているので、なんだか流用できそうな気がしてきました。
Golangならきっと上手いこと<code>interface</code>を実装すれば、なんとかできるのではとやってみました。</p>

<h2>実装</h2>

<p>HTTP2は暗号化や複雑なフロー制御を行っていますが、
外から見れば<code>net.Conn</code>インターフェースに読み書きしている何かに過ぎません。
そして、<code>websocket.Conn</code>も<code>net.Conn</code>を実装しているので、そのままHTTP2のライブラリに渡せるはずです。</p>

<p>そうしてできたのが以下のサーバです。</p>

<p>``` go server.go
package main</p>

<p>import (</p>

<pre><code>"errors"
"log"
"net/http"
"net/http/httputil"
"sync"

"golang.org/x/net/http2"
"golang.org/x/net/websocket"
</code></pre>

<p>)</p>

<p>type transport struct {</p>

<pre><code>m      sync.Mutex
t      http.RoundTripper
closed chan struct{}
</code></pre>

<p>}</p>

<p>var t *transport</p>

<p>func main() {</p>

<pre><code>t = &amp;transport{}
s := websocket.Server{Handler: websocket.Handler(Handler)}
http.Handle("/", s)
go http.ListenAndServe(":3000", nil)
http.ListenAndServe(":3001", &amp;httputil.ReverseProxy{
    Transport: t,
    Director: func(req *http.Request) {
    },
})
</code></pre>

<p>}</p>

<p>func Handler(ws *websocket.Conn) {</p>

<pre><code>log.Println("start new connection")
t2 := &amp;http2.Transport{}
conn, err := t2.NewClientConn(ws)
if err != nil {
    log.Println(err)
    return
}

t.m.Lock()
if t.t != nil {
    t.m.Unlock()
    log.Println("already connected.")
    return
}
t.t = conn
t.m.Unlock()
&lt;-t.closed
log.Println("close connection")
</code></pre>

<p>}</p>

<p>func (t <em>transport) RoundTrip(req </em>http.Request) (*http.Response, error) {</p>

<pre><code>t.m.Lock()
t2 := t.t
t.m.Unlock()
if t2 == nil {
    return nil, errors.New("connection not found")
}
res, err := t2.RoundTrip(req)
if err != nil {
    log.Println(err)
    t.m.Lock()
    t.t = nil
    t.m.Unlock()
    t.closed &lt;- struct{}{}
    return nil, err
}
return res, nil
</code></pre>

<p>}
```</p>

<p>複数Websocketのコネクションが張られた場合の処理が少し煩雑ですが、思いのほか短くかけました。
3001番ポートに来たリクエストをWebsocket経由で転送します。
Websocketは3000番ポートで待ち受けです。</p>

<p>これにアクセスするためのクライアントがこちら。</p>

<p>``` go client.go
package main</p>

<p>import (</p>

<pre><code>"log"
"net/http/httputil"
"net/url"

"golang.org/x/net/http2"
"golang.org/x/net/websocket"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>origin := "http://localhost:3000/"
u := "ws://localhost:3000/"
ws, err := websocket.Dial(u, "", origin)
if err != nil {
    log.Fatal(err)
}

target, _ := url.Parse("http://localhost:8000/")

s := &amp;http2.Server{}
s.ServeConn(ws, &amp;http2.ServeConnOpts{
    Handler: httputil.NewSingleHostReverseProxy(target),
})
</code></pre>

<p>}
```</p>

<p>Websocket経由でリクエストを受け付け、それを8000番ポートに転送します。
こちらも非常に短くかけました。
サーバーとクライアントを立ち上げて<code>http://localhost:3001/</code>にアクセスすると、
<code>http://localhost:8000/</code>の内容が見れるはずです。</p>

<h2>ngrok1.xについて</h2>

<p>ところでngrokの旧バージョンはソースコードが公開されているから、こっちを使ったほうが早い？
でも、開発中止って書かれてて不安になる。</p>

<ul>
<li><a href="https://github.com/inconshreveable/ngrok">ngrok1.x</a></li>
</ul>


<h2>まとめ</h2>

<p>ローカルのサーバをお手軽に公開するためのngrokというサービスを紹介しました。
自作のためのアイデアとして、http2 over websocketを試してみました。</p>

<p>設定の読み込みとかエラー処理とかセキュリティ周りとかいろいろ足りてない部分はありますが、
たったあれだけのコードで、ヘッダの圧縮転送、リクエストの並行処理等のHTTP2の機能が使えるのは面白いですね。</p>

<p>もうちょっと手を加えて多少は使えるものにしてみたいですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx-omniauth-adapterのGolangポート作った]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter/"/>
    <updated>2016-03-10T12:51:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/10/go-nginx-oauth2-adapter</id>
    <content type="html"><![CDATA[<p>「<a href="http://techlife.cookpad.com/entry/2015/10/16/080000">nginx で omniauth を利用してアクセス制御を行う</a>」という記事で、
<a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>の存在を知ったので、
Golangで<a href="https://github.com/sorah/nginx_omniauth_adapter">nginx_omniauth_adapter</a>と似たようなものを作ってみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-nginx-oauth2-adapter">shogo82148/go-nginx-oauth2-adapter</a></li>
</ul>


<!-- More -->


<h2>背景</h2>

<p><a href="https://github.com/typester/gate">typester/gate</a>は単体でも動くようになっていますが、
例えばIP制限などちょっと高度なことをしたい場合には結局nginxを前段に置く必要があります。
nginxとgateの設定を同時にいじる必要があって煩雑だと感じていました。</p>

<p>そんな中「<a href="http://techlife.cookpad.com/entry/2015/10/16/080000">nginx で omniauth を利用してアクセス制御を行う</a>」という記事で、
<a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a>の存在を知りました。
gateが認証＋Proxyをやってしまうのに対して、認証だけRubyのomniauthモジュールで行いProxyはnginxに任せるという方法です。</p>

<p>以前から記事の存在は知っていたのですが、Rubyの実行環境をそろえるのが億劫で手を出せずにいました。
小さなアプリなので自分の慣れた言語で実装しても大したことないのではと思い、Goで実装してみることにしました。</p>

<h2>使い方</h2>

<p><code>go get</code>で落として来れます。
最低限client_idとclient_secretの指定が必要です。
nginx_omniauth_adapterと同じ環境変数名で設定できるほか、YAML形式の設定ファイルを読みこませることができます。
YAMLの形式はREADMEを参照してください。</p>

<p><code>bash
$ go get github.com/shogo82148/go-nginx-oauth2-adapter/cli/go-nginx-oauth2-adapter
$ export NGX_OMNIAUTH_GOOGLE_KEY=YOUR_CLIENT_ID
$ export NGX_OMNIAUTH_GOOGLE_SECRET=YOUR_CLIENT_SECRET
$ go-nginx-oauth2-adapter
$ go-nginx-oauth2-adapter -c conf.yaml # 設定ファイルでの指定も可能
</code></p>

<p>PerlでHTTPサーバ書いているひとにはおなじみのServer::Starterにも対応しているので、
それ経由で立ち上げておくと設定の更新・プログラム自身の更新等が楽になると思います。</p>

<p><code>bash
start_server --port 18081 -- go-nginx-oauth2-adapter -c conf.yaml
</code></p>

<p>nginx側の設定は<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter/blob/master/examples/nginx/nginx-site.conf">examples</a>ディレクトリを参照してください。
ヘッダ名・パス名等を合わせてあるので、nginx_omniauth_adapterと同じ設定で動くはずです。</p>

<p>また、<a href="https://h2o.examp1e.net/">h2o</a>の設定はプログラマブルだからh2oでもちゃんと設定ファイルを書けば動くのではと考え、
<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter/blob/master/examples/h2o/oauth.rb">h2oの設定</a>も書いてみました。
mrubyからproxyに渡るリクエストを書き換える方法がない(？)っぽいので、アプリ側で認証情報をとることはできないですが、一応制限はできます。
basic認証の実装を見る限りremote-userヘッダだけは渡せるようなので、これを使えばなんとかなるかもしれないですが、未確認です。
(Ruby慣れてないからってGoで実装したけど、結局Rubyを書いていて面白い)</p>

<h2>nginx_omniauth_adapterとの違い</h2>

<p>厳密に同じ挙動を実装するのが面倒だったため、挙動に若干の違いがあります。
一番大きなものは認証後のリダイレクト先です。</p>

<p>nginx_omniauth_adapterは認証後、一度adapterのURLにリダイレクトしてから、アプリサーバの<code>/_auth/callback</code>にリダイレクトします。
それに対してgo-nginx-oauth2-adapterは認証後、アプリサーバの<code>/_auth/callback</code>に直接リダイレクトします。
この違いのため、Google Developers Consoleの「承認済みのリダイレクト URI」に設定するべきURIが異なることに注意してください。
nginx_omniauth_adapterはadapter自身のURI、go-nginx-oauth2-adapterはアプリサーバの<code>/_auth/callbak</code>を指定します。</p>

<p>この挙動のため、go-nginx-oauth2-adapterはアプリの追加のたびにnginxの設定に加え「承認済みのリダイレクト URI」に正しいURIを追加する必要があります。
もちろん設定箇所がGoogle Developers Consoleではないだけで、nginx_omniauth_adapterもリダイレクト先の設定は必要です。
GoogleでもFacebookでも認証できるようにしたいという場合、nginx_omniauth_adapterは設定を一箇所変えればOKですが、go-nginx-oauth2-adapterは各サービスに登録し直す必要があります。
現状、認証に使うサービスをユーザが選ぶ仕組みがないので、そのまま放置してあります。</p>

<h2>まとめ</h2>

<p><a href="https://github.com/sorah/nginx_omniauth_adapter">nginx_omniauth_adapter</a>のGolangポート
<a href="https://github.com/shogo82148/go-nginx-oauth2-adapter">shogo82148/go-nginx-oauth2-adapter</a>を紹介しました。</p>

<p>adapter自身の公開設定をしなくて良い分簡単にセットアップできます。
nginx_omniauth_adapter互換ですぐに乗り換えもできるので、ぜひお気軽にお試し下さい。</p>
]]></content>
  </entry>
  
</feed>
