<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-10-28T21:15:36+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Webブラウザを使って電波を出してみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/03/29/web-jjy/"/>
    <updated>2016-03-29T12:19:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/03/29/web-jjy</id>
    <content type="html"><![CDATA[<p>読者の持っている至って普通のコンピューターは、実は電波時計の時刻合わせを行うために必要な標準電波の発信装置が備わっている。</p>

<p>コードは以下から入手できる。</p>

<ul>
<li><a href="https://github.com/shogo82148/web-jjy">shogo82148/web-jjy</a></li>
<li><a href="http://shogo82148.github.io/web-jjy/">JJYシミュレータWeb版</a></li>
</ul>


<!-- More -->


<h2>動かし方</h2>

<p>パソコンのイヤホンジャックにアンテナ(普通のイヤホンで十分です)を接続し、電波時計の近くに置きます。
音量を最大にし、「Start」ボタンを押すと信号が送信されます。
電波時計を強制受信モードにし、時刻が設定されるのを待ちましょう。</p>

<p>パソコンの時間を基準にするので、あらかじめntpとかで時刻設定をしておくといいと思います。</p>

<h2>原理</h2>

<p><a href="http://jjy.nict.go.jp/jjy/trans/index.html">標準電波JJY</a>は日本標準時のタイムコードを送信する電波で、
東日本では40kHz、西日本では60kHzの周波数で発信されています。
電波時計はこの信号を使って時刻合わせをしています。</p>

<p>この信号をオーディオデバイスから出力する<a href="http://www.starstonesoft.com/jjy_simulator.htm">電波時計用JJYシミュレータ</a>というものがあるのを知り、
「今のWebブラウザならjavascriptだけで実装できるのでは？」と思いやってみました。
一般的なオーディオデバイスは、20kHz以上の周波数の再生には適していないため、そのままでは40kHz/60kHzの信号は出せません。
そこで、<a href="http://www.starstonesoft.com/jjy_simulator.htm">電波時計用JJYシミュレータ</a>は、歪んだ波形に含まれる高調波を利用しています。
ボリュームを大きくして音が割れた状態になると、音声信号は矩形波に近いかたちになります。
矩形波には3倍、5倍、7倍&hellip;の奇数倍の周波数成分が含まれているため、
(<a href="http://togetter.com/li/942071">世はまさに大フーリエ時代</a>とか見ると楽しい)
13.333kHzの矩形波を出力することで、39.999kHzの信号を出せるというわけです。</p>

<p>元のソフトウェアはWindowsのバイナリ形式でしたが、
WebAudioの登場によりWebブラウザからも同様のことが行えるようになりました。</p>

<h2>最後に</h2>

<p>少し前にCPUから出るノイズを使ってAMラジオの電波を発信するという記事が話題になりましたね。</p>

<ul>
<li><a href="http://cpplover.blogspot.jp/2016/03/am.html">普通のコンピューターからAMラジオを鳴らそう</a></li>
</ul>


<p>CPUやオーディオデバイスも電気で動いている以上、電波が出ているのは当たり前のことなのですが、
こうやって改めて確認できると面白いですね。</p>

<p>パソコンから出る程度の電波強度では、電波法に抵触することはないと思いますが、
うっかり強力な電波を発信しないよう気をつけてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[キレイになったコトバとハートを元に戻すツール作った]]></title>
    <link href="https://shogo82148.github.io/blog/2014/06/01/anti-sizukatter/"/>
    <updated>2014-06-01T00:24:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2014/06/01/anti-sizukatter</id>
    <content type="html"><![CDATA[<p>現実世界にご満足の方消えてなくなってほしいの！！！</p>

<p><a href="http://www.toyotown.jp/sizukatter/">しずかったー</a>を使うと個性あふれるコトバを使ってもキレイにしてくれるので
とっても便利ですね！
でも、本当は何を言っているのか真意を知りたい・・・。</p>

<p>そんな人のために、キレイになったコトバとハートを元に戻す
<a href="http://shogo82148.github.io/anti-sizukatter/">アンチしずかったー</a>
を作りました。</p>

<!-- More -->


<h2>仕組み</h2>

<p>しずかったーは単純な文字列置換で動いているみたいなので、
対応表を頑張って作りました。
それを<a href="http://mecab.googlecode.com/svn/trunk/mecab/doc/index.html">MeCab</a>用の辞書に変換し、
<a href="http://igo.sourceforge.jp/">Igo</a>を使ってバイナリ辞書に変換、
<a href="https://github.com/shogo82148/igo-javascript">igo-javascript</a>でブラ失礼しちゃう上で解析できるようにしました。</p>

<h2>既知の問題点</h2>

<p>しずかったー前後の文脈関係なく変換しちゃうので、
同音異義語は元に戻らないことがあります。
特にひらがな・カタカナは失敗することが多いです。(「（お昼寝したい）ふわふわ」だとか「ブラ失礼しちゃう」だとか)</p>

<p>あと、マシュマロ的な内緒の言葉はさすがのしずかちゃんでも代替表現が思いつかなかったらしく、
全部ハートになってしまいます。
元に戻せと言う方が頑張ればなんとかできそうなので期待しないでく時代が変わればかっこいい。</p>

<h2>まとめ</h2>

<p>またおもしろいものを作ってしまいましたが、
igo-javascriptのバグを発見できたりしたので、いいのです。</p>

<p>自宅警備員でお時間ある方の皆様、天才だと思ったらぜひおしゃべり広場や「いいね！」広場で共有をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript版WaveZutaZuta作ってみた]]></title>
    <link href="https://shogo82148.github.io/blog/2012/12/24/wavezutazutajs/"/>
    <updated>2012-12-24T13:51:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2012/12/24/wavezutazutajs</id>
    <content type="html"><![CDATA[<p>「<a href="http://nekogata.hatenablog.com/entry/2012/12/23/155250">WaveZutaZutaというおもちゃを書いている話</a>」
という記事を見ていたら，誰かがツイッターで
「いっちーがJavaScriptに移植してくれる」と発言．</p>

<p>あ，はい．やってみましょう．</p>

<!-- More -->


<h2>どんな感じのものなの？</h2>

<p>音声ファイルをテキトーに切り貼りできるライブラリです．
<a href="http://shogo82148.github.com/WaveZutaZutaJS/">WaveZutaZutaJS</a>にブラウザで実行出来るサンプルを置いたので
実際試してみるのが一番わかりやすいと思います．
適当な音声ファイルをドラッグ＆ドロップして，playボタンを押すと音が流れるので，いろいろ遊んでみてください．</p>

<p>テキストボックスには楽譜が書かれています．
楽譜の書き方は「<a href="http://nekogata.hatenablog.com/entry/2012/12/23/155250">WaveZutaZutaというおもちゃを書いている話</a>」
と同じです．</p>

<blockquote><p>ちなみに、楽譜ファイルの読み方、書き方ですが、aからzまでの文字それぞれにずたずたにされたwaveファイルの"破片"がアサインされていて、-は音をのばす(タイ)を意味し、0は休符を意味します。*を指定すると、a-zのうちどれかをランダムで鳴らします。1文字が64分音符ひとつ分の長さです。空白文字は無視されます。</p></blockquote>

<h2>使い方</h2>

<p><a href="https://github.com/shogo82148/WaveZutaZutaJS">リポジトリ</a>の WaveZutaZutaJS.js がライブラリの本体です．
次のように使います．</p>

<pre><code class="javascript">var data = new ArrayBuffer(); // ずたずたにしたい音声データを入れておく
var context = new AudioContext();
var zuta = new WaveZutaZuta(context);
zuta.onSuccess = function(self, source) {
    // 元の音声の先頭5秒から3秒間流す
    zuta.setNote('a', 5);
    var node = zuta.getAudioNode([{sound: 'a': length: 3}]);
    node.connect(context.destination);
};
zuta.loadAudio(data);
</code></pre>

<p><code>data</code> には入力音声のバイナリデータを入れておきます．
形式はブラウザが対応していれば何でもOKです．
Chromeなら wav, mp3, mp4 など，メジャーな形式はたいてい読めると思います．</p>

<p><code>getAudioNode</code>で返ってくるのは AudioNode なので，WaveZutzZutaJS の出力にさらにエフェクトをかけることができます．
例えば，次のコードで周波数フィルタを通すことができます．</p>

<pre><code class="javascript">var data = new ArrayBuffer(); // ずたずたにしたい音声データを入れておく
var context = new AudioContext();
var zuta = new WaveZutaZuta(context);
zuta.onSuccess = function(self, source) {
    // 元の音声の先頭5秒から3秒間流す
    zuta.setNote('a', 5);
    var node = zuta.getAudioNode([{sound: 'a': length: 3}]);

    // 周波数フィルタを用意
    var filter = context.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 1000;

    // 接続
    node.connect(filter);
    filter.connect(context.destination);
};
zuta.loadAudio(data);
</code></pre>

<h2>簡単な技術解説</h2>

<h3>decodeAudioData</h3>

<p>WebAudioの<code>decodeAudioData</code>を使うと音声データからPCMデータを得ることができます．
これを使うと音声データを配列として得ることができるので，
WeveZutaZutaJSではこの配列を切り貼りしてずたずたにしています．</p>

<pre><code class="javascript">var data = new ArrayBuffer() // 音声データ
var context = new AudioContext();
context.decodeAudioData(data, function(buf) {
    //buf には AudioBuffer 型の音声データが入っている

    var float32array = getChannelData(0);
    // float32array を適当にいじる
});
</code></pre>

<h3>JavaScriptNode</h3>

<p>JavaScriptNode は音源やフィルタ・アナライザを JavaScript のコードを使って書くことの出来るものです．
例えば，正弦波を生成するコードは次のようになります．</p>

<pre><code class="javascript">var context = new AudioContext();
var node = context.createJavaScriptNode(2048, 0, 1); // バッファの大きさ，入力の数，出力の数
var x;
node.onaudioprocess = function(buf) {
    var data = buf.outputBuffer.getChannelData(0);
    var i;
    for(i = 0; i &lt; data.length; ++i) {
        data[i] = Math.sin(x++);
    }
};
node.connect(context.destination);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavascriptでIME]]></title>
    <link href="https://shogo82148.github.io/blog/2012/03/28/igoime/"/>
    <updated>2012-03-28T22:00:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2012/03/28/igoime</id>
    <content type="html"><![CDATA[<p>この前いじった<a href="http://shogo82148.github.com/AjaxIME">Chrome17対応版AjaxIME</a>は
実際の変換を行うのに本家<a href="http://ajaxime.chasen.org/">AjaxIME</a>が提供している変換サーバをそのまま使用しています。
そのため、すべての入力内容は本家サーバに送信されてしまいます。
どんな入力をしたのか作者さんにバレバレです。
この送信内容、暗号化すらされていないので、作者以外の人に見られる可能性もあります。
自分の書いた文章が勝手にインターネットに送信されているっていうのはあんまり嬉しくないですね。
ローカルのみで完結するのが理想です。</p>

<p>本家サーバはどうやら<a href="http://chasen.org/~taku/software/mecab-skkserv/">mecab-skkserv</a>と同じエンジンを使っているようです。
このバックエンドで動いているのは実は<a href="http://mecab.googlecode.com/svn/trunk/mecab/doc/index.html">MeCab</a>。
ということは、MeCabと互換性のある<a href="https://github.com/shogo82148/igo-javascript">igo-javascript</a>でも同じことができるはず・・・！
これはならブラウザ上ですべてが完結する！</p>

<p>はい、そういうことで作ってみました。</p>

<ul>
<li><a href="http://shogo82148.github.com/IgoIME/">IgoIME</a></li>
</ul>


<p>使い方は本家と一緒です。Alt-o (Ctrl-9)でモード切替。
ローマ字で日本語を入力することができます。</p>

<p>日本語入力をするためには変換候補をいくつか出力する必要がありますが、
本来Igoにはその機能はありません。
そのため、複数候補を出す部分だけ独自実装してあります。
しかし、まだなんか変換候補が怪しいですね・・・。
長い文章を入力したのに一文字しか結果が帰ってこないことがあります。
なんでだろう・・・・</p>

<p>まだまだ改良が必要なようです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascriptでの関数宣言]]></title>
    <link href="https://shogo82148.github.io/blog/2012/03/23/javascript-function/"/>
    <updated>2012-03-23T18:22:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2012/03/23/javascript-function</id>
    <content type="html"><![CDATA[<h2>Chrome17対応版AjaxIME</h2>

<p>Ajaxを使ってIMEを実現した<a href="http://ajaxime.chasen.org/">AjaxIME</a>がFireFoxでは動くのに最新版のChromeで動かない。
動くように少しいじってみた。</p>

<ul>
<li><a href="http://shogo82148.github.com/AjaxIME/">Chrome17対応版AjaxIME</a></li>
</ul>


<!-- more -->


<h2>原因</h2>

<p>Chromeで動かなかった原因はここ。</p>

<pre><code class="javascript">if(typeof getComputedStyle == 'undefined') {
    function getComputedStyle() {
        //中身は省略
    }
}
</code></pre>

<p>FireFoxやChromeには getComputedStyle という関数が定義されているけど、
IEには定義されていない。
if文で有無を判定して、無い場合は動作をエミュレートする関数を定義している。</p>

<p>実行の様子をデバッガで追って見ると、Chromeではエミュレートする必要が無いのになぜか自前で定義した関数が呼び出されていた。
どうやら、Chromeでは 自作 getComputedStyle 関数が if文の中にあったとしてもコード読み込み時に作成されてしまうみたい。
FireFox だと if文の中が実行されない場合には作成されない。</p>

<p>結果だけ書くと、次のように書きなおしたら動いた。</p>

<pre><code class="javascript">if(typeof getComputedStyle == 'undefined') {
    getComputedStyle = function() {
        //中身は省略
    }
}
</code></pre>

<p>あと Chrome だと、Input要素にフォーカスがあたった時に余計な装飾がついてしまうので、CSS上書きして抑制。
IE8でTextRangeが使えない問題は「<a href="http://d.hatena.ne.jp/kanehama/20100330/1269946922">IE8でのTextRange.moveToPoint()</a>」を参考にして解決。
IE7のエミュレートモードにしているだけで、根本的な解決にはなってないけど、まあIEだしいいでしょ。</p>

<h2>どっちが正しいの？</h2>

<p>とりあえず問題は解決したんだけど、FireFoxとChromeで動作が違うけど、どちらの動作が正しいの？
気になったので調べてみた。</p>

<p>「<a href="http://alpha.mixi.co.jp/entry/2012/10814/">mixi Engineers' Blog >> 詳細 ECMA-262-3 第5章 関数</a>」に関数の定義法についてわかりやすい解説が載っていた。
結論からいうと、一番初めの書き方は「誤り」で実際の動作は実装依存、つまり FireFox の動作も Chrome の動作も正しいとのこと。</p>

<h2>関数定義と関数式</h2>

<p>関数の定義法は大きく分けて、次のような関数定義と関数式に分かれている。
関数式は更に名前なしと名前付きがある。</p>

<pre><code class="javascript">//関数定義
function foo() {
}

//名前なしの関数式
var foo = function() {
};

//名前付きの関数式
var foo = function _foo() {
};
</code></pre>

<p>普通の関数定義と無名関数があるのは知っててけど、単なるシュガーシンタックスみたいなものかと思った。
mixiのブログによると全くの別物。
関数定義と関数式の大きな違いは、実行時に呼び出し可能になっているかどうか。
関数定義は実行時に呼び出し可能になっているから、定義と呼び出しの順番は関係ない。</p>

<pre><code class="javascript">foo(); //OK
function foo() {
}
foo(); //OK
</code></pre>

<p>関数式は実行されるまで呼び出し可能にはならないから、定義より前で呼び出すことはできない。</p>

<pre><code class="javascript">foo(); //ERROR!
foo = function() {
};
foo(); //OK
</code></pre>

<p>関数定義は実行の前に評価する必要があるからif文の中に入れちゃダメ。
他にも関数名が使える範囲に違いがあるみたいだけど、詳しいことはmixiのブログ参照。</p>

<h2>まとめ</h2>

<p>関数定義と関数式の違いは重要なので覚えておこう！</p>

<p>ところで、なぜAjaxIMEをいじっているかというと・・・ふふふ・・・</p>
]]></content>
  </entry>
  
</feed>
