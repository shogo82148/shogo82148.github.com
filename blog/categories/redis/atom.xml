<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/redis/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-06-26T10:20:23+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis、PostgreSQL、MySQLで近傍検索]]></title>
    <link href="https://shogo82148.github.io/blog/2017/03/28/database-gis/"/>
    <updated>2017-03-28T19:59:49+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/03/28/database-gis</id>
    <content type="html"><![CDATA[<p>「<a href="http://techblog.kayac.com/serverside-geohash">サーバーで付近の情報を通知するサービスのつくり方</a>」
という、Geohashを使って近傍検索を実現する記事をみつけました。
最近<a href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/">Redisに関する記事</a>を書いた関係で、
この記事をみて「GeohashはRedisと一緒に使うともっと便利だよ！」と思わず宣伝したくなったのですが、
MySQL5.7でInnoDBに空間インデックス(Spatial Index)のサポートが入ったので
「MySQLでももっと簡単にできるのでは？」と思い、
RedisやMySQLを含めたいろんなDBで近傍検索を実現する方法を調べてみました。</p>

<p>以前、<a href="https://shogo82148.github.io/blog/2012/08/02/fireworks/">スマートフォンのセンサを活用して花火の打ち上げ場所を推定するアプリ</a>を作った関係で、
地球上での距離計算の実装も気になったので、それについても調査してみました。</p>

<!-- More -->


<h2>関連知識</h2>

<h3>GeoHash</h3>

<p><a href="https://ja.wikipedia.org/wiki/%E3%82%B8%E3%82%AA%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5">Geohash（ジオハッシュ）</a>
は緯度・経度を短い文字列に変換する方法です。
距離が近い2地点のGeohashは似たような文字列になるという特徴があります(一部例外あり)。
この特徴を利用すると、文字列検索だけで近傍検索が実現できます。</p>

<h3>地球上の二点間の距離</h3>

<p>地球は完全な球体ではなく、回転楕円体であることが知られています。
地球の形がわからないと緯度・経度などを決められないので、
<a href="https://ja.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E6%A5%95%E5%86%86%E4%BD%93">地球楕円体</a>が定義されています。
近似方法によっていくつか種類があるのですが、GPSなどで使われているWGS84がよく使われているようです。</p>

<p>国土地理院が提供している<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/main.html">測量計算サイト</a>では
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/bl2stf.html">距離と方位角の計算</a>を使って緯度・経度から距離を計算できます。
回転楕円体上の距離の厳密解は求められない(要出典)ので、
<a href="http://vldb.gsi.go.jp/sokuchi/surveycalc/surveycalc/algorithm/bl2st/bl2st.htm">数値計算</a>によって求めることになります。
計算式を見て分かる通り非常に複雑なので、なんらかの近似をしている実装がほとんどです。</p>

<h2>各種DBでの実現方法</h2>

<h3>Redis</h3>

<p>Redisでは3.2から<a href="https://redis.io/commands#geo">GEO</a>関連の機能をサポートしています。
ソート済みセットにGeohashを組み合わせて実現しています。</p>

<p>簡単に試してみました。データは以下の記事から拝借したものを使用します。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/ilo/20090212/1234448136">MySQLで指定した緯度経度から半径nメートル内検索っぽいのを実現するSQL</a></li>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<p><a href="https://redis.io/commands/geoadd"><code>GEOADD</code></a>でデータ挿入です。
ちなみにデータを削除する<code>GEODEL</code>は用意されていないとのこと。
中身はソート済みセットなので、<a href="https://redis.io/commands/zrem">ZREM</a>でいいんですね。</p>

<pre><code class="plain">$ cat command.txt
GEOADD geotable 139.777254 35.713768 上野駅         139.774029 35.711846 西郷隆盛像
GEOADD geotable 139.774744 35.712737 上野の森美術館 139.770872 35.712351 不忍池弁財天
GEOADD geotable 139.775696 35.716293 野口英世博士像 139.775803 35.715420 国立西洋美術館
GEOADD geotable 139.776544 35.716319 国立科学博物館 139.772776 35.717186 東京都美術館
GEOADD geotable 139.776462 35.718883 東京国立博物館 139.794547 35.715280 花やしき
GEOADD geotable 139.792692 35.710635 雷門
$ redis-cli &lt; command.txt
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 2
(integer) 1
</code></pre>

<p><code>GEOHASH</code>で各地点のGeohashを取得できます。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEOHASH geotable 上野駅 西郷隆盛像 上野の森美術館
1) "xn77htqxy10"
2) "xn77hthkdf0"
3) "xn77htkcg80"
</code></pre>

<p><code>GEORADIUS</code>で近傍検索ができます。
上野駅から半径300m以内の地点を求める例です。
データに日本語を使ったので非常にわかりにくいですが、
上野駅から近い順に「上野駅」「国立西洋美術館」「上野の森美術館」「国立科学博物館」の距離と座標を返してくれました。</p>

<pre><code class="plain">$ redis-cli
127.0.0.1:6379&gt; GEORADIUS geotable 139.777254 35.713768 300 m WITHCOORD WITHDIST ASC
1) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe9\xa7\x85"
   2) "0.1203"
   3) 1) "139.77725297212600708"
      2) "35.71376868735887911"
2) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe8\xa5\xbf\xe6\xb4\x8b\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "225.4920"
   3) 1) "139.77580457925796509"
      2) "35.71541879083360271"
3) 1) "\xe4\xb8\x8a\xe9\x87\x8e\xe3\x81\xae\xe6\xa3\xae\xe7\xbe\x8e\xe8\xa1\x93\xe9\xa4\xa8"
   2) "254.1580"
   3) 1) "139.77474242448806763"
      2) "35.71273705584702896"
4) 1) "\xe5\x9b\xbd\xe7\xab\x8b\xe7\xa7\x91\xe5\xad\xa6\xe5\x8d\x9a\xe7\x89\xa9\xe9\xa4\xa8"
   2) "290.8339"
   3) 1) "139.77654486894607544"
      2) "35.71631861684517872"
</code></pre>

<p>上野駅と上野駅の距離は当然0mなはずですが、ちょっとだけズレてます。
これはソート済みセットの制約で緯度・経度それぞれ53bitを26bitにまるめているからです(たぶん)。
距離の計算は<a href="https://github.com/antirez/redis/blob/4.0/src/geohash_helper.c#L52">半径6372797.560856mの完全な球体</a>で近似し、
<a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>というのを使っています。</p>

<p>ちなみに扱える緯度・経度には以下の制限があり、極付近の座標は扱えません。</p>

<ul>
<li>経度 -180度から180度</li>
<li>緯度 -85.05112878度から85.05112878度</li>
</ul>


<p>これは Spherical Mercator(球面メルカトル図法) の制限らしいです。
Google Maps, OpenStreetMap, Bing 等でよく見る地図は平面ですが、本来の地球は丸いので、うまく平面にマッピングする必要があります。
このときにどうしても本来の地形から歪んでしまうわけですが、
極付近では歪みが無限大になってしまいうまく平面の地図にできないのです。</p>

<p>ただ、Redis自体は平面へのマッピングをしないので、別にこの制限要らな気もします。
まあ、コーナーケースなので他にも問題がありそうですし、
そもそも北極・南極向けにサービス作らないので気にしないでおきましょう。</p>

<h3>PostgreSQL</h3>

<p>日本語で書かれた先行事例を見つけたので、PostgreSQLの紹介から。
以下の記事にあるように、PostGISというオプション機能をインストールすると簡単に実現できます。</p>

<ul>
<li><a href="https://www.infoscoop.org/blogjp/2015/01/21/tutorial_for_geodb/">PostgreSQLとOracleで緯度経度から半径nメートル内検索を実行してみる。</a></li>
</ul>


<pre><code class="sql">-- PostGISを有効化
CREATE EXTENSION postgis;

-- テーブルの作成
CREATE TABLE geotable (
    id   SERIAL NOT NULL PRIMARY KEY,
    name varchar (255) NOT NULL,
    geom geography(POINT, 4326) NOT NULL
);

-- データの挿入
INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeographyFromText('SRID=4326;POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeographyFromText('SRID=4326;POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeographyFromText('SRID=4326;POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeographyFromText('SRID=4326;POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeographyFromText('SRID=4326;POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeographyFromText('SRID=4326;POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeographyFromText('SRID=4326;POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeographyFromText('SRID=4326;POINT(139.776462 35.718883)')),
('花やしき', ST_GeographyFromText('SRID=4326;POINT(139.794547 35.71528)')),
('雷門', ST_GeographyFromText('SRID=4326;POINT(139.792692 35.710635)'));

-- 空間インデックスの作成
CREATE INDEX gist_geotable on geotable USING GIST (geom);
</code></pre>

<p><code>ST_GeoHash</code>でGeohashを求めることができます。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom) FROM geotable;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |      st_geohash
-----------------------+-----------------------------+----------------------
 上野駅             | POINT(139.777254 35.713768) | xn77htqxy0fu2t0y69sv
 西郷隆盛像       | POINT(139.774029 35.711846) | xn77hthkdfw51p8cmr68
 上野の森美術館 | POINT(139.774744 35.712737) | xn77htkcg8enm86bp3j7
 不忍池弁財天    | POINT(139.770872 35.712351) | xn77ht4p92sp8jdqkjzf
 野口英世博士像 | POINT(139.775696 35.716293) | xn77htvw3z9495yr4dxd
 国立西洋美術館 | POINT(139.775803 35.71542)  | xn77htv9kkbffr4ptjcy
 国立科学博物館 | POINT(139.776544 35.716319) | xn77htynts3mer092t8v
 東京都美術館    | POINT(139.772776 35.717186) | xn77hw57twp9x63n6vus
 東京国立博物館 | POINT(139.776462 35.718883) | xn77hwqjedkhwdmmwp0n
 花やしき          | POINT(139.794547 35.71528)  | xn77jjg2949rgdfxbrjp
 雷門                | POINT(139.792692 35.710635) | xn77jhcvtbf5mdcexf85
(11 rows)
</code></pre>

<p>近傍検索には<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_DWithin.html"><code>ST_DWithin</code></a>を使います。
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance.html"><code>ST_Distance</code></a>や
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Sphere.html"><code>ST_Distance_Sphere</code></a>、
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/ST_Distance_Spheroid.html"><code>ST_Distance_Spheroid</code></a>等
を使って距離を計算して絞り込むことも出来ますが、これらの関数はインデックスを使ってくれません。
<code>ST_DWithin</code>は
<a href="http://cse.naro.affrc.go.jp/yellow/pgisman/2.0.0/using_postgis_dbmanagement.html#id286995989">GiSTインデックス</a>
を利用してくれるので高速に処理してくれます。</p>

<pre><code class="sql">SELECT
    name,
    ST_AsText(geom),
    ST_Distance('SRID=4326;POINT(139.777254 35.713768)', geom) as dist
FROM geotable
WHERE ST_DWithin(geom, ST_GeographyFromText('SRID=4326;POINT(139.777254 35.713768)'), 300.0)
ORDER BY dist;
</code></pre>

<pre><code class="plain">         name          |          st_astext          |     dist
-----------------------+-----------------------------+---------------
 上野駅             | POINT(139.777254 35.713768) |             0
 国立西洋美術館 | POINT(139.775803 35.71542)  | 225.468916585
 上野の森美術館 | POINT(139.774744 35.712737) | 254.308127877
 国立科学博物館 | POINT(139.776544 35.716319) | 290.242707221
</code></pre>

<p><code>ST_</code>で始まる関数は<a href="http://www.opengeospatial.org/standards/sfs">OpenGIS</a>やSQL/MMで標準化されているものらしいです。</p>

<h3>MySQL</h3>

<p>MySQLに関しては以下の記事を見つけました。
この記事が書かれた頃はMyISAMでしか空間インデックスをサポートしていませんでしたが、
5.7からInnoDBでもサポートされるようになったので、
InnoDBでも同様のことができるはずです。</p>

<ul>
<li><a href="http://qiita.com/kochizufan/items/a68b30ba74849483f75c">mysql空間テーブルの作り方</a></li>
</ul>


<p>MySQL5.7で入った機能についてはこちらを参照。
空間インデックス以外にも大量に変更があるので、アップグレードする人は確認をおすすめします。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B01LCJRCYE&linkId=ac9d8d9e348bd97dc858337c94e82696"></iframe>


<p>MySQLもPostgreSQLもOpenGISに準拠する方針みたいなので、
PostgreSQLと同じ感じでSQLが書けると信じたいところですが、
当然ながらそうは行きません。</p>

<p>一番大きな違いは<code>geography</code>型には対応しておらず<code>geometry</code>型しか使えないということです。
<code>geography</code>型は測地系の情報を持っている(つまり地球が回転楕円体だということを知っている)のですが、
<code>geometry</code>型は測地系の情報が無いため、平面しか扱えません。</p>

<pre><code class="sql">CREATE DATABASE test; -- 5.6以前は勝手に作ってくれたけど、5.7からは無いらしい
USE test;
CREATE TABLE IF NOT EXISTS `geotable` (
  `id`   int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` VARCHAR (255) NOT NULL,
  `geom` geometry NOT NULL,
  PRIMARY KEY (`id`),
  SPATIAL KEY `geom` (`geom`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
</code></pre>

<p>座標の指定も<code>ST_GeographyFromText</code>ではなく<code>ST_GeomFromText</code>を使います。</p>

<pre><code class="sql">INSERT INTO geotable (name, geom) VALUES
('上野駅', ST_GeomFromText('POINT(139.777254 35.713768)')),
('西郷隆盛像', ST_GeomFromText('POINT(139.774029 35.711846)')),
('上野の森美術館', ST_GeomFromText('POINT(139.774744 35.712737)')),
('不忍池弁財天', ST_GeomFromText('POINT(139.770872 35.712351)')),
('野口英世博士像', ST_GeomFromText('POINT(139.775696 35.716293)')),
('国立西洋美術館', ST_GeomFromText('POINT(139.775803 35.71542)')),
('国立科学博物館', ST_GeomFromText('POINT(139.776544 35.716319)')),
('東京都美術館', ST_GeomFromText('POINT(139.772776 35.717186)')),
('東京国立博物館', ST_GeomFromText('POINT(139.776462 35.718883)')),
('花やしき', ST_GeomFromText('POINT(139.794547 35.71528)')),
('雷門', ST_GeomFromText('POINT(139.792692 35.710635)'));
</code></pre>

<p>PostgreSQLと同様にGeohashを求める<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-geohash-functions.html"><code>ST_GeoHash</code>があります</a>が、
桁数を指定する必要があるという違いがあります。</p>

<pre><code class="sql">SELECT name, ST_AsText(geom), ST_GeoHash(geom, 11) FROM geotable;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+----------------------+
| name                  | ST_AsText(geom)             | ST_GeoHash(geom, 11) |
+-----------------------+-----------------------------+----------------------+
| 上野駅                | POINT(139.777254 35.713768) | xn77htqxy0f          |
| 西郷隆盛像            | POINT(139.774029 35.711846) | xn77hthkdfw          |
| 上野の森美術館        | POINT(139.774744 35.712737) | xn77htkcg8e          |
| 不忍池弁財天          | POINT(139.770872 35.712351) | xn77ht4p92s          |
| 野口英世博士像        | POINT(139.775696 35.716293) | xn77htvw3z9          |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | xn77htv9kkb          |
| 国立科学博物館        | POINT(139.776544 35.716319) | xn77htynts3          |
| 東京都美術館          | POINT(139.772776 35.717186) | xn77hw57twp          |
| 東京国立博物館        | POINT(139.776462 35.718883) | xn77hwqjedk          |
| 花やしき              | POINT(139.794547 35.71528)  | xn77jjg2949          |
| 雷門                  | POINT(139.792692 35.710635) | xn77jhcvtbf          |
+-----------------------+-----------------------------+----------------------+
11 rows in set (0.00 sec)
</code></pre>

<p>MySQLにも距離を求める<code>ST_Distance</code>はあるのですが、これは平面専用です。
地球上での距離を求めるには<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-convenience-functions.html"><code>ST_Distance_Sphere</code>を使います</a>。
MySQL5.7から追加された関数で、これを使うと半径6370986mの球体で近似したときの距離を計算できます。</p>

<p>そして残念なことにPostgreSQLにはあった<code>ST_DWithin</code>はMySQLにはありません。
<code>ST_Distance_Sphere</code>を使えばクエリは書けるのですが、インデックスを使ってくれないので非効率です。
そのため、矩形の範囲指定で大雑把に絞り込んだあとで<code>ST_Distance_Sphere</code>を使って詳細に絞り込むことになります。</p>

<pre><code class="sql">SET @ueno = ST_GeomFromText('POINT(139.777254 35.713768)');
SELECT
    name,
    ST_AsText(geom),
    ST_Distance_Sphere(@ueno, geom) AS dist
FROM geotable
WHERE ST_Distance_Sphere(@ueno, geom) &lt;= 300
AND ST_Within(geom, ST_Buffer(@ueno, DEGREES(300/(6370986*COS(RADIANS(ST_Y(@ueno))))), ST_Buffer_Strategy('point_square')))
ORDER BY dist;
</code></pre>

<pre><code class="plain">+-----------------------+-----------------------------+--------------------+
| name                  | ST_AsText(geom)             | dist               |
+-----------------------+-----------------------------+--------------------+
| 上野駅                | POINT(139.777254 35.713768) |                  0 |
| 国立西洋美術館        | POINT(139.775803 35.71542)  | 225.62014319497658 |
| 上野の森美術館        | POINT(139.774744 35.712737) | 253.96163316266237 |
| 国立科学博物館        | POINT(139.776544 35.716319) | 290.81011310408957 |
+-----------------------+-----------------------------+--------------------+
4 rows in set (0.00 sec)
</code></pre>

<p>緯度によって経度1度あたりの長さが違うので、矩形選択の範囲に補正を入れてあります。
本当は緯度の補正は無くても良いはずですが、広めならいいだろ！ってことで雑に書いています。
本番で使いたい人は補正＆バリデーション頑張ってください(特に極の辺りで大変なことになるので)。</p>

<h3>その他DB</h3>

<p>力尽きたので簡単に。</p>

<p>SQLiteは<a href="https://www.gaia-gis.it/fossil/libspatialite/index">SpatiaLite</a>という拡張モジュールで空間データを扱えるようです。</p>

<p>全文検索エンジンの<a href="http://groonga.org/ja/">Groonga</a>も近傍検索に対応していて、
距離の計算方法は以下の3つから選べるようです。
(<a href="http://groonga.org/ja/docs/reference/functions/geo_distance.html"><code>geo_distance</code></a>)</p>

<ul>
<li><code>rectangle</code>: 方形近似して距離を計算</li>
<li><code>sphere</code>: <a href="https://github.com/groonga/groonga/blob/v7.0.0/lib/grn_geo.h#L42">半径6357303m</a>の完全な球体と仮定して計算</li>
<li><code>ellipsoid</code>: WGS84地球楕円体を<a href="http://yamadarake.jp/trdi/report000001.html">ヒュベニの距離計算式</a>で近似</li>
</ul>


<p>ヒュベニの距離計算式というのが出てきましたが、<code>ellipsoid</code>で使っているのは簡易版で、
<a href="http://www.amano-tec.com/apps/paceruler.html">本来のヒュベニの距離計算式</a>は非常に複雑で難しい・・・。</p>

<h2>まとめ</h2>

<p>Redis、PostgreSQL、MySQLで近傍検索をやってみました。</p>

<ul>
<li>Redisは近傍検索だけならお手軽</li>
<li>PostgreSQL+PostGISは今回触った中では最強。地理データを真面目に扱うならいいかも</li>
<li>MySQLは5.6以前よりは扱いやすくなったものの、空間インデックスを効果的に使うには一工夫必要</li>
</ul>


<p>PostgreSQL+PostGISと比べると、どうしてもMySQL5.7は見劣りしますね。
しかし、検索をSQLで書けるという利点は大きいので、利用を検討する価値はあると思います。</p>

<p>ところで、大体のDBで地球を完全な球で近似する実装が入ってるんですが、
半径が微妙に違うんですよね。</p>

<ul>
<li>Redis: 6 372 797.560 856m</li>
<li>PostgreSQL: 6 370 986m</li>
<li>MySQL: 6 370 986m</li>
<li>Groonga: 6 357 303m</li>
<li>赤道半径: 6 378 137m</li>
<li>極半径: 6 356 752.314 245m</li>
</ul>


<p>0.24%しか違わないので、実用上は全く問題ないんですが、
出典がよくわからないし気になります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisを使ってユニークなIDを配布する]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis/"/>
    <updated>2017-02-26T19:37:45+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis</id>
    <content type="html"><![CDATA[<p>スケーラブルにIDを生成する方法として
Twitterの<a href="https://github.com/twitter/snowflake">snowflake</a>が有名です。
1024台までスケールすることが出来ますが、各snowflakeのサーバにユニークなWoker IDを割り振る必要があります。
IDを振るためのサーバにIDを振るのが問題になるとは難しいですね。</p>

<p>各snowflakeサーバにIDを振る親玉Worker ID配布サーバを作るというアイデアはあったのですが、
Worker IDサーバの可用性を考えるのが大変で手を付けていませんでした。
最近になってWorker IDサーバとしてRedisを使い、ソート済みセット型で管理すれば楽できるのでは？
と思いついたので、やってみたというお話です。</p>

<!-- More -->


<h2>概要</h2>

<p>レポジトリはこちらです。</p>

<ul>
<li><a href="https://github.com/shogo82148/yaraus">shogo82148/yaraus</a></li>
</ul>


<p>他の<a href="https://github.com/twitter/snowflake">snowflake</a>-likeなID発番サーバの実装として
<a href="http://techblog.kayac.com/katsubushi-introduction.html">katsubushi</a>や
<a href="https://github.com/sony/sonyflake">sonyflake</a>なんていうのもあります。
これらのID発番サーバにRedisを使ってWorker IDを割り振るコマンドです。
Redis3.2以上推奨です。</p>

<h2>使い方</h2>

<p>Go製なので<code>go get</code>でインストールできます。</p>

<pre><code class="bash">go get github.com/shogo82148/yaraus/cmd/yaraus
</code></pre>

<pre><code class="bash"># 1から1023までのIDが使えるようにRedisを初期化
$ yaraus init -min 1 -max 1023

# ユニークなIDが必要な処理を実行する
$ yaraus run -- echo {}
2017/02/25 17:19:16 getting new id...
2017/02/25 17:19:16 client id: YourHostName-1488010756.738-1, id: 1
2017/02/25 17:19:16 sleep 2s for making sure that other generates which has same id expire.
2017/02/25 17:19:18 starting...
1
2017/02/25 17:19:18 releasing id...

# katsubushiと一緒に使う例
$ yaraus run -- ./katsubushi -worker-id={} -port=7238

# ステータス情報もとれます
$ yaraus stats
{
    "client_id_count": 4,
    "client_get_id_count": 4,
    "client_get_id_success": 4,
    "get_id_no_available_id": 0,
    "extend_ttl_count": 8,
    "extend_ttl_success": 8,
    "extend_ttl_ownership_error": 0,
    "extend_ttl_expire_warning": 0,
    "unusing_ids": 1023,
    "using_ids": 0,
    "using_ttl_max": 0,
    "using_ttl_mid": 0,
    "using_ttl_min": 0
}
</code></pre>

<p>ステータスの意味は以下の通りです。</p>

<ul>
<li><code>client_id_count</code>: 今までに接続してきたクライアントの延べ数</li>
<li><code>client_get_id_count</code>: ID取得を試みた回数</li>
<li><code>client_get_id_success</code>: ID取得に成功した回数</li>
<li><code>get_id_no_available_id</code>: 利用可能なIDが無くて失敗した回数</li>
<li><code>extend_ttl_count</code>: Expireを伸ばそうと試みた回数</li>
<li><code>extend_ttl_success</code>: Expireを伸ばすのに成功した回数</li>
<li><code>extend_ttl_ownership_error</code>: IDが横取りされた回数</li>
<li><code>extend_ttl_expire_warning</code>: IDが横取りされそうだったのを防いだ回数</li>
<li><code>unusing_ids</code>: 未使用のIDの数</li>
<li><code>using_ids</code>: 使用中のIDの数</li>
<li><code>using_ttl_max</code>: IDの寿命の最大値(秒単位)</li>
<li><code>using_ttl_mid</code>: IDの寿命の中央値(秒単位)</li>
<li><code>using_ttl_min</code>: IDの寿命の最小値(秒単位)</li>
</ul>


<h2>実装アイデア</h2>

<p>Redisのセット型を使えば、ID配布自体は簡単です。
Perlでの実装は以下のようになります。(Go実装なのに例がPerlなのは、僕が一番慣れているので・・・)</p>

<pre><code class="perl"># あらかじめPoolにIDを蓄えておく
$redis-&gt;sadd('pool', "id$_") for 1..10;

# ランダムに選ぶ
my $id = $redis-&gt;spop('pool');

# 使い終わったら戻す
$redis-&gt;sadd('pool', $id);
</code></pre>

<p>多めに見積もって1IDあたり1kB使うと仮定しても、1000個のIDで約1MBです。
余裕で全部メモリにのるので、オンメモリのRedisでも全く問題ありません。</p>

<p>しかし、この方法では、IDを受け取ったクライアントが突然死してしまった場合に
永遠にIDが開放されないため、そのうちIDが枯渇してしまいます。</p>

<p>そこで思いついたのが、ソート済みセット型を使ったExpire付き機能付きID配布です。
「ソート済みセットのスコアにExpireの予定時刻を入れる」というルールでIDを管理します。
ソート済みセットを使えば、「スコアが一番小さいID＝Expireしている可能性が一番高いID」
を簡単に取得できます。
現在時刻と比較して実際にExpireしているかをチェックし、ExpireしていたらID取得成功です。
Perlのコードに起こすと以下のようになります。</p>

<pre><code class="perl"># PoolにID追加
$redis-&gt;zadd('pool', time, "id$_") for 1..10;

# IDを取得
RETRY:
my ($id, $score) = $redis-&gt;zrange('pool', 0, 0, "WITHSCORE");

# expireしているかチェック
if $score &lt; time {
    # ID取得失敗、しばらく待ってID取得やり直し
    sleep 1;
    goto RETRY
}

# expireの期間延長
my $expire = 10; # 10秒でexpire
$redis-&gt;zadd('pool', time + $expire, $id);

# $idを使ったなにかの処理

# 使い終わったらExpire扱い
$redis-&gt;zadd('pool', time, $id);
</code></pre>

<p>クライアントが突然死していまうと、Expireが更新されないため
どんどんRankがあがっていき、最終的には別のクライアントに再利用されます。</p>

<p>この方法であれば、Expireしてからの期間が長いIDから再利用されるというのも利点です。
どうしてもサーバとクライアントで時刻のズレが生じてしまうので、
サーバはExpireした！と思っても、クライアントがまだ使用中ということは十分に考えられます。
そのためExpireしたIDをすぐに再利用してしまうと、多重使用になってしまう可能性があります。
Expireしてからの期間が長いIDから再利用することで、この問題を緩和できるというわけです。</p>

<p>(Googleさんみたいに分散データベース管理に原子時計を導入していれば話は別ですが・・・)</p>

<p>ソート済みセット型のScoreは64bitの浮動小数点型なので、
scoreにunix timestampを使うとマイクロ秒程度の精度になってしまいますが、
この用途であれば十分足りるでしょう。</p>

<h2>実装上の工夫</h2>

<p>このアイデアなら楽できる！と思ったものの、
実際にコードに起こすとなると考慮すべきことがたくさんあって大変でした。</p>

<h3>ID取得とExpire期間延長をアトミックにする</h3>

<p>先のコード例をそのまま実装すると同時アクセスがあった場合にIDプールが壊れます。
それを防ぐために
「IDを取得」「expireしているかチェック」「expireの期間延長」はアトミックに実行する必要があります。</p>

<p>Redisの場合、Luaスクリプトを使えば簡単ですね。
慣れないLuaに少し手こずりましたが、一度覚えてしまうと全部Luaにしたくなってしまう麻薬ですね、あれは。</p>

<h3>Luaスクリプト内で時刻を取得する</h3>

<p>このアイデアは時刻が肝なので、可能であれば時刻の管理もRedisサーバに一任したいところです。
しかし、Luaスクリプト内ではOS機能のモジュールが無効化されており、時刻の取得はできません。
ファイルもいじれる危ないモジュールなので仕方ないですね。</p>

<p>ではどうするかというと、LuaからRedisのTIMEコマンドを呼び出して時刻を取得します。
しかしながら、この方法も一筋縄ではいかず、何もせずに呼び出すとコマンドの実行に失敗してしまいます。</p>

<p>TIMEコマンドが失敗する原因はLuaスクリプトのレプリケーションの方法にあります。
Redisのレプリケーション方法は、マスターからスクリプトをまるごとスレーブに送り、スレーブ側でスクリプト再実行する方式です。
そのため、TIMEコマンドのように実行するタイミングによって結果が変わるコマンドは、
マスターとスレーブで不整合が起きてしまう可能性があるため実行できないのです。</p>

<p>この問題を解決するため、Redis3.2から <code>redis.replicate_commands</code> が追加されました。
この関数を呼び出すと、Luaスクリプト内で実行したRedisへの書き込みコマンドを転送するレプリケーション方式に変わります。
実行結果だけを送るのでTIMEコマンドも安全に実行できるというわけです。</p>

<pre><code class="lua">redis.replicate_commands()
local t = redis.call("TIME")
time = t[1] + t[2]*1e-6 -- 秒単位に変換
</code></pre>

<p>なお、<code>redis.replicate_commands</code>が使えない場合は、クライアントの時刻を使うようフォールバックするので、
3.2よりまえのRedisでも動作はします。</p>

<p>ちなみにレプリケーションの挙動を変えるコマンドは他にもあって、
<code>redis.set_repl</code>を使うとレプリケーション自体を止めることも出来るらしいです。
怖い。</p>

<h3>若い番号のIDから配布する</h3>

<p>これはあまり重要ではないんですが、Expireまでの期間が同じだった場合、
若い番号のIDから順に配布するようにしました。
「エライ人順にIPアドレスを設定しろ」みたいなアレなので、
別に考慮しなくてもいいんですが、数字を見ると順番に並べたくなってしまうのが人間というものです。</p>

<p>Redisのソート済みセットはスコアが同じ場合、メンバーの辞書順に並びます。
<code>Itoa(id)</code>した結果をそのまま辞書順ソートすると</p>

<pre><code class="plain">1, 10, 11, 12, ..., 2, 20, 21, ...
</code></pre>

<p>のようなおかしな順番になってしまいます。
そこで、「1桁のときは頭にAを付ける」「2桁のときはB」「3桁のときはC」&hellip;
と先頭の文字で数字の桁数が分かるようにしました。</p>

<pre><code class="plain">A1, A2, A3, ..., A9, B10, B11, B12, ... B99, C100, C101, C102, ...
</code></pre>

<p>この規則はRFC2550をヒントにしました。
RFC2550にはZまで使い切ったあとのことも書いてあるんですが、そこまではしていません。
可読性にこだわらなければ他にも方法はあるのですが、redis-cliで見れたほうが嬉しいじゃないですか。</p>

<ul>
<li><a href="https://tools.ietf.org/html/rfc2550">RFC 2550 Y10K and Beyond</a></li>
<li><a href="http://www.cam.hi-ho.ne.jp/mendoxi/rfc/rfc2550j.html">参考日本語訳 RFC 2550 Y10K とその先</a></li>
</ul>


<h3>レプリケーション完了を待つ</h3>

<p>可用性を求めるならば、Redisサーバー自体が突然死する可能性も考えなければなりません。
この問題に対応するにはマスタースレーブ構成を取るのが一般的でしょう。
マスタースレーブ構成ではフェールオーバー時に多少のデータ消失が起こる可能性があります。
レプリケーションが終わっていない分のデータが消失するためです。</p>

<p>キャッシュ用途であれば許容できるかもしれませんが、
ID配布でこれが起こるのは致命的です。
配布したIDをもとにデータベースへの書き込みを行うので、整合性が崩れ、修復困難なダメージを与えてしまう可能性があります。</p>

<p>この問題を最小限に抑えるために、2.8からWAITコマンドが追加されています。
WAITコマンドを使うと、今まで書き込んだデータがレプリケーションされたかを検出できます。</p>

<pre><code># ROLEコマンドでスレーブの台数を確認
127.0.0.1:6379&gt; ROLE
1) "master"
2) (integer) 83
3) 1) 1) "::1"     # 一台スレーブ
      2) "6378"
      3) "83"

# 適当に書き込み
127.0.0.1:6379&gt; SET foo bar
OK

# 1つのスレーブのレプリケーションが完了するのを待つ(Timeout 1000ms)
127.0.0.1:6379&gt; WAIT 1 1000
(integer) 1 # レプリケーションが完了したスレーブの台数
</code></pre>

<p>レプリケーションの完了＝コマンドの実行完了と解釈すれば、
データの消失を最小限に抑えることができます。</p>

<p>ちなみに、WAITコマンドのtimeoutはミリ秒ですが、今回使用した<a href="https://godoc.org/gopkg.in/redis.v5">go-redis/redis</a>は
これを秒として扱っていました。
(こういうのRedis::Fast開発時にもあった気がする)
単位重要ですね。
time.ParseDurationで時間指定をすると、毎回単位指定が必要になって面倒ですが、
こういうミスを防ぐためには有用そうです。
積極的に使っていきたい。</p>

<h3>横取り検出</h3>

<p>WAITコマンドでデータの消失を最小限にしたとしても、0にできるわけではありません。
消失が起こった場合の対応も必要です。
ID配布した記録が消えて横取りが出来る可能性があるので、
IDに所有者(貸出先の方が正しかったかも)を一緒に記録しておくことにしました。</p>

<p>各クライアントにクライアントIDを付与しておきます。(現状の実装はhostname+timestamp+連番)
横取りされた方は、自分のクライアントIDとIDの所有者を比較し、横取りが分かった時点で速やかにID開放します。
横取りした方は、ID取得からID使用までしばらく時間を開けます(-delayでこの時間は変更可能)
これは横取りされた方のID開放が終わるまで、猶予時間を与えるためです。</p>

<h2>動作条件等</h2>

<p>何度か書いていますが、このアイデアは時刻が肝です。
各サーバ間の時刻同期が正しく行われている必要があります。
普通にNTPを使っていればmsのオーダーで同期が取れるので問題ないでしょう。</p>

<p>・・・ただし、みんな大嫌いなうるう秒があります。
うるう秒の対応の仕方がまちまちなので、ことなった対応方針が適用されたサーバーが混ざると大変です。</p>

<p>例えば、マネージドなRedisとしてElastiCacheを使うと、
うるう秒挿入のタイミングでElastiCacheは<a href="http://aws.typepad.com/aws_japan/2015/05/look-before-you-leap-the-coming-leap-second-and-aws.html">AWS調整時刻</a>で動作します。
残念ながらAWS調整時刻を返すNTPは提供されていないようです。</p>

<p>デフォルトの設定はこの辺を考慮してマージンを取っているので大丈夫なはず・・・。
使う人がいるかはわかりませんが、検証頑張って！</p>

<h2>名前について</h2>

<p>「Yet Another Ranged Unique id Supplier」の略です。
いい名前が思いつかなかったので、fujiwaraさん製のRanged Unique id Supplierが既にあったのでそこから拝借しました。
Yet Anatherは、こう付けると流行ると「言語のしくみ」に書いてあったからです。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B01N7JZXMD&linkId=8ee3d3dfb649430b1d0abd35881e5f56"></iframe>


<h2>まとめ</h2>

<ul>
<li>RedisをID発番サーバID配布サーバとして活用する方法を考えてみました</li>
<li>可用性を求めていったらレプリケーションの高度な使い方がわかってきた

<ul>
<li><code>redis.replicate_commands</code>でスクリプトのレプリケーション方式を変更する</li>
<li>WAITコマンドでレプリケーションを待つ</li>
</ul>
</li>
<li>フェールオーバのこととか考えると全然楽じゃなかった・・・</li>
</ul>


<p>思いつきを試したかっただけなのですが、勉強になったので良しとしましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WEB+DB PRESS Vol.97にPerlとRedisの記事を寄稿しました]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/"/>
    <updated>2017-02-23T18:27:53+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97</id>
    <content type="html"><![CDATA[<p>昨年末に<a href="https://twitter.com/songmu">Songmu</a>さんからお話を頂き、
<a href="http://gihyo.jp/magazine/wdpress/archive/2017/vol97">WEB+DB PRESS Vol.97</a>内の連載「第43回Perl Hackers Hub」に
「PerlでのRedis活用法」というタイトルで寄稿しました。
発売日は<strong>2月24日</strong>です。</p>

<!-- More -->


<h2>内容</h2>

<p>簡単に内容を紹介しておきます。
Perl使いではじめてRedisを使う人向けに書いたつもりです。</p>

<h3>Redisの簡単な説明</h3>

<p>Redisのインストール方と、Perlからの接続方法、そしてRedisの型の説明です。
記事の中でも紹介していますが、Redisはその豊富な型が特長です。
読者はきっとPerl使いだろうということで、Perlの型(Perlにも型はあるんだよ！！)と
比較しながら簡単に紹介しています。</p>

<h3>Redisの応用例とCPANモジュールの紹介</h3>

<p>Redisを使うとこんなことができるよ、という紹介です。
CPANで公開されているRedis関連のモジュールも合わせて紹介しています。</p>

<h3>Redis自体の注意点</h3>

<p>以前Redisを使ったサービスの運用に携わっていたのですが、
そのなかで実際に起きたことを元に、Redisの注意点について書きました。
さいわいサービスが停止するような事故にはありませんでしたが、
メトリックスを眺めながらエンジニア勢でヤバイヤバイ騒いでましたね・・・。
みなさんも気をつけて下さい。</p>

<h2>執筆してみての感想</h2>

<p>昔から文章を書くのにはだいぶ苦手意識があり、
今回の執筆も非常に苦労しました。
一文の前半を書いた時点で
「今から書こうとしている情報は本当に必要なのか」
「自分の記憶違いで間違った情報なのでは」と不安になり、
色々考えているうちに、何書こうとしてたのかわからなくなるんですよね。
まずは適当に書き上げて、後からちゃんと推敲しよう、
とは思いつつもなかなか進められず・・・。
スループットを上げたい。</p>

<p>細かい表現とかも気になってなかなか進まないので、
こういうの入れて頑張ろうと思います！</p>

<ul>
<li><a href="http://qiita.com/azu/items/2c565a38df5ed4c9f4e1">VS Codeでtextlintを使って文章をチェックする</a></li>
<li><a href="http://takemikami.com/2017/02/14/gitbook.html">gitbookで技術書を書く環境の構築手順</a></li>
</ul>


<p>(執筆が進まないと、こういう環境構築に時間をかけてしまうのもよくないと思うんだ・・・)</p>

<h2>余談</h2>

<p>ところで、<strong>Vol.97</strong>と<strong>第43回</strong>ってどっちも<strong>素数</strong>ですね！
雑なプログラムを書いて調べてみたところ、
両方素数になるのはVol.83, 第29回以来、<strong>7回目</strong>(これも<strong>素数</strong>だ！)。
次はVol.101, 第47回です。
そのときのPerl Hackerは誰になるのでしょうか。楽しみですね！</p>

<pre><code class="perl">use warnings;
use strict;

sub is_prime {
    my $n = shift;
    return 0 if $n &lt; 2;
    my $i = 2;
    while($i*$i&lt;=$n) {
        return 0 if $n % $i == 0;
        $i++;
    }
    return 1;
}

my $i = 1;
for my $n(1..200) {
    my $m = $n-43+97;
    if (is_prime($n) &amp;&amp; is_prime($m)) {
        printf "%3d: Vol.%3d, No.%3d\n", $i, $m, $n;
        $i++;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを公開しました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules/"/>
    <updated>2016-03-18T22:16:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules</id>
    <content type="html"><![CDATA[<p>以前<a href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/">Redisでスコアを複数設定できるランキングを作ってみた</a>けど、
Githubの肥やしになっていてもあれなので、CPANizeしました。
あわせて、この実装のために作ったユーティリティモジュールも別モジュールとして公開しました。</p>

<ul>
<li><a href="https://metacpan.org/pod/Redis::LeaderBoardMulti">Redis::LeaderBoardMulti</a></li>
<li><a href="https://metacpan.org/pod/Redis::Script">Redis::Script</a></li>
<li><a href="https://metacpan.org/pod/Redis::Transaction">Redis::Transaction</a></li>
</ul>


<!-- More -->


<h2>Redis::LeaderBoardMulti</h2>

<p>最初の基準で順位を決められなかった場合の第二基準が欲しいというときに使うモジュールです。
インターフェースがRedis::LeaderBoard互換になるように調整したので、
前回とインターフェースがちょっと変わっています。</p>

<pre><code class="perl">se Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
# Redis::LeaderBoardに合わせて複数指定できるようになりました
$lb-&gt;set_score(
    'one' =&gt; [100, time],
    'two' =&gt; [ 50, time],
);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p>Redis::LeaderBoard互換なのでそのまま入れ替えられるはずですが、以下のような実装上の制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
<li>同順の場合の出現順

<ul>
<li>Redis::LeaderBoard は ZRANK, ZREVRANK を使い分けているので、orderパラメータによって昇順/降順が変わります</li>
<li>Redis::LaederBoardMulti は ZRANK しか使わないので、必ず昇順になります</li>
</ul>
</li>
</ul>


<p>一応 Lua Script を使わないオプションもそのまま残してありますが、特に理由がない限りデフォルト(Lua Script を使う)で使うといいと思います。
どうしてもロックの範囲が広くなってしまう場合があり、楽観的ロックでは効率が悪いケースがあるためです。</p>

<h2>Redis::Script</h2>

<p>EVALSHAを簡単に使うためのモジュールです。
EVALコマンドを使うとLua Scriptの実装ができますが、毎回毎回実行するスクリプト全体を送る必要があります。
EVALSHAコマンドはその代わりにスクリプトのSHA1ハッシュを送ることで、帯域の節約ができるというコマンドです。
しかしEVALSHAはSHA1ハッシュを事前に登録する必要があり、どのタイミングで登録を行うかが問題になってきます。</p>

<p><a href="http://redis.io/commands/eval">EVALコマンドのドキュメント</a>によると、
「EVALSHAで実行してみて <code>NOSCRIPT No matching script</code> で失敗したらEVALでやり直す」というのがおすすめらしいです。
EVALコマンドはSHA1ハッシュの登録も行ってくれるので、初回 <code>NOSCRIPT</code> になっても次回からはEVALSHAが成功します。</p>

<p>そんなに複雑なことではないのですが、毎回書くのも大変なのでモジュールとして切り出したのが Redis::Script です。
以下のようにスクリプトオブジェクトを作っておいて、パラメータを渡して実行します。</p>

<pre><code class="perl">use Redis;
use Redis::Script;
my $script = Redis::Script-&gt;new(script =&gt; "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}");
my ($key1, $key2, $arg1, $arg2) = $script-&gt;eval(Redis-&gt;new, ['key1', 'key2'], ['arg1', 'arg2']);
</code></pre>

<p><code>$script</code> が計算済みのSHA1ハッシュを保存しておいてくれるので、計算リソースの節約にもなるはずです。
(ベンチとってみたところ、スクリプトのサイズが1kBから10kBくらいにならないと効果なさそうでしたが・・・)</p>

<h2>Redis::Transaction</h2>

<p>Redisのトランザクションを簡単に行うためのモジュールです。</p>

<p>MULTI-EXECは単に実行するだけなら、MULTIとEXECで囲うだけでよいので簡単です。
例えば、 <code>foo</code> と <code>bar</code> を同時にインクリメントしたい場合、以下のようにすると実現できます。</p>

<pre><code class="perl">$redis-&gt;multi;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
$redis-&gt;exec; # 他のクライアントからはfooとbarが全く同時にインクリメントされたように見える
</code></pre>

<p>ただ、このような素朴な実装だと、途中でネットワークが不調になった場合などに再接続処理が止まったままになる可能性があります。
例えば以下のようにトランザクションの中で例外が発生すると、以後そのコネクションを使おうとしたときにエラーになります。
コネクションの永続化をしている場合はしばらくエラーが出続けることになり問題です。</p>

<pre><code class="perl">eval {
    $redis-&gt;multi; # トランザクション開始
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
    $redis-&gt;exec;
};
$redis-&gt;ping; # 繋がらなくなる
</code></pre>

<p>Redis::Transaction はこのような問題を防ぐためのモジュールです。
トランザクションが失敗したときの後始末をよしなにやってくれるので、万が一エラーになっても安心です。</p>

<pre><code class="perl">multi_exec Redis-&gt;new, 1, sub { # 1は失敗したときのリトライ回数
    my $redis = shift;
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
};
$redis-&gt;ping; # 繋がる！
</code></pre>

<p>WATCH-MULTI-EXECを使った楽観的ロックも扱えます。
Redisのトランザクションは楽観的ロックなので、
処理中に他のクライアントが書き換えを行った場合に失敗する可能性があります。
その場合でもリトライを行ってくれて便利です。</p>

<pre><code class="perl"># $redis-&gt;incr('mykey') をトランザクションを使って実現する
watch_multi_exec Redis-&gt;new, ['mykey'], 10, sub {
    my $redis = shift;
    return $redis-&gt;get('mykey');
}, sub {
    my ($redis, $value) = @_;
    $redis-&gt;set('mykey', $value + 1);
};
</code></pre>

<h2>まとめ</h2>

<p>Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを紹介しました。
それぞれは小さなモジュールですが、
トラブル発生時にも問題にならないようちゃんとした実装しようとすると、
意外と考えることが多く面倒なものです(特にトランザクション周りとか)。
適当に実装してしまったこころ当たりのある人は、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisでスコアを複数設定できるランキングを作ってみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/"/>
    <updated>2016-02-06T02:30:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi</id>
    <content type="html"><![CDATA[<p>ランキングを作っているとスコアを複数設定したいことがよくあると思います。
例えば「得点が同じだったら早くその得点を出した人優先」とか「勝ち点が同じだったら得失点差が大きい方優先」とかのように、
最初の基準で順位を決められなかった場合の第二基準が欲しいみたいな場合です。</p>

<p>ランキングを作るのにはRedisのSorted Setを使うのが便利ですが、残念ながらSorted Setはひとつしかスコアを設定できません。
少し前にどうやったら実装できるかと社内チャットで話題に上ったので、試しにRedis::LeaderBoardMulti(仮名)という名前で書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/p5-Redis-LeaderBoardMulti">shogo82148/p5-Redis-LeaderBoardMulti</a></li>
</ul>


<!-- More -->


<h2>使い方</h2>

<p>メソッドの名前は<a href="http://www.songmu.jp/riji/archives/2013/06/redisleaderboar.html">Redis::LeaderBoard</a>にあわせてありますが、
スコアが複数指定できるようになった関係でちょっと変わってます。</p>

<pre><code class="perl">use Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
$lb-&gt;set_score('one' =&gt; 100, time); # 第二基準は時間=得点が同じだったら早くその得点を出した人優先
$lb-&gt;set_score('two' =&gt;  50, time);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p><code>set_score</code>の第二引数以降はすべてスコアとして扱われます。(そのためRedis::LeaderBoardと互換性はない)
上の例では「得点が同じだったら早くその得点を出した人優先」になってます。</p>

<h2>制限事項</h2>

<p>実装の都合により、以下のような制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数です

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
</ul>


<h2>実装の仕組み</h2>

<p>Sorted Setの同じスコアを持つメンバーは辞書順にソートされます(zaddの<a href="http://redis.io/commands/zadd#elements-with-the-same-score">同じスコアを持つ要素</a>の項を参照)。
例えば以下の様にメンバー「a」「b」「c」を追加すると、必ず「abc」の順番になることが保証されています。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "a" 0 "b" 0 "c"
(integer) 3
127.0.0.1:6379&gt; ZRANK ranking "b"
(integer) 1
</code></pre>

<p>これを利用して、メンバーの先頭にスコアをエンコードして付けておきます。
もちろんエンコードしたあとでもスコアの大小関係が保たれている必要があります。
以下はエンコード方式にビッグエンディアンの16bit整数を使った例です。
Redis 2.8.9から辞書順比較に特化したコマンド(LEXがつくやつ)が追加されているので、
ランクを求める処理は以下のように書くことができます。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x02b"    (bをスコア2で追加)
(integer) 1
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x01a"    (aをスコア1で追加)
(integer) 1
127.0.0.1:6379&gt; ZLEXCOUNT ranking - "(\x00\x02"    (スコア2未満の個数=bのランク)
(integer) 1
</code></pre>

<p>さすがに16bit符号なし整数だと範囲が狭いので、実際の実装は以下のようになっています。</p>

<ul>
<li>エンコードはビッグエンディアンの64bit符号付き整数</li>
<li>負数も扱えるように下駄を履かせる

<ul>
<li>1と-1を単純にエンコードすると-1の方が大きくなってしまう</li>
<li>0x8000000000000000を足して符号なし整数の範囲で比較できるように補正</li>
</ul>
</li>
</ul>


<h2>アトミック性について</h2>

<p>この方法だとSorted Setだけでは現在のスコアを取得できないので、
スコアだけ別管理にする必要があります。
スコアの更新とランキングの更新があるので、
片方だけ更新される状況がないようにアトミック性に注意する必要があります。
更新途中の間違った結果を返すだけならすぐに復旧するのでまだマシですが、
途中でネットワーク障害が起こって不整合なデータが残ってしまうと面倒です。</p>

<p>アトミック性を確保するためのパターンをいくつか実装してみました。
<code>use_script</code>と<code>use_hash</code>で制御が可能です。</p>

<h3>トランザクションを使った方法</h3>

<p>Redisには<a href="http://redis.io/topics/transactions">トランザクション</a>の仕組みがあるのでこれを使った方法です。
<code>use_script=&gt;0</code>が指定されるとこの方法で更新を行います。</p>

<pre><code class="plain">127.0.0.1:6379&gt; WATCH ranking:a   (他のクライアントが更新を行っていないか監視)
OK
127.0.0.1:6379&gt; GET ranking:a   (ranking:aに入っている現在のスコアを取得)
"\x00\x01"
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; ZREM ranking "\x00\x01a"
QUEUED
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x03a"
QUEUED
127.0.0.1:6379&gt; SET ranking:a "\x00\x03"
QUEUED
127.0.0.1:6379&gt; EXEC   (スコアの更新とランキングの更新をアトミックに行う)
1) (integer) 1
2) (integer) 1
3) OK
</code></pre>

<p>Redisのトランザクションは楽観的ロックなので、他のクライアントがスコアを更新していると失敗する場合があります。
失敗した場合はリトライが必要です。
(この機構、いろいろと注意点があって毎回実装するのはつらすぎるので、別モジュールとして分離したいけど、いい名前とインターフェース募集中)</p>

<p><code>use_hash=&gt;1</code>が指定されていると、スコアの記録にHashを使います。
「Hashの特定のキーの更新をWATCHする」という命令はないため、ランキング全体を<code>WATCH</code>で監視します。
(<code>use_hash=&gt;0</code>の場合、そのメンバのスコアだけ監視する)</p>

<h3>Luaスクリプトを使った方法</h3>

<p>RedisはLuaスクリプトを実行する機能があります。
Luaスクリプト実行中は他の命令の実行をブロックするので、アトミック性が確保されます。</p>

<pre><code class="lua">local s=redis.call('GET', 'ranking:a')
if s then
  redis.call('ZREM', 'ranking', s..'a')
end
redis.call('ZADD', 'ranking', 0, '\x00\x03a')
redis.call('SET', 'ranking:a', '\x00\x03')
</code></pre>

<p>Luaスクリプトを実行するには<code>EVAL</code>と<code>EVALSHA</code>の二種類のコマンドがあります。
<code>EVALSHA</code>は転送量を抑えられて便利ですが、事前に<code>SCRIPT LOAD</code>で使うスクリプトを登録しておく必要があります。
(ココらへんも別モジュールに分離したいけど、いい名前とインターフェース募集中)
<code>use_evalsha</code>オプションでどちらを使うか制御可能です。</p>

<p>ちなみに<code>EVAL</code>で実行したスクリプトも<a href="http://redis.io/commands/eval#script-cache-semantics">永遠にキャッシュされる</a>らしいです。
上の例はわかりやすいようにキー名や値を直接埋め込んでいますが、同じことをしようとLuaスクリプトの動的生成なんてすると死にます。
スクリプト内で<code>KEYS</code>や<code>ARGV</code>を使うと<code>EVAL</code>時にパラメータを渡せるようになるので、これを活用しましょう。</p>

<h3>諦める</h3>

<p><a href="https://metacpan.org/pod/Redis::LeaderBoard">Redis::LeaderBoard</a>の実装を見て気がついたんですが、
<code>get_rank</code>の実装は「スコアの取得」「スコアに対応するランクの取得」がアトミックでないため、
以下の条件を満たすと実際のランクより1大きい結果を返します。</p>

<ul>
<li>同じメンバーのスコア更新とランク取得が同時に行われる</li>
<li>ランクが上がるようにスコアが更新される</li>
</ul>


<p>確かに厳密性は欠けますがたかだか1結果が変わるだけですし、
そもそも更新と取得が同時に行われないようにモジュールを使う側が排他制御するべきですね。
こういうケースでは諦めるというのも一つの手かなと思いました。
もちろんデータの整合性が壊れる場合は頑張ってアトミック性を確保するべきでしょう。</p>

<h2>まとめ</h2>

<ul>
<li>Redisでランキングをつくる際に、スコアを複数設定する方法を紹介しました</li>
<li>アトミック性を確保する方法を紹介しました

<ul>
<li>トランザクションを使った方法</li>
<li>Luaスクリプトを使った方法</li>
<li>諦める</li>
</ul>
</li>
</ul>


<p>もうちょっとドキュメントを整備したらCPANにあげてみますかね。
トランザクション管理・Luaスクリプト管理も分離したい(いい名前を思いついたら)。
「こんな名前がいい！」「こんなインターフェースがいい！」等あればコメントください。</p>
]]></content>
  </entry>
  
</feed>
