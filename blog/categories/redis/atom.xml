<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/redis/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2013-09-20T23:22:50+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis::NamespaceのPerl版書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/09/14/redis-namespace-perl/"/>
    <updated>2013-09-14T18:36:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/09/14/redis-namespace-perl</id>
    <content type="html"><![CDATA[<p><a href="http://redis.io/">Redis</a> のキーにプリフィックスつけるの面倒だなー自動的につけてくれないかなーと思い、
調べてみると Ruby に <a href="https://github.com/resque/redis-namespace">Redis-Namespace</a> というものがあるらしい。
だけども、Perl では探しても見つからなかったので書いてみた。</p>

<p>レポジトリはこちら→<a href="https://github.com/shogo82148/Redis-Namepace">Redis::Namespace</a></p>

<!-- More -->


<h2>使い方</h2>

<p>インターフェースは <a href="http://search.cpan.org/~melo/Redis/">Perl Redis</a> と一緒。
コマンドのキー名に当たる部分に、自動的にプレフィックスをつけてくれる。</p>

<p>``` perl
use Redis;
use Redis::Namespace;</p>

<p>my $redis = Redis->new;
my $ns = Redis::Namespace(redis => $redis, namespace => 'fugu');</p>

<p>$ns->set('foo', 'bar');    # $redis->set('fugu:foo', 'bar');
my $foo = $ns->get('foo'); # my $foo = $redis->get('fugu:foo');
```</p>

<p>大体のコマンドには対応したつもり。
別のプレフィックスがついたキーには基本的にアクセスできなくなるので、
キー名の管理が少し楽になると思います。</p>

<p>でも、flushdb とか flushall すると全部消えるので気をつけてね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl の Redis ライブラリを調べた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/08/24/perl-redis-libraries/"/>
    <updated>2013-08-24T17:51:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/08/24/perl-redis-libraries</id>
    <content type="html"><![CDATA[<p>最近<a href="http://redis.io/">Redis</a> を使ったコードを書くようになったのですが、
キー名を毎回指定するのがだるいです。
Ruby には <a href="https://github.com/nateware/redis-objects">redis-objects</a> というのがあって、
Redisのキーをオブジェクトとして扱うことができるようです。
きっと、Perl にも似たようなのあるだろ、って思って調べてみました。</p>

<!-- More -->


<h2>ほしいもの</h2>

<p>低レベルなRedisのライブラリはたいていメソッドとRedisのコマンドが一対一対応していて、
次のようなコードになると思います。</p>

<p><code>perl hogehoge.pl
$redis-&gt;set('key-name', 'piyopiyo');
$redis-&gt;get('key_name');
</code></p>

<p>でも、Redisに何か操作をしたいわけじゃなくて、
Redisのキーに対して操作をしたいので、
次のように書けるべきだと思うんです。</p>

<p><code>perl expected.pl
my $key = key($redis, 'key-name');
$key-&gt;set('piyopiyo');
$key-&gt;get();
</code></p>

<h2>Redis::Hash, Redis::List</h2>

<p><a href="http://search.cpan.org/~melo/Redis/lib/Redis/Hash.pm">Redis::Hash</a>と
<a href="http://search.cpan.org/~melo/Redis/lib/Redis/List.pm">Redis::List</a>は
Perlのハッシュや配列と同じ操作で Redis にアクセスできるようにするライブラリ。</p>

<p>``` perl Redis::Hash
use utf8;
use warnings;
use strict;
use 5.014;</p>

<p>use Redis::Hash;</p>

<p>tie my %my_hash, 'Redis::Hash', 'hash_prefix', (server => 'localhost:6379');</p>

<h1>set hash_prefix:hogehoge piyopiyo</h1>

<h1>set hash_prefix:fugafuga fugufugu</h1>

<p>$my_hash{hogehoge} = 'piyopiyo';
$my_hash{fugafuga} = 'fugufugu';</p>

<h1>get hash_prefix:hogehoge piyopiyo</h1>

<p>say $my_hash{hogehoge}; # piyopiyo</p>

<h1>keys hash_prefix:*</h1>

<p>say join ',', keys %my_hash; #fugafuga,hogehoge</p>

<h1>keys hash_prefix:*</h1>

<h1>get hash_prefix:fugafuga</h1>

<h1>get hash_prefix:hogehoge</h1>

<p>say join ',', values %my_hash; #fugufugu,piyopiyo</p>

<h1>del hash_prefix:hogehoge</h1>

<p>delete $my_hash{hogehoge};
```</p>

<p>tie とかよくわかない。
Perl の黒魔術を見た気がしました。</p>

<p>普通のハッシュや配列に見えるのは面白いけど、
Redisっぽい機能がまったく使えないのはつらい。
<code>tied(%my_hash)-&gt;cmd</code> って書けばコマンド発行できるけど、
それなら最初から直接 <a href="http://search.cpan.org/~melo/Redis/lib/Redis.pm">Redis.pm</a> を
使えよって話になります。</p>

<p>あと、tie するごとにコネクションを張り直しているようなので、
たくさんのハッシュやリストを作ると大変なことになりそうです。</p>

<h2>Redis::Client</h2>

<p>これも tie すると、Redis上のデータをハッシュや配列として扱うことができます。
tie できるのは <a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/String.pm">String</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/List.pm">List</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Hash.pm">Hash</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Set.pm">Set</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Zset.pm">Zset</a>。
それぞれがRedisで使えるデータ型に対応している。</p>

<p>``` perl Redis::Client::String
use utf8;
use warnings;
use strict;
use 5.014;</p>

<p>use Redis::Client;</p>

<p>my $client = Redis::Client->new;
tie my $str, 'Redis::Client::String', key => 'my_string', client => $client;</p>

<p>$str = 'foo';
say $str;
```</p>

<p>ひとつのキーに対してひとつのオブジェクトを割り当てるのは良さげ。
また、ハッシュ型、セット型、ソート済みセット型といった、Redis特有のデータ型に対応しているのもGood。
でも、ただストアするだけならこれで十分だけど、もう少し高度な機能も使いたい・・・。</p>

<h2>Tie::Redis</h2>

<p><a href="http://search.cpan.org/~dgl/Tie-Redis/lib/Tie/Redis/Hash.pm">Tie::Redis</a> も
tie を使ってPerlのデータ構造っぽく扱えるようにするライブラリ。</p>

<p>Redis全体を一つのハッシュとして扱ったり、
Redisの文字列型、ハッシュ型、リスト型を扱えるみたい。</p>

<h2>Redis::Object</h2>

<p><a href="http://search.cpan.org/~ukautz/Redis-Object/README.pod">Redis::Oject</a>は
ORM風なRedis用ライブラリ。</p>

<p>``` perl RedisDatabase.pm
package MyRedisDatabase;</p>

<p>use Moose;
extends qw/ Redis::Object /;</p>

<p>has tables => (</p>

<pre><code>isa     =&gt; 'ArrayRef[Str]',
is      =&gt; 'ro',
default =&gt; sub { [ qw/SomeTable/ ] },
</code></pre>

<p>);</p>

<p><strong>PACKAGE</strong>->meta->make_immutable;
```</p>

<p>``` perl RedisDatabase/SomeTable.pm
package MyRedisDatabase::SomeTable;</p>

<p>use Moose;
with qw/ Redis::Object::Table /;</p>

<p>has hoge => ( isa => 'Str', is => 'rw', default => 'Something' );</p>

<p><strong>PACKAGE</strong>->meta->make_immutable;
```</p>

<p>``` perl redis-object.pl
use utf8;
use strict;
use warnings;
use 5.014;</p>

<p>use MyRedisDatabase;</p>

<h1>init database</h1>

<p>my $db = MyRedisDatabase->new(</p>

<pre><code>server =&gt; 'localhost:6379'
</code></pre>

<p>);</p>

<h1>create item</h1>

<p>my $item = $db->create( SomeTable => {</p>

<pre><code>hoge =&gt; "Hello",
</code></pre>

<p>} );</p>

<h1>fetch item by id</h1>

<p>$item = $db->find( SomeTable => $item->id );</p>

<h1>update item</h1>

<p>$item->hoge( "piyo" );
```</p>

<p>ORMっぽいけど、あんまり複雑な検索はできないらしい。
ここまでするなら普通にMySQLとORMつかったほうが良さそう。</p>

<h2>まとめ</h2>

<p>みんな tie が大好き。</p>

<p>tie しないのがほしいな・・・。</p>
]]></content>
  </entry>
  
</feed>
