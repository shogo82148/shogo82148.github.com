<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/redis/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-03-17T22:26:36+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redisを使ってユニークなIDを配布する]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis/"/>
    <updated>2017-02-26T19:37:45+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/26/unique-id-supplier-using-redis</id>
    <content type="html"><![CDATA[<p>スケーラブルにIDを生成する方法として
Twitterの<a href="https://github.com/twitter/snowflake">snowflake</a>が有名です。
1024台までスケールすることが出来ますが、各snowflakeのサーバにユニークなWoker IDを割り振る必要があります。
IDを振るためのサーバにIDを振るのが問題になるとは難しいですね。</p>

<p>各snowflakeサーバにIDを振る親玉Worker ID配布サーバを作るというアイデアはあったのですが、
Worker IDサーバの可用性を考えるのが大変で手を付けていませんでした。
最近になってWorker IDサーバとしてRedisを使い、ソート済みセット型で管理すれば楽できるのでは？
と思いついたので、やってみたというお話です。</p>

<!-- More -->


<h2>概要</h2>

<p>レポジトリはこちらです。</p>

<ul>
<li><a href="https://github.com/shogo82148/yaraus">shogo82148/yaraus</a></li>
</ul>


<p>他の<a href="https://github.com/twitter/snowflake">snowflake</a>-likeなID発番サーバの実装として
<a href="http://techblog.kayac.com/katsubushi-introduction.html">katsubushi</a>や
<a href="https://github.com/sony/sonyflake">sonyflake</a>なんていうのもあります。
これらのID発番サーバにRedisを使ってWorker IDを割り振るコマンドです。
Redis3.2以上推奨です。</p>

<h2>使い方</h2>

<p>Go製なので<code>go get</code>でインストールできます。</p>

<pre><code class="bash">go get github.com/shogo82148/yaraus/cmd/yaraus
</code></pre>

<pre><code class="bash"># 1から1023までのIDが使えるようにRedisを初期化
$ yaraus init -min 1 -max 1023

# ユニークなIDが必要な処理を実行する
$ yaraus run -- echo {}
2017/02/25 17:19:16 getting new id...
2017/02/25 17:19:16 client id: YourHostName-1488010756.738-1, id: 1
2017/02/25 17:19:16 sleep 2s for making sure that other generates which has same id expire.
2017/02/25 17:19:18 starting...
1
2017/02/25 17:19:18 releasing id...

# katsubushiと一緒に使う例
$ yaraus run -- ./katsubushi -worker-id={} -port=7238

# ステータス情報もとれます
$ yaraus stats
{
    "client_id_count": 4,
    "client_get_id_count": 4,
    "client_get_id_success": 4,
    "get_id_no_available_id": 0,
    "extend_ttl_count": 8,
    "extend_ttl_success": 8,
    "extend_ttl_ownership_error": 0,
    "extend_ttl_expire_warning": 0,
    "unusing_ids": 1023,
    "using_ids": 0,
    "using_ttl_max": 0,
    "using_ttl_mid": 0,
    "using_ttl_min": 0
}
</code></pre>

<p>ステータスの意味は以下の通りです。</p>

<ul>
<li><code>client_id_count</code>: 今までに接続してきたクライアントの延べ数</li>
<li><code>client_get_id_count</code>: ID取得を試みた回数</li>
<li><code>client_get_id_success</code>: ID取得に成功した回数</li>
<li><code>get_id_no_available_id</code>: 利用可能なIDが無くて失敗した回数</li>
<li><code>extend_ttl_count</code>: Expireを伸ばそうと試みた回数</li>
<li><code>extend_ttl_success</code>: Expireを伸ばすのに成功した回数</li>
<li><code>extend_ttl_ownership_error</code>: IDが横取りされた回数</li>
<li><code>extend_ttl_expire_warning</code>: IDが横取りされそうだったのを防いだ回数</li>
<li><code>unusing_ids</code>: 未使用のIDの数</li>
<li><code>using_ids</code>: 使用中のIDの数</li>
<li><code>using_ttl_max</code>: IDの寿命の最大値(秒単位)</li>
<li><code>using_ttl_mid</code>: IDの寿命の中央値(秒単位)</li>
<li><code>using_ttl_min</code>: IDの寿命の最小値(秒単位)</li>
</ul>


<h2>実装アイデア</h2>

<p>Redisのセット型を使えば、ID配布自体は簡単です。
Perlでの実装は以下のようになります。(Go実装なのに例がPerlなのは、僕が一番慣れているので・・・)</p>

<pre><code class="perl"># あらかじめPoolにIDを蓄えておく
$redis-&gt;sadd('pool', "id$_") for 1..10;

# ランダムに選ぶ
my $id = $redis-&gt;spop('pool');

# 使い終わったら戻す
$redis-&gt;sadd('pool', $id);
</code></pre>

<p>多めに見積もって1IDあたり1kB使うと仮定しても、1000個のIDで約1MBです。
余裕で全部メモリにのるので、オンメモリのRedisでも全く問題ありません。</p>

<p>しかし、この方法では、IDを受け取ったクライアントが突然死してしまった場合に
永遠にIDが開放されないため、そのうちIDが枯渇してしまいます。</p>

<p>そこで思いついたのが、ソート済みセット型を使ったExpire付き機能付きID配布です。
「ソート済みセットのスコアにExpireの予定時刻を入れる」というルールでIDを管理します。
ソート済みセットを使えば、「スコアが一番小さいID＝Expireしている可能性が一番高いID」
を簡単に取得できます。
現在時刻と比較して実際にExpireしているかをチェックし、ExpireしていたらID取得成功です。
Perlのコードに起こすと以下のようになります。</p>

<pre><code class="perl"># PoolにID追加
$redis-&gt;zadd('pool', time, "id$_") for 1..10;

# IDを取得
RETRY:
my ($id, $score) = $redis-&gt;zrange('pool', 0, 0, "WITHSCORE");

# expireしているかチェック
if $score &lt; time {
    # ID取得失敗、しばらく待ってID取得やり直し
    sleep 1;
    goto RETRY
}

# expireの期間延長
my $expire = 10; # 10秒でexpire
$redis-&gt;zadd('pool', time + $expire, $id);

# $idを使ったなにかの処理

# 使い終わったらExpire扱い
$redis-&gt;zadd('pool', time, $id);
</code></pre>

<p>クライアントが突然死していまうと、Expireが更新されないため
どんどんRankがあがっていき、最終的には別のクライアントに再利用されます。</p>

<p>この方法であれば、Expireしてからの期間が長いIDから再利用されるというのも利点です。
どうしてもサーバとクライアントで時刻のズレが生じてしまうので、
サーバはExpireした！と思っても、クライアントがまだ使用中ということは十分に考えられます。
そのためExpireしたIDをすぐに再利用してしまうと、多重使用になってしまう可能性があります。
Expireしてからの期間が長いIDから再利用することで、この問題を緩和できるというわけです。</p>

<p>(Googleさんみたいに分散データベース管理に原子時計を導入していれば話は別ですが・・・)</p>

<p>ソート済みセット型のScoreは64bitの浮動小数点型なので、
scoreにunix timestampを使うとマイクロ秒程度の精度になってしまいますが、
この用途であれば十分足りるでしょう。</p>

<h2>実装上の工夫</h2>

<p>このアイデアなら楽できる！と思ったものの、
実際にコードに起こすとなると考慮すべきことがたくさんあって大変でした。</p>

<h3>ID取得とExpire期間延長をアトミックにする</h3>

<p>先のコード例をそのまま実装すると同時アクセスがあった場合にIDプールが壊れます。
それを防ぐために
「IDを取得」「expireしているかチェック」「expireの期間延長」はアトミックに実行する必要があります。</p>

<p>Redisの場合、Luaスクリプトを使えば簡単ですね。
慣れないLuaに少し手こずりましたが、一度覚えてしまうと全部Luaにしたくなってしまう麻薬ですね、あれは。</p>

<h3>Luaスクリプト内で時刻を取得する</h3>

<p>このアイデアは時刻が肝なので、可能であれば時刻の管理もRedisサーバに一任したいところです。
しかし、Luaスクリプト内ではOS機能のモジュールが無効化されており、時刻の取得はできません。
ファイルもいじれる危ないモジュールなので仕方ないですね。</p>

<p>ではどうするかというと、LuaからRedisのTIMEコマンドを呼び出して時刻を取得します。
しかしながら、この方法も一筋縄ではいかず、何もせずに呼び出すとコマンドの実行に失敗してしまいます。</p>

<p>TIMEコマンドが失敗する原因はLuaスクリプトのレプリケーションの方法にあります。
Redisのレプリケーション方法は、マスターからスクリプトをまるごとスレーブに送り、スレーブ側でスクリプト再実行する方式です。
そのため、TIMEコマンドのように実行するタイミングによって結果が変わるコマンドは、
マスターとスレーブで不整合が起きてしまう可能性があるため実行できないのです。</p>

<p>この問題を解決するため、Redis3.2から <code>redis.replicate_commands</code> が追加されました。
この関数を呼び出すと、Luaスクリプト内で実行したRedisへの書き込みコマンドを転送するレプリケーション方式に変わります。
実行結果だけを送るのでTIMEコマンドも安全に実行できるというわけです。</p>

<pre><code class="lua">redis.replicate_commands()
local t = redis.call("TIME")
time = t[1] + t[2]*1e-6 -- 秒単位に変換
</code></pre>

<p>なお、<code>redis.replicate_commands</code>が使えない場合は、クライアントの時刻を使うようフォールバックするので、
3.2よりまえのRedisでも動作はします。</p>

<p>ちなみにレプリケーションの挙動を変えるコマンドは他にもあって、
<code>redis.set_repl</code>を使うとレプリケーション自体を止めることも出来るらしいです。
怖い。</p>

<h3>若い番号のIDから配布する</h3>

<p>これはあまり重要ではないんですが、Expireまでの期間が同じだった場合、
若い番号のIDから順に配布するようにしました。
「エライ人順にIPアドレスを設定しろ」みたいなアレなので、
別に考慮しなくてもいいんですが、数字を見ると順番に並べたくなってしまうのが人間というものです。</p>

<p>Redisのソート済みセットはスコアが同じ場合、メンバーの辞書順に並びます。
<code>Itoa(id)</code>した結果をそのまま辞書順ソートすると</p>

<pre><code class="plain">1, 10, 11, 12, ..., 2, 20, 21, ...
</code></pre>

<p>のようなおかしな順番になってしまいます。
そこで、「1桁のときは頭にAを付ける」「2桁のときはB」「3桁のときはC」&hellip;
と先頭の文字で数字の桁数が分かるようにしました。</p>

<pre><code class="plain">A1, A2, A3, ..., A9, B10, B11, B12, ... B99, C100, C101, C102, ...
</code></pre>

<p>この規則はRFC2550をヒントにしました。
RFC2550にはZまで使い切ったあとのことも書いてあるんですが、そこまではしていません。
可読性にこだわらなければ他にも方法はあるのですが、redis-cliで見れたほうが嬉しいじゃないですか。</p>

<ul>
<li><a href="https://tools.ietf.org/html/rfc2550">RFC 2550 Y10K and Beyond</a></li>
<li><a href="http://www.cam.hi-ho.ne.jp/mendoxi/rfc/rfc2550j.html">参考日本語訳 RFC 2550 Y10K とその先</a></li>
</ul>


<h3>レプリケーション完了を待つ</h3>

<p>可用性を求めるならば、Redisサーバー自体が突然死する可能性も考えなければなりません。
この問題に対応するにはマスタースレーブ構成を取るのが一般的でしょう。
マスタースレーブ構成ではフェールオーバー時に多少のデータ消失が起こる可能性があります。
レプリケーションが終わっていない分のデータが消失するためです。</p>

<p>キャッシュ用途であれば許容できるかもしれませんが、
ID配布でこれが起こるのは致命的です。
配布したIDをもとにデータベースへの書き込みを行うので、整合性が崩れ、修復困難なダメージを与えてしまう可能性があります。</p>

<p>この問題を最小限に抑えるために、2.8からWAITコマンドが追加されています。
WAITコマンドを使うと、今まで書き込んだデータがレプリケーションされたかを検出できます。</p>

<pre><code># ROLEコマンドでスレーブの台数を確認
127.0.0.1:6379&gt; ROLE
1) "master"
2) (integer) 83
3) 1) 1) "::1"     # 一台スレーブ
      2) "6378"
      3) "83"

# 適当に書き込み
127.0.0.1:6379&gt; SET foo bar
OK

# 1つのスレーブのレプリケーションが完了するのを待つ(Timeout 1000ms)
127.0.0.1:6379&gt; WAIT 1 1000
(integer) 1 # レプリケーションが完了したスレーブの台数
</code></pre>

<p>レプリケーションの完了＝コマンドの実行完了と解釈すれば、
データの消失を最小限に抑えることができます。</p>

<p>ちなみに、WAITコマンドのtimeoutはミリ秒ですが、今回使用した<a href="https://godoc.org/gopkg.in/redis.v5">go-redis/redis</a>は
これを秒として扱っていました。
(こういうのRedis::Fast開発時にもあった気がする)
単位重要ですね。
time.ParseDurationで時間指定をすると、毎回単位指定が必要になって面倒ですが、
こういうミスを防ぐためには有用そうです。
積極的に使っていきたい。</p>

<h3>横取り検出</h3>

<p>WAITコマンドでデータの消失を最小限にしたとしても、0にできるわけではありません。
消失が起こった場合の対応も必要です。
ID配布した記録が消えて横取りが出来る可能性があるので、
IDに所有者(貸出先の方が正しかったかも)を一緒に記録しておくことにしました。</p>

<p>各クライアントにクライアントIDを付与しておきます。(現状の実装はhostname+timestamp+連番)
横取りされた方は、自分のクライアントIDとIDの所有者を比較し、横取りが分かった時点で速やかにID開放します。
横取りした方は、ID取得からID使用までしばらく時間を開けます(-delayでこの時間は変更可能)
これは横取りされた方のID開放が終わるまで、猶予時間を与えるためです。</p>

<h2>動作条件等</h2>

<p>何度か書いていますが、このアイデアは時刻が肝です。
各サーバ間の時刻同期が正しく行われている必要があります。
普通にNTPを使っていればmsのオーダーで同期が取れるので問題ないでしょう。</p>

<p>・・・ただし、みんな大嫌いなうるう秒があります。
うるう秒の対応の仕方がまちまちなので、ことなった対応方針が適用されたサーバーが混ざると大変です。</p>

<p>例えば、マネージドなRedisとしてElastiCacheを使うと、
うるう秒挿入のタイミングでElastiCacheは<a href="http://aws.typepad.com/aws_japan/2015/05/look-before-you-leap-the-coming-leap-second-and-aws.html">AWS調整時刻</a>で動作します。
残念ながらAWS調整時刻を返すNTPは提供されていないようです。</p>

<p>デフォルトの設定はこの辺を考慮してマージンを取っているので大丈夫なはず・・・。
使う人がいるかはわかりませんが、検証頑張って！</p>

<h2>名前について</h2>

<p>「Yet Another Ranged Unique id Supplier」の略です。
いい名前が思いつかなかったので、fujiwaraさん製のRanged Unique id Supplierが既にあったのでそこから拝借しました。
Yet Anatherは、こう付けると流行ると「言語のしくみ」に書いてあったからです。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B01N7JZXMD&linkId=8ee3d3dfb649430b1d0abd35881e5f56"></iframe>


<h2>まとめ</h2>

<ul>
<li>RedisをID発番サーバID配布サーバとして活用する方法を考えてみました</li>
<li>可用性を求めていったらレプリケーションの高度な使い方がわかってきた

<ul>
<li><code>redis.replicate_commands</code>でスクリプトのレプリケーション方式を変更する</li>
<li>WAITコマンドでレプリケーションを待つ</li>
</ul>
</li>
<li>フェールオーバのこととか考えると全然楽じゃなかった・・・</li>
</ul>


<p>思いつきを試したかっただけなのですが、勉強になったので良しとしましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WEB+DB PRESS Vol.97にPerlとRedisの記事を寄稿しました]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/"/>
    <updated>2017-02-23T18:27:53+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97</id>
    <content type="html"><![CDATA[<p>昨年末に<a href="https://twitter.com/songmu">Songmu</a>さんからお話を頂き、
<a href="http://gihyo.jp/magazine/wdpress/archive/2017/vol97">WEB+DB PRESS Vol.97</a>内の連載「第43回Perl Hackers Hub」に
「PerlでのRedis活用法」というタイトルで寄稿しました。
発売日は<strong>2月24日</strong>です。</p>

<!-- More -->


<h2>内容</h2>

<p>簡単に内容を紹介しておきます。
Perl使いではじめてRedisを使う人向けに書いたつもりです。</p>

<h3>Redisの簡単な説明</h3>

<p>Redisのインストール方と、Perlからの接続方法、そしてRedisの型の説明です。
記事の中でも紹介していますが、Redisはその豊富な型が特長です。
読者はきっとPerl使いだろうということで、Perlの型(Perlにも型はあるんだよ！！)と
比較しながら簡単に紹介しています。</p>

<h3>Redisの応用例とCPANモジュールの紹介</h3>

<p>Redisを使うとこんなことができるよ、という紹介です。
CPANで公開されているRedis関連のモジュールも合わせて紹介しています。</p>

<h3>Redis自体の注意点</h3>

<p>以前Redisを使ったサービスの運用に携わっていたのですが、
そのなかで実際に起きたことを元に、Redisの注意点について書きました。
さいわいサービスが停止するような事故にはありませんでしたが、
メトリックスを眺めながらエンジニア勢でヤバイヤバイ騒いでましたね・・・。
みなさんも気をつけて下さい。</p>

<h2>執筆してみての感想</h2>

<p>昔から文章を書くのにはだいぶ苦手意識があり、
今回の執筆も非常に苦労しました。
一文の前半を書いた時点で
「今から書こうとしている情報は本当に必要なのか」
「自分の記憶違いで間違った情報なのでは」と不安になり、
色々考えているうちに、何書こうとしてたのかわからなくなるんですよね。
まずは適当に書き上げて、後からちゃんと推敲しよう、
とは思いつつもなかなか進められず・・・。
スループットを上げたい。</p>

<p>細かい表現とかも気になってなかなか進まないので、
こういうの入れて頑張ろうと思います！</p>

<ul>
<li><a href="http://qiita.com/azu/items/2c565a38df5ed4c9f4e1">VS Codeでtextlintを使って文章をチェックする</a></li>
<li><a href="http://takemikami.com/2017/02/14/gitbook.html">gitbookで技術書を書く環境の構築手順</a></li>
</ul>


<p>(執筆が進まないと、こういう環境構築に時間をかけてしまうのもよくないと思うんだ・・・)</p>

<h2>余談</h2>

<p>ところで、<strong>Vol.97</strong>と<strong>第43回</strong>ってどっちも<strong>素数</strong>ですね！
雑なプログラムを書いて調べてみたところ、
両方素数になるのはVol.83, 第29回以来、<strong>7回目</strong>(これも<strong>素数</strong>だ！)。
次はVol.101, 第47回です。
そのときのPerl Hackerは誰になるのでしょうか。楽しみですね！</p>

<pre><code class="perl">use warnings;
use strict;

sub is_prime {
    my $n = shift;
    return 0 if $n &lt; 2;
    my $i = 2;
    while($i*$i&lt;=$n) {
        return 0 if $n % $i == 0;
        $i++;
    }
    return 1;
}

my $i = 1;
for my $n(1..200) {
    my $m = $n-43+97;
    if (is_prime($n) &amp;&amp; is_prime($m)) {
        printf "%3d: Vol.%3d, No.%3d\n", $i, $m, $n;
        $i++;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを公開しました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules/"/>
    <updated>2016-03-18T22:16:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules</id>
    <content type="html"><![CDATA[<p>以前<a href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/">Redisでスコアを複数設定できるランキングを作ってみた</a>けど、
Githubの肥やしになっていてもあれなので、CPANizeしました。
あわせて、この実装のために作ったユーティリティモジュールも別モジュールとして公開しました。</p>

<ul>
<li><a href="https://metacpan.org/pod/Redis::LeaderBoardMulti">Redis::LeaderBoardMulti</a></li>
<li><a href="https://metacpan.org/pod/Redis::Script">Redis::Script</a></li>
<li><a href="https://metacpan.org/pod/Redis::Transaction">Redis::Transaction</a></li>
</ul>


<!-- More -->


<h2>Redis::LeaderBoardMulti</h2>

<p>最初の基準で順位を決められなかった場合の第二基準が欲しいというときに使うモジュールです。
インターフェースがRedis::LeaderBoard互換になるように調整したので、
前回とインターフェースがちょっと変わっています。</p>

<pre><code class="perl">se Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
# Redis::LeaderBoardに合わせて複数指定できるようになりました
$lb-&gt;set_score(
    'one' =&gt; [100, time],
    'two' =&gt; [ 50, time],
);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p>Redis::LeaderBoard互換なのでそのまま入れ替えられるはずですが、以下のような実装上の制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
<li>同順の場合の出現順

<ul>
<li>Redis::LeaderBoard は ZRANK, ZREVRANK を使い分けているので、orderパラメータによって昇順/降順が変わります</li>
<li>Redis::LaederBoardMulti は ZRANK しか使わないので、必ず昇順になります</li>
</ul>
</li>
</ul>


<p>一応 Lua Script を使わないオプションもそのまま残してありますが、特に理由がない限りデフォルト(Lua Script を使う)で使うといいと思います。
どうしてもロックの範囲が広くなってしまう場合があり、楽観的ロックでは効率が悪いケースがあるためです。</p>

<h2>Redis::Script</h2>

<p>EVALSHAを簡単に使うためのモジュールです。
EVALコマンドを使うとLua Scriptの実装ができますが、毎回毎回実行するスクリプト全体を送る必要があります。
EVALSHAコマンドはその代わりにスクリプトのSHA1ハッシュを送ることで、帯域の節約ができるというコマンドです。
しかしEVALSHAはSHA1ハッシュを事前に登録する必要があり、どのタイミングで登録を行うかが問題になってきます。</p>

<p><a href="http://redis.io/commands/eval">EVALコマンドのドキュメント</a>によると、
「EVALSHAで実行してみて <code>NOSCRIPT No matching script</code> で失敗したらEVALでやり直す」というのがおすすめらしいです。
EVALコマンドはSHA1ハッシュの登録も行ってくれるので、初回 <code>NOSCRIPT</code> になっても次回からはEVALSHAが成功します。</p>

<p>そんなに複雑なことではないのですが、毎回書くのも大変なのでモジュールとして切り出したのが Redis::Script です。
以下のようにスクリプトオブジェクトを作っておいて、パラメータを渡して実行します。</p>

<pre><code class="perl">use Redis;
use Redis::Script;
my $script = Redis::Script-&gt;new(script =&gt; "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}");
my ($key1, $key2, $arg1, $arg2) = $script-&gt;eval(Redis-&gt;new, ['key1', 'key2'], ['arg1', 'arg2']);
</code></pre>

<p><code>$script</code> が計算済みのSHA1ハッシュを保存しておいてくれるので、計算リソースの節約にもなるはずです。
(ベンチとってみたところ、スクリプトのサイズが1kBから10kBくらいにならないと効果なさそうでしたが・・・)</p>

<h2>Redis::Transaction</h2>

<p>Redisのトランザクションを簡単に行うためのモジュールです。</p>

<p>MULTI-EXECは単に実行するだけなら、MULTIとEXECで囲うだけでよいので簡単です。
例えば、 <code>foo</code> と <code>bar</code> を同時にインクリメントしたい場合、以下のようにすると実現できます。</p>

<pre><code class="perl">$redis-&gt;multi;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
$redis-&gt;exec; # 他のクライアントからはfooとbarが全く同時にインクリメントされたように見える
</code></pre>

<p>ただ、このような素朴な実装だと、途中でネットワークが不調になった場合などに再接続処理が止まったままになる可能性があります。
例えば以下のようにトランザクションの中で例外が発生すると、以後そのコネクションを使おうとしたときにエラーになります。
コネクションの永続化をしている場合はしばらくエラーが出続けることになり問題です。</p>

<pre><code class="perl">eval {
    $redis-&gt;multi; # トランザクション開始
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
    $redis-&gt;exec;
};
$redis-&gt;ping; # 繋がらなくなる
</code></pre>

<p>Redis::Transaction はこのような問題を防ぐためのモジュールです。
トランザクションが失敗したときの後始末をよしなにやってくれるので、万が一エラーになっても安心です。</p>

<pre><code class="perl">multi_exec Redis-&gt;new, 1, sub { # 1は失敗したときのリトライ回数
    my $redis = shift;
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
};
$redis-&gt;ping; # 繋がる！
</code></pre>

<p>WATCH-MULTI-EXECを使った楽観的ロックも扱えます。
Redisのトランザクションは楽観的ロックなので、
処理中に他のクライアントが書き換えを行った場合に失敗する可能性があります。
その場合でもリトライを行ってくれて便利です。</p>

<pre><code class="perl"># $redis-&gt;incr('mykey') をトランザクションを使って実現する
watch_multi_exec Redis-&gt;new, ['mykey'], 10, sub {
    my $redis = shift;
    return $redis-&gt;get('mykey');
}, sub {
    my ($redis, $value) = @_;
    $redis-&gt;set('mykey', $value + 1);
};
</code></pre>

<h2>まとめ</h2>

<p>Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを紹介しました。
それぞれは小さなモジュールですが、
トラブル発生時にも問題にならないようちゃんとした実装しようとすると、
意外と考えることが多く面倒なものです(特にトランザクション周りとか)。
適当に実装してしまったこころ当たりのある人は、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisでスコアを複数設定できるランキングを作ってみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/"/>
    <updated>2016-02-06T02:30:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi</id>
    <content type="html"><![CDATA[<p>ランキングを作っているとスコアを複数設定したいことがよくあると思います。
例えば「得点が同じだったら早くその得点を出した人優先」とか「勝ち点が同じだったら得失点差が大きい方優先」とかのように、
最初の基準で順位を決められなかった場合の第二基準が欲しいみたいな場合です。</p>

<p>ランキングを作るのにはRedisのSorted Setを使うのが便利ですが、残念ながらSorted Setはひとつしかスコアを設定できません。
少し前にどうやったら実装できるかと社内チャットで話題に上ったので、試しにRedis::LeaderBoardMulti(仮名)という名前で書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/p5-Redis-LeaderBoardMulti">shogo82148/p5-Redis-LeaderBoardMulti</a></li>
</ul>


<!-- More -->


<h2>使い方</h2>

<p>メソッドの名前は<a href="http://www.songmu.jp/riji/archives/2013/06/redisleaderboar.html">Redis::LeaderBoard</a>にあわせてありますが、
スコアが複数指定できるようになった関係でちょっと変わってます。</p>

<pre><code class="perl">use Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
$lb-&gt;set_score('one' =&gt; 100, time); # 第二基準は時間=得点が同じだったら早くその得点を出した人優先
$lb-&gt;set_score('two' =&gt;  50, time);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p><code>set_score</code>の第二引数以降はすべてスコアとして扱われます。(そのためRedis::LeaderBoardと互換性はない)
上の例では「得点が同じだったら早くその得点を出した人優先」になってます。</p>

<h2>制限事項</h2>

<p>実装の都合により、以下のような制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数です

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
</ul>


<h2>実装の仕組み</h2>

<p>Sorted Setの同じスコアを持つメンバーは辞書順にソートされます(zaddの<a href="http://redis.io/commands/zadd#elements-with-the-same-score">同じスコアを持つ要素</a>の項を参照)。
例えば以下の様にメンバー「a」「b」「c」を追加すると、必ず「abc」の順番になることが保証されています。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "a" 0 "b" 0 "c"
(integer) 3
127.0.0.1:6379&gt; ZRANK ranking "b"
(integer) 1
</code></pre>

<p>これを利用して、メンバーの先頭にスコアをエンコードして付けておきます。
もちろんエンコードしたあとでもスコアの大小関係が保たれている必要があります。
以下はエンコード方式にビッグエンディアンの16bit整数を使った例です。
Redis 2.8.9から辞書順比較に特化したコマンド(LEXがつくやつ)が追加されているので、
ランクを求める処理は以下のように書くことができます。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x02b"    (bをスコア2で追加)
(integer) 1
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x01a"    (aをスコア1で追加)
(integer) 1
127.0.0.1:6379&gt; ZLEXCOUNT ranking - "(\x00\x02"    (スコア2未満の個数=bのランク)
(integer) 1
</code></pre>

<p>さすがに16bit符号なし整数だと範囲が狭いので、実際の実装は以下のようになっています。</p>

<ul>
<li>エンコードはビッグエンディアンの64bit符号付き整数</li>
<li>負数も扱えるように下駄を履かせる

<ul>
<li>1と-1を単純にエンコードすると-1の方が大きくなってしまう</li>
<li>0x8000000000000000を足して符号なし整数の範囲で比較できるように補正</li>
</ul>
</li>
</ul>


<h2>アトミック性について</h2>

<p>この方法だとSorted Setだけでは現在のスコアを取得できないので、
スコアだけ別管理にする必要があります。
スコアの更新とランキングの更新があるので、
片方だけ更新される状況がないようにアトミック性に注意する必要があります。
更新途中の間違った結果を返すだけならすぐに復旧するのでまだマシですが、
途中でネットワーク障害が起こって不整合なデータが残ってしまうと面倒です。</p>

<p>アトミック性を確保するためのパターンをいくつか実装してみました。
<code>use_script</code>と<code>use_hash</code>で制御が可能です。</p>

<h3>トランザクションを使った方法</h3>

<p>Redisには<a href="http://redis.io/topics/transactions">トランザクション</a>の仕組みがあるのでこれを使った方法です。
<code>use_script=&gt;0</code>が指定されるとこの方法で更新を行います。</p>

<pre><code class="plain">127.0.0.1:6379&gt; WATCH ranking:a   (他のクライアントが更新を行っていないか監視)
OK
127.0.0.1:6379&gt; GET ranking:a   (ranking:aに入っている現在のスコアを取得)
"\x00\x01"
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; ZREM ranking "\x00\x01a"
QUEUED
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x03a"
QUEUED
127.0.0.1:6379&gt; SET ranking:a "\x00\x03"
QUEUED
127.0.0.1:6379&gt; EXEC   (スコアの更新とランキングの更新をアトミックに行う)
1) (integer) 1
2) (integer) 1
3) OK
</code></pre>

<p>Redisのトランザクションは楽観的ロックなので、他のクライアントがスコアを更新していると失敗する場合があります。
失敗した場合はリトライが必要です。
(この機構、いろいろと注意点があって毎回実装するのはつらすぎるので、別モジュールとして分離したいけど、いい名前とインターフェース募集中)</p>

<p><code>use_hash=&gt;1</code>が指定されていると、スコアの記録にHashを使います。
「Hashの特定のキーの更新をWATCHする」という命令はないため、ランキング全体を<code>WATCH</code>で監視します。
(<code>use_hash=&gt;0</code>の場合、そのメンバのスコアだけ監視する)</p>

<h3>Luaスクリプトを使った方法</h3>

<p>RedisはLuaスクリプトを実行する機能があります。
Luaスクリプト実行中は他の命令の実行をブロックするので、アトミック性が確保されます。</p>

<pre><code class="lua">local s=redis.call('GET', 'ranking:a')
if s then
  redis.call('ZREM', 'ranking', s..'a')
end
redis.call('ZADD', 'ranking', 0, '\x00\x03a')
redis.call('SET', 'ranking:a', '\x00\x03')
</code></pre>

<p>Luaスクリプトを実行するには<code>EVAL</code>と<code>EVALSHA</code>の二種類のコマンドがあります。
<code>EVALSHA</code>は転送量を抑えられて便利ですが、事前に<code>SCRIPT LOAD</code>で使うスクリプトを登録しておく必要があります。
(ココらへんも別モジュールに分離したいけど、いい名前とインターフェース募集中)
<code>use_evalsha</code>オプションでどちらを使うか制御可能です。</p>

<p>ちなみに<code>EVAL</code>で実行したスクリプトも<a href="http://redis.io/commands/eval#script-cache-semantics">永遠にキャッシュされる</a>らしいです。
上の例はわかりやすいようにキー名や値を直接埋め込んでいますが、同じことをしようとLuaスクリプトの動的生成なんてすると死にます。
スクリプト内で<code>KEYS</code>や<code>ARGV</code>を使うと<code>EVAL</code>時にパラメータを渡せるようになるので、これを活用しましょう。</p>

<h3>諦める</h3>

<p><a href="https://metacpan.org/pod/Redis::LeaderBoard">Redis::LeaderBoard</a>の実装を見て気がついたんですが、
<code>get_rank</code>の実装は「スコアの取得」「スコアに対応するランクの取得」がアトミックでないため、
以下の条件を満たすと実際のランクより1大きい結果を返します。</p>

<ul>
<li>同じメンバーのスコア更新とランク取得が同時に行われる</li>
<li>ランクが上がるようにスコアが更新される</li>
</ul>


<p>確かに厳密性は欠けますがたかだか1結果が変わるだけですし、
そもそも更新と取得が同時に行われないようにモジュールを使う側が排他制御するべきですね。
こういうケースでは諦めるというのも一つの手かなと思いました。
もちろんデータの整合性が壊れる場合は頑張ってアトミック性を確保するべきでしょう。</p>

<h2>まとめ</h2>

<ul>
<li>Redisでランキングをつくる際に、スコアを複数設定する方法を紹介しました</li>
<li>アトミック性を確保する方法を紹介しました

<ul>
<li>トランザクションを使った方法</li>
<li>Luaスクリプトを使った方法</li>
<li>諦める</li>
</ul>
</li>
</ul>


<p>もうちょっとドキュメントを整備したらCPANにあげてみますかね。
トランザクション管理・Luaスクリプト管理も分離したい(いい名前を思いついたら)。
「こんな名前がいい！」「こんなインターフェースがいい！」等あればコメントください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.17 をリリースしました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released/"/>
    <updated>2016-01-23T16:20:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/release/SHOGO/Redis-Fast-0.17">Redis::Fast 0.17</a> をリリースしました。
主な変更点は以下のとおりです。</p>

<ul>
<li>I/Oの待ち合わせに使うシステムコールをselect(2)からpoll(2)に変更</li>
<li>hiredisをv0.13.3にアップデート</li>
</ul>


<!-- More -->


<p>macでテストが終わらない問題がありましたが、この変更によって修正されています。</p>

<p>hiredisは<a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man2/connect.2.html">connect(2)</a>をnonblokingモードで呼び出しています。
nonblockingなので接続が未完了であってもすぐに制御を返し、errnoにEINPROGRESSが設定されます。
この場合、manにあるようにselect(2)で書き込み可能になるのを待つことで、接続完了を検知できます。</p>

<blockquote><p>select(2) で書き込み可能になった後に、 getsockopt(2) を使って SOL_SOCKET レベルで SO_ERROR オプションを読み出すこ とにより、 connect() が成功したか、失敗したかを判断できる。</p></blockquote>

<p>linuxの場合はこれで上手く動くのですが、macだと何故かselect(2)が永遠に制御を返さない場合があるようです。
接続先が存在しない場合に起こるのですが、制御を返す場合もあるので謎です。</p>

<p>いろいろ調べてはみたのですがselect(2)だとどうやっても上手く動かなかったので、poll(2)に変更しました。
poll(2)変更版でテストしてみると、接続先が存在しない場合にPOLLOUTを返すケースとPOLLHUPを返すケースがあるようです。
どうやらPOLLHUPにあたるイベントが来た時の挙動がlinuxとmacとで違うらしい？
謎です。</p>
]]></content>
  </entry>
  
</feed>
