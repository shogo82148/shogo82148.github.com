<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unity | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/unity/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2014-07-05T18:37:26+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C# でお手軽にMessagePack解析！]]></title>
    <link href="http://shogo82148.github.io/blog/2014/05/25/mini-message-pack/"/>
    <updated>2014-05-25T01:38:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/05/25/mini-message-pack</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/shogo82148/MiniMessagePack">MiniMessagePack.cs</a>ってのを作った。
C#のプロジェクトにファイルひとつ導入するだけで、お手軽にMessagePackの解析ができます。</p>

<!-- More -->


<h2>なんで作ったの？</h2>

<p><a href="https://gist.github.com/darktable/1411710">MiniJSON</a> の置き換えが目的です。
とあるUnityプロジェクトでMB単位のJSONをパースする箇所があってですね・・・
パースにはMiniJSONを使っているのですが、さすがに対象がでかすぎて重たい。
そこでMessagePackへの置き換えを検討してみたわけです。</p>

<p>もちろん C# で動く MessagePack のパーサはすでにあって、
<a href="https://github.com/msgpack/msgpack-cli">messagepack-cli</a>とか<a href="https://github.com/southwudang/msgpack-unity">messagepack-unity</a>とか見つけました。
しかし、Unityのちょっと古いMonoで動かすためにちょっとゴニョゴニョしないといけなかったり、
MiniJSON との互換性を取るためにもゴニョゴニョしないといけなかったり(実際やってみたらキャストが大量に失敗して辛かった・・・)、
今回の用途にはちょっと高機能かなーと思ったので作っちゃいました！</p>

<h2>つかいかた</h2>

<h3>デコードする</h3>

<p><code>byte</code>の配列を渡すとパースして返してくれます。
配列は<code>List&lt;object&gt;</code>で、マップは<code>Dictionary&lt;string, object&gt;</code>になります。</p>

<p>``` csharp
using MiniMessagePack;</p>

<p>// it means {"compact":true,"schema":0} in JSON
var msgpack = new byte[] {</p>

<pre><code>0x82, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0xc3,
0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x00
</code></pre>

<p>};</p>

<p>var packer = new MiniMessagePacker ();
object unpacked_data = packer.Unpack (msgpack);
/*
unpacked_data = new Dictionary&lt;string, object> {</p>

<pre><code>{ "compact", true },
{ "schema", 0},
</code></pre>

<p>};
*/
```</p>

<h3>エンコードする</h3>

<p>オブジェクトを渡すと MessagePack にエンコードして返してくれます。</p>

<p>``` csharp
using MiniMessagePack;</p>

<p>var unpacked_data = new Dictionary&lt;string, object> {</p>

<pre><code>{ "compact", true },
{ "schema", 0},
</code></pre>

<p>};</p>

<p>var packer = new MiniMessagePacker ();
bytep[] msgpack = packer.Pack (unpacked_data);
// msgpack = new byte[] { 0x82, 0xa7, ...};
```</p>

<h2>制限事項</h2>

<p>MiniJSON との互換性を取るために、色々と制限事項があります。</p>

<ul>
<li>デコード時、整数型は全て<code>long</code>型

<ul>
<li>整数の大きさに関係なく全て<code>long</code>型になります</li>
<li>符号なし64bit整数型も<code>long</code>として扱われるので、表現できる範囲が狭くなっていることに注意してください</li>
</ul>
</li>
<li>デコード時、浮動小数点型は全て<code>double</code>型

<ul>
<li><code>float</code>も<code>double</code>として扱われます(拡張される方向への変換だから問題ないとは思うけど)</li>
</ul>
</li>
<li>デコード時、マップ型のキーは文字列にキャストされます

<ul>
<li>MessagePackの仕様にはキーの型に制限が無いっぽい(？)けど、扱えるのは文字列の場合のみです</li>
</ul>
</li>
<li>Extended は今のところ扱えません</li>
</ul>


<h2>ちょっとだけ使ってみた結果</h2>

<p>正確なベンチマークとかはとってないのですが、
実際のプロジェクトに組み込んでみた結果、MiniJSONとくらべて約2倍の速さでパースできました！</p>

<p>MiniJSON を使っているプロジェクトであれば簡単に導入できるはずなので、ぜひ試してみてみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unity Test Tools を使ってみる]]></title>
    <link href="http://shogo82148.github.io/blog/2013/12/21/unity-test-tools/"/>
    <updated>2013-12-21T21:02:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/12/21/unity-test-tools</id>
    <content type="html"><![CDATA[<p>みなさんこんにちは、
最近つらいことばかりで元気のないいっちーです。
少しでもつらいことを解消できないかと Unity Test Tools ってので遊んでみました。</p>

<!-- More -->


<h2>背景</h2>

<p>最近あったつらいことのひとつに「Unityで作ってるプロジェクトで、機能拡張したときに間違えて一行消しちゃった！！！」
ってのがあります。</p>

<p>もちろん僕が消したわけじゃないですよ！！！
僕サーバサイドエンジニアですから、Unityはいじりません。
でも、一応修正コミットは見ていたはずなので、気がつけなかったのは残念です・・・。</p>

<p>どんなにコード書く人が頑張っても、レビューする人が頑張っても、
人間誰だってミスします。
じゃあ、機械にやらせよう！テストコードだ！って話なんですが、
コードカバレッジが低く、今回のつらい事例でもテストがありませんでした。
一部書いてあるテストも、担当者が代わってからなんか怪しい・・・。</p>

<p>あと、自分も手元でテスト動かしてみたのですが、今のテスト面倒・・・。</p>

<ul>
<li>Unityのコンソールにドバッと流れる

<ul>
<li>テストが全部通ったのか、失敗したのかよくわからない</li>
</ul>
</li>
<li>ユニットテストを1項目だけやりたいとかどうやるんだろう

<ul>
<li>「テストの実行」が「シーンの再生」なので1項目とかどうすんの？</li>
</ul>
</li>
</ul>


<h2>Unity Test Tools</h2>

<p>つらいので解決方法を探るべくインターネットの海をさまよっていたら Unity Test Tools なるものを発見。</p>

<ul>
<li><a href="http://blogs.unity3d.com/2013/12/18/unity-test-tools-released/">Unity Test Tools Released</a></li>
</ul>


<p>これを書いてる時点で、3日前のリリースです！
タイムリーだ！！</p>

<p>英語でよくわかんないけど、スクリーンショットはわかりやすくてかっこいいぞ！
遊んでみよう！</p>

<h2>事前準備</h2>

<p>まず、Unity Testing Tools をダウンロードしてこよう！
Aseet Store に並んでるので、ダウンロードボタンを押してしばらく待ってれば Unity が勝手に使える状態にしてくれます。</p>

<h2>簡単なユニットテストを書いてみる</h2>

<p>以前れもんさんが書いた「<a href="http://tech.kayac.com/archive/merry_christmas_2012.html">#24 「Unityでコルーチンも単体テストしよう」 tech.kayac.com Advent Calendar 2012</a>」を
Unity Testing Tools でやってみました。</p>

<p>テストの対象はこんな感じのクラスです(短く書けそうな部分があったのでちょっと変えた)。</p>

<p>``` csharp
namespace MyProject {</p>

<pre><code>public class Plan {
    public string Title { get; private set; }
    public string Text { get; private set; }

    public Plan(string title, string text) {
        Title = title;
        Text = text;
    }
}
</code></pre>

<p>}
```</p>

<p>れもんさんの記事ではSharpUnitを使っていましたが、
Unity Test Tools は NUnit というテストフレームワークを使うようです。
Plan のテストをNUnitを使って書きなおしてみます。</p>

<p>``` csharp
using System;
using System.Threading;
using NUnit.Framework;</p>

<p>namespace MyProject.Tests
{</p>

<pre><code>class PlanTest
{
    [TestCase("Christmas", "Let's play tennis!")]
    [TestCase("Christmas", null)]
    public void Constractor (string title, string text)
    {
        Plan plan = new Plan(title, text);
        Assert.AreEqual(plan.Title, title);
        Assert.AreEqual(plan.Text, text);
    }
}
</code></pre>

<p>}
```</p>

<p>TestCaseのお陰でずいぶんシンプルになりました。
(にわかC#erの僕はアトリビュートが出てきてドキドキです)</p>

<p>気をつけないといけないのは、このテストをEditorというフォルダの中に入れないといけないことです。
Editorってフォルダの中に入っていると、普段のプロジェクトとは別のプロジェクトに所属するようになります。
Unity Editor の動作を変更するようなスクリプトをかけるらしいので、その一つとして実装するってことですかね・・・？
(そのへんよくわかってない)</p>

<p>テストスクリプトを保存したら、あとはメニューから「Unity Test Tools」「Run all unit tests」をクリックするだけ！
テスト用シーンを追加する必要もありません。簡単！</p>

<p>「Unit Test Runner」を使えば、テストを1項目だけテストすることもできるし、
ファイルを右クリックしたときのメニューから「Load tests from this file」を選べばファイルごとにテストもできます。</p>

<h2>結合テストをやってみる</h2>

<p>次にネットワーク周りのテストをやってみます。
テストするのはこのクラスです。</p>

<p>``` csharp
using UnityEngine;
using System.Collections;</p>

<p>namespace MyProject {</p>

<pre><code>public class InternetPlanFactory {
    public Plan Plan { get; private set; }

    // 特定のURLにアクセスし、1行目をタイトル、2行目をテキストとしてオブジェクトを生成
    public IEnumerator PlanFromUrl(string url) {
        WWW www = new WWW(url);
        yield return www;
        if (www.error != null) {
            // ノープランだ
            this.Plan = null;
        } else {
            // 適当にPlanつくる
            string[] lines = www.text.Split('\n');
            string title = lines[0];
            string text = lines.Length &gt; 1 ? lines[1] : "";
            this.Plan = new Plan(title, text);
        }
    }
}
</code></pre>

<p>}
```</p>

<p>このクラスのテストには <code>GameObject</code> が必要みたいです。
<code>GameObject</code> って何者？とUnity情弱の僕は思うのですが、なにやらシーンから取ってこないといけないものらしいです。
ユニットテストでも頑張ればとってこれるのかもしれないけど、
結合テストとしてシーンの中で実行してみます。</p>

<p>結合テストを作るには、新しいシーンを追加し、
そのシーンを開いた状態で「Integration Test Runner」を開きます。
ここで緑の「＋」ボタンを押すとシーンに「TestRunner」と新しいテストが現れます。
さらにテストの子として新しい<code>GameObject</code>を追加しておきましょう。</p>

<p>次に以下の様なスクリプトを書きます。</p>

<p>``` csharp
using UnityEngine;
using System;
using System.Collections;
using MyProject;</p>

<p>public class Hoge : MonoBehaviour {</p>

<pre><code>void Start () {
    StartCoroutine(TestPlanFromUrlOk());
}

private IEnumerator TestPlanFromUrlOk() {
    InternetPlanFactory factory = new InternetPlanFactory();
    yield return StartCoroutine(factory.PlanFromUrl("http://example.com"));

    if(factory.Plan == null)
        throw new Exception("Plan is null");
    if(factory.Plan.Title == null)
        throw new Exception("Plan.Title is null");
    if(factory.Plan.Text == null)
        throw new Exception("Plan.Text is null");
    IntegrationTest.Pass(gameObject);
    // IntegrationTest.Fail(gameObject); // と書くとテスト失敗できる
}
</code></pre>

<p>}
```</p>

<p>(アサーションの仕方が残念すぎるけど力尽きた)</p>

<p>このスクリプトをさっき作った<code>GameObject</code>にアタッチすれば準備完了です。
「Integration Test Runner」からテスト可能になります。</p>

<h2>おわり</h2>

<p>今日はここまで。
今までも一応テストあったけど、Unity Testing Tools使うともっと便利に書けそう。
きっとぴーちんとかがもっと便利な機能を見つけてくれる。</p>

<p>ちなみに <code>Plan("Christmas", null)</code> なので、
<code>Text != null</code> なURLを募集してます。</p>
]]></content>
  </entry>
  
</feed>
