<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2014-05-23T00:00:09+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.07 をリリースしました！]]></title>
    <link href="http://shogo82148.github.io/blog/2014/05/17/redis-fast-0-dot-07-released/"/>
    <updated>2014-05-17T16:27:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/05/17/redis-fast-0-dot-07-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/release/Redis-Fast">Redis::Fast 0.07</a> をリリースしました。
現時点での最新バージョンである Redis.pm 1.974 とコンパチブルになります。</p>

<!-- More -->


<p>主な修正点は以下の通りです</p>

<ul>
<li>Redis Sentinel 対応</li>
<li>トランザクション内での再接続禁止</li>
<li>再接続にDB選択し直し</li>
</ul>


<h2>Redis Sentinel 対応</h2>

<p>Redis Sentinel というのは自動フェールオーバーの仕組みらしいです。
(ソースはコピペしたきただけで仕組みはあまり理解していない)
どんなものかは本家ドキュメントや実際に検証してみた人の記事をご参照ください。</p>

<ul>
<li><a href="http://redis.io/topics/sentinel">Redis Sentinel Documentation</a></li>
<li><a href="http://chrone.hatenablog.com/entry/2014/02/28/212616">Redis 2.8 の Sentinel の動きを検証してみた</a></li>
<li><a href="http://blog.kenjiskywalker.org/blog/2013/01/24/redis-sentiel-howto/">Redis Sentinelを動かしてみた</a></li>
</ul>


<p>前から移植作業は進めてたのですが、本家 Redis.pm でもテストがコケたりしてちょっと不安だったのでリリースを見送ってました。
今日 Redis.pm の安定版がリリースされたのでこっちも追従しますよ！！</p>

<p>コネクションを作るときに <code>sentinels</code> を渡すと Redis Sentinel から接続情報を取ってきてくれます。
一緒に <code>reconnect</code> を設定しておいてあげると、Masterに何かあった時に接続情報を再取得→
自動的に Slave へフェールオーバーしてくれます。</p>

<p>``` perl
use Redis::Fast;
my $redis = Redis::Fast->new(</p>

<pre><code>sentinels =&gt; [ '127.0.0.1:26379' ],
service =&gt; 'mymaster',
reconnect =&gt; 1,
</code></pre>

<p>);
```</p>

<h2>トランザクション内での再接続禁止</h2>

<p>Redisにも簡単な<a href="http://redis.io/topics/transactions">トランザクション機能</a>があって、
複数の命令を同時に実行することができます。
トランザクション中に再接続が発生するとトランザクションがリセットされてしまうので、
接続前の命令を再投入する必要があるのですが、Redis.pm/Redis::Fastの再接続処理はそこまで面倒を見てくれません。
以前のバージョンではそこの面倒を見てくれないのに適当に処理してしまい、
トランザクションが中途半端なまま実行されてしました。</p>

<p>0.07 からはトランザクション内では再接続を行わずに例外を吐きます。
トランザクションを最初からやり直すなど、よしなに対応してください。</p>

<h2>再接続時にDB選択し直し</h2>

<p>一つのRedis-Serverが複数のデータベースを持てるようになっていて、
<a href="http://redis.io/commands/select">SELECT</a>コマンドを使って切り替え可能です。
今までのバージョンでは、SELECTコマンドでデータベースを切り替えていても、
再接続時にリセットされてしまう問題がありました。
0.07では再接続の中でSELECTを実行し直すので、再接続を気にする必要はありません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.06 released]]></title>
    <link href="http://shogo82148.github.io/blog/2014/02/01/redis-fast-0-dot-06-released/"/>
    <updated>2014-02-01T21:36:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/02/01/redis-fast-0-dot-06-released</id>
    <content type="html"><![CDATA[<p>こんにちは、もうすぐ17才と100ヶ月を迎えるいっちーです。
今朝、<a href="https://metacpan.org/release/Redis-Fast">Redis::Fast 0.06</a>をリリースしました。
主な変更点はメモリーリークの修正と、エラー発生時にSegmentation Faltで落ちる問題の修正です。</p>

<!-- More -->


<h2>メモリーリーク</h2>

<p>Redis::Fastをサブスクライバーモードで動作させると、メモリを無限に食い続ける問題をついに！ついに！修正しました。
原因は、一言で言ってしまえば、Perlのリファレンスカウントの扱いの勉強不足です・・・。</p>

<p>XSの中でPerlのオブジェクトを作るとき、プログラマが手動でリファレンスカウントを制御する必要があります。
とはいうものの、全てのオブジェクトのリファレンスカウントを制御するのは大変なので、
XSには「揮発性」という考え方があります。
<code>sv_2motral</code>を使って変数を揮発性に設定しておけば、よしななタイミングでオブジェクトを解放してくれます。
<a href="http://d.hatena.ne.jp/gfx/20100519/1274247355">gfx先生のブログ</a>にもあるように、
オブジェクト作成したら原則<code>sv_2motral</code>をつけるようにすれば、
メモリーリークはほとんどなくなるはずです。</p>

<p><code>c
SV * s = newSVpv("Hello World",0);  // Perl の文字列オブジェクト
sv_2motral(s) // 揮発性にすることで、使われなくなったら自動的に解放してくれる
</code></p>

<p>この「よしななタイミング」をよく理解していなかったのでリークしてました・・・。
XSからオブジェクトへアクセスできなくなったときでないとオブジェクトを解放できないので、
揮発性のオブジェクトが実際に解放されるのは「XSで書かれた関数が終了してPerlに戻るとき」です。
メッセージを待ち続ける<code>wait_for_messages</code>関数は
(タイムアウトをしない限り)ずっと終了しないので、
揮発性のオブジェクトを解放するタイミングが一切なかったのです。</p>

<p>不要になったら解放されるよう、揮発性オブジェクトの有効範囲を明示的に指定しました。
<code>c
sv_2motral(s);
ENTER;
SAVETMPS;
sv_2motral(v);
FREETMPS;
LEAVE;
// v はココで解放される
// s は生き残ってる
</code></p>

<p><a href="http://perldoc.jp/docs/perl/5.18.1/perlcall.pod">perlcall</a>とかちゃんとドキュメントを読みましょう > 自分</p>

<h2>Segmentation Falt</h2>

<p>同期的にコマンドを実行してる最中にSIGNAL等で実行が中断されると、
Segmentation Faltが起こる問題を修正しました。
Redis::Fastは同期モードでコマンドを発行したときでも、
hiredisの非同期モードの機能を使って通信しています。
コマンド実行中にエラーが発生すると、
コールバック関数の呼び出しタイミングが変わってしまい、
メモリの確保・解放のタイミングが狂ってしまっていました。</p>

<p>このバグ、試した環境の中ではUbuntu+Perl5.14でしか再現しませんでした。
他の環境ではたまたま解放後もアクセスできてしまって、
正常に動作してしまっていたようです。
嫌なバグだ・・・。</p>

<h2>まとめ</h2>

<p>C言語でメモリ管理するコードは書くべきでない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ark-View-DataTable グラフや表やCSVを簡単に表示したい]]></title>
    <link href="http://shogo82148.github.io/blog/2013/12/07/ark-view-datatable/"/>
    <updated>2013-12-07T20:11:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/12/07/ark-view-datatable</id>
    <content type="html"><![CDATA[<p>こんにちは、最近ログの解析をして遊んでいるいっちーです。
解析の結果は最終的にグラフに出すわけなのですが、
先輩方がよく使っているのもあって <a href="https://developers.google.com/chart/">Google Charts</a> を使ってます。</p>

<p>で、このグラフを他の人に見せると「その元データCSVでちょうだい！」と言われるんです...。</p>

<!-- More- -->


<p>もちろんcsvを作るなんてこと簡単にできるんですが、
今のプログラムにはグラフ用のテンプレートとHTMLで表出力するためのテンプレートとCSV用のテンプレートがあって、
グラフが追加されるたびにコピペして微妙に書き直し、
という不毛な作業が発生してしまうのです。つらい。</p>

<h2>Ark::View::DataTable</h2>

<p>使い回しの効かないテンプレートとかなんのためのテンプレートなのか。
データだけ用意してあとはそれぞれのテンプレートに入れるだけとなるのが理想的だよねー、と思い続けて早数ヶ月。
ようやく重い腰を上げて <a href="https://github.com/shogo82148/Ark-View-DataTable">Ark::View::DataTable</a>ってのを書きました。</p>

<h2>使い方</h2>

<p><a href="https://metacpan.org/pod/Data::Google::Visualization::DataTable">Data::Google::Visualization::DataTable</a> をレンダリングするための
ArkのViewです。</p>

<p>``` perl
use Ark::View::DataTable;
use Data::Google::Visualization::DataTable;</p>

<p>sub gvis :Local {</p>

<pre><code>my ($self, $c) = @_;
my $datatable = Data::Google::Visualization::DataTable-&gt;new();

$datatable-&gt;add_columns(
    { id =&gt; 'x',   label =&gt; "X", type =&gt; 'number' },
    { id =&gt; 'y',   label =&gt; "Y", type =&gt; 'number' },
);

# 〜〜〜〜正弦波を描きましょう〜〜〜〜
$datatable-&gt;add_rows(
    map { [$_, sin(2*3.1415926535*$_/500)] } 1..1000,
);
$c-&gt;stash-&gt;{table} = $datatable;
$c-&gt;forward( $c-&gt;view( 'DataTable' ) );
</code></pre>

<p>}
```</p>

<p>Controllerに感じでかくと使えます。
「/gvis?tqx=out:html」にアクセスするとHTMLの表が、
「/gvis?tqx=out:csv」にアクセスするとCSV形式のファイルが、
「/gvis?tqx=out:tsv-excel」にアクセスするとExcelで開けるファイルがそれぞれダウンロードできます。</p>

<h2>グラフを書く</h2>

<p>このViewは<a href="https://developers.google.com/chart/interactive/docs/dev/implementing_data_source">Chart Tools Datasource Protocol</a>に対応したレスポンスを返すので、
Google Charts からも簡単に扱えます。</p>

<p>``` html
<html>
<body>
<span id="linechart"></span></p>

<script src="https://www.google.com/jsapi"></script>


<script>
google.load("visualization", '1', {packages:['corechart']});
google.setOnLoadCallback(drawChart);
function drawChart() {
  var query = new google.visualization.Query('/gvis');
  query.send(handleQueryResponse);
}

function handleQueryResponse(response) {
  var data = response.getDataTable();
  var chart = new google.visualization.LineChart(document.getElementById('linechart'));
  chart.draw(data, null);
}
</script>


<p></body>
</html>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ISUCON3の本戦に参加してきた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/11/09/isucon3/"/>
    <updated>2013-11-09T23:58:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/11/09/isucon3</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2013/10/07/isucon3-qualify/">ISUCON3の予選</a>を何とか通過し、
本戦へと参戦してきました。</p>

<p>大会中の方針とか考えたこととかメモ。</p>

<h2>お題</h2>

<ul>
<li>Tw○tter--likeな画像投稿サービス

<ul>
<li>ユーザをフォローできる</li>
<li>フォローしたユーザが画像を投稿すると、タイムラインに画像が流れる</li>
<li>公開範囲を全員に公開・フォロワーのみに公開・自分だけに公開から選べる</li>
</ul>
</li>
<li>タイムラインはロングポーリングを使ってリアルタイム反映

<ul>
<li>JSON-APIが用意されていて、Javascriptから叩く</li>
</ul>
</li>
<li>使用できるサーバは5台</li>
</ul>


<p>画像を扱うお題と聞いて、会場がざわめきました。</p>

<h2>MySQLのクエリを見てみる</h2>

<p>開始直後、鍵を用意したり、gitのレポジトリを立てたりなんだりした後、
一回目の計測。</p>

<p>topコマンドで走っているプロセスを見ていると、大量のconvertが！！
プロセス名とお題から考えるに、こいつら確実にImage Magickだ・・・。
CPUのほとんどが画像の変換にくわれていたので、
まずは「どこかでキャッシュする」作戦をとることに。
キャッシュするならフロントに近いほうがいいだろうということで、
フロントのnginxでキャッシュする作戦をとることにしました
(アクセス制限があるimageは難しいかもしれないけど、全部publicなiconならすぐできるだろうとこのときは思ってました)。</p>

<p>僕はnginxがconvertを駆逐してくれると信じて、MySQLに投げているクエリを中心にPerlのコードを見てました。
役割分担はこんな感じ。</p>

<ul>
<li>サーバの設定とか(@mackee_wさん)</li>
<li>nginxでキャッシュする設定(@9reさん)</li>
<li>コード読む、主にMySQLに投げてるクエリとか(@shogo82148)</li>
</ul>


<p>毎回、ひどいクエリが仕込まれているようなイメージがあったけど、
今回はそこまでひどくない。
クエリチューニング全然効果なさそうと判断して、次の作戦を考えることにしました。</p>

<h2>No Image Magick, use Imager!</h2>

<p>やっぱり一番のボトルネックは画像変換。
nginxでキャッシュするとはいえ軽いほうがいいよね、ということで、
外部プロセスで実行している画像変換をImagerを使ってPerlと同じプロセスでやる作戦。</p>

<p>Imagerに置き換え後ベンチにかけたら、若干スコアが・・・上がった・・・ような・・・？
しかし、画像が変化していると怒られて、スコアは無効。
画像エラーを修正するコストと、スコアの上がり具合を見て、Image Magickのままにすることにしました。</p>

<p>予選でも同じように外部プロセス起動している部分をPerlのライブラリにしたけど、
その時はあっさり動いた。
あれは外部プロセス起動をやめたらスコア上がると思い込ませるための布石だったんだ・・・。
(今回の場合、プロセスの起動より画像の変換のほうが重いので、スコアが上がらないのは当たり前)</p>

<h2>いろいろ諦めてPerl側でファイルキャッシュ</h2>

<p>Imagerはテストを通らず、nginxの設定キャッシュ設定も上手く動作しなかったので、
Perlでファイルキャッシュする方針に変更。
convertの結果にmvで適当な場所にコピーして保存。
これだけでスコアが5倍くらいに跳ね上がり、一気に上位に浮上！
最初からやっておくべきだった・・・。
もうちょっと早ければ特別賞もらえたかもしれないのに。</p>

<h2>rsync! rsync!</h2>

<p>ファイルキャッシュの作業をやっている間に、@mackee_wさんがnfsの設定をやってくれたので、
アップロードされたファイルやキャッシュファイルの保存先をnfsに変更。</p>

<p>あとは物量作戦でいくしかないだろうということで、rsyncで他のサーバにコピーして調整を繰り返してた。
(並行してnginxのキャッシュ設定にも再チャレンジしてたけど、nginx力が足りなかった)</p>

<h2>最終結果</h2>

<p>テストFAILした!! No Score!!</p>

<p>なんかこんなの前もあった！</p>

<h2>反省点</h2>

<ul>
<li>画像変換をGETでやってたけど、POSTでやったほうがよかったかも</li>
<li>nginxについて勉強しよう</li>
<li>nfsについて勉強しよう</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::NamespaceとRedis::Keyをリリースしました]]></title>
    <link href="http://shogo82148.github.io/blog/2013/10/18/redis-namespace-and-redis-key/"/>
    <updated>2013-10-18T23:21:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/10/18/redis-namespace-and-redis-key</id>
    <content type="html"><![CDATA[<p>こんばんは、最近シングルトン恐怖症になっているいっちーです。
<a href="https://metacpan.org/release/Redis-Namespace">Redis::Namespace</a>と
<a href="https://metacpan.org/release/Redis-Key">Redis::Key</a>をリリースしました。</p>

<!-- More -->


<h2>Redis::Namespace</h2>

<p>「<a href="http://shogo82148.github.io/blog/2013/09/14/redis-namespace-perl/">Redis::NamespaceのPerl版書いた</a>」
で紹介したモジュールをCPANizeしました。
コマンドのキー名に当たる部分に、自動にプレフィックスをつけてくれる賢い奴です。</p>

<p>```perl
use Redis;
use Redis::Namespace;</p>

<p>my $redis = Redis->new;
my $ns = Redis::Namespace->new(redis => $redis, namespace => 'fugu');</p>

<p>$ns->set('foo', 'bar');    # $redis->set('fugu:foo', 'bar');
my $foo = $ns->get('foo'); # my $foo = $redis->get('fugu:foo');
```</p>

<p>RedisにはKey-Value Storeなんてかっこいい名前が付いているけど、
結局はシステム全体で使えるグローバル変数なわけです。
グローバル変数は駆逐するべきです。
いちいちプレフィックスつけて名前の衝突を回避するなんて人間のやることとは思えません。</p>

<p>せめてモジュールローカルとか、クラスローカルとかある程度スコープを制限したいですよね。
Redis::Namespaceを使えば簡単に実現できます。</p>

<h2>Redis::Key</h2>

<p>Redis::Key は Redisのキーの簡単なラッパークラスです。
毎回毎回「接続先のRedisサーバ」と「キーの名前」を指定するのは面倒です。
この2つをセットにして、一つのオブジェクトとして扱うことができます。</p>

<p>```perl
use Redis;
use Redis::Key;</p>

<p>my $redis = Redis->new;
my $key = Redis::Key->new(redis => $redis, key => 'hoge');
$key->set('fugu'); # $redis->set('hoge', 'fuga');
$key->get;         # $redis->get('hoge');
```</p>

<p>普通に使っている限りは他のキーにアクセスすることができなくなるので、
Redis::Keyのオブジェクトを他のクラスに渡す、とかしても安心です。</p>

<p>あと、キーの名前の一部をプレースホルダーにして、あとから値を埋め込むこともできます。
キー名の一部に日付やIDを埋め込むっていうことが多いのでつけてみました。</p>

<p><code>perl
my $user_keys = Redis::Key-&gt;new(redis =&gt; $redis, key =&gt; 'user:{id}', need_bind =&gt; 1);
my $user = $user_keys-&gt;bind(id =&gt; 1001);
$user-&gt;get;  # $redis-&gt;get('user:1001');
</code></p>

<p>Key-Value Store はお手軽ではありますが、キーの名前に一定のルールを設けてあげないと
さすがに管理できなくなります。
Redis::Key を使ってルールを書くのが楽になるといいですね。</p>

<h2>Redis::Fast と Redis::Namespace と Redis::Key を組み合わせる</h2>

<p>Redis::Fast と Redis::Namespace は Redis.pm 互換なので組み合わせて使えます。</p>

<p><code>perl
my $redis = Redis::Fast-&gt;new;
my $ns1 = Redis::Namespace-&gt;new(redis =&gt; $redis, namespace =&gt; 'hoge');
my $ns2 = Redis::Namespace-&gt;new(redis =&gt; $ns1, namespace =&gt; 'fuga'); # Redis::Namespaceのネストもできる
my $key = Redis::Key-&gt;new(redis =&gt; $ns2, key =&gt; 'key'); # hoge:fuga:key という名前になる
</code></p>

<p>なんだか最近Redis関連のモジュールばかり書いてますが、
なんでもRedisに突っ込めばいいと思っているわけではありません。
Redisを使ったコードを読んでいたら目眩がしたからです。
ISUCON3の予選で使ったのはRedisを使いたかったらというより、
Redis::Fastを使いたかったからです。</p>
]]></content>
  </entry>
  
</feed>
