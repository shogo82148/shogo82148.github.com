<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-01-22T22:46:38+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.19リリースのお知らせ]]></title>
    <link href="https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/"/>
    <updated>2016-12-20T22:38:27+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/pod/Redis::Fast">Redis::Fast 0.19</a> をリリースしました。
主な変更点は以下の通りです。</p>

<ul>
<li><code>reconnect_on_error</code> オプションの追加</li>
<li>Sentinelのノード一覧が更新されない不具合の修正</li>
<li>IPv6の実験的サポート</li>
</ul>


<!-- More -->


<h2><code>reconnect_on_error</code> オプションの追加</h2>

<p><a href="https://github.com/yoheimuta">@yoheimuta</a>さんからのプルリクエストです。
今まではネットワークエラーが発生した時のみ再接続処理が走っていましたが、
Redisがエラーを返した場合にも再接続を行うようになります。
マスタースレーブ構成をしているときに、
何らかの原因によりRedis::Fastからのコネクションを維持したまま、
マスターがスレーブに降格してしまった場合に対処するための機能です。
以下のように設定することで、新しいマスターに再接続を行うことが可能になります。</p>

<pre><code class="perl">my $r = Redis::Fast-&gt;new(
    reconnect          =&gt; 1, # 0以上で再接続有効
    reconnect_on_error =&gt; sub {
        my ($error, $ret, $command) = @_;
        if ($error =~ /READONLY You can't write against a read only slave/) {
            return 1; # 再接続を行う。次の再接続まで最低1秒空ける
        }
        return -1; # 再接続は行わない
    },
);
</code></pre>

<h2>Sentinelのノード一覧が更新されない不具合の修正</h2>

<p>Redis::FastにはどれかひとつのSentinelノードに接続すると、
他のノードの情報を自動的に収集する機能があります。
この機能が最新のRedisでは動いていなかったので修正しました。
具体的にいつからなのかまでは追ってないのですが、
Redisのバージョン3.0.6から3.2.6の間のどこかで
ノード一覧の形式が変わってしまったようです。</p>

<p>(最近Sentinelの話題を聞かないけど、みんな使ってるのかな・・・)</p>

<h2>IPv6の実験的サポート</h2>

<p>サーバの指定にIPv6のアドレスが使えるようになりました。
<code>Redis::Fast-&gt;new(server =&gt; "[::1]:6379")</code> のような指定ができます。</p>

<p>バックエンドのhiredis自体は以前からIPv6に対応していたのですが、
今までRedis::Fastでは正しく動きませんでした。</p>

<p>とりあえずlocalhostに接続できることは確認しましたが、
手元にIPv6のネットワークがなくて検証もできていないため、
実験的サポートという扱いで・・・。
 誰かIPv6に詳しい方、検証お願いします。</p>

<h2>感想</h2>

<ul>
<li>テストがなかなか通らず辛かった</li>
<li>CPAN Autherを変な幾何学模様から変えたい</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DateTime.pmにうるう秒の修正が入った話]]></title>
    <link href="https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/"/>
    <updated>2016-12-15T22:17:47+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm</id>
    <content type="html"><![CDATA[<p>こんにちは、<a href="https://metacpan.org/pod/DateTime">DateTime.pm</a> Watcherのいっちーです。
本日面白いパッチがDateTime.pmに取り込まれたので、ご紹介したいと思います。</p>

<!-- More -->


<p>そのpullreqがこちらです。Closedになっていますが、該当コミットはmasterに取り込まれています。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/pull/48">The leap second in 2012 was on 2012-07-01 not 2012-06-01. #48</a></li>
</ul>


<blockquote><p>per <a href="https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction">https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction</a> the leap second in 2012 was on 2012-07-01 not 2012-06-01. It&rsquo;s is well known that leap seconds only occur directly before Jan 1st or July 1st.</p></blockquote>

<p>適当な和訳「2012年に挿入されたうるう秒は2012年6月1日ではなく2012年7月1日です。よく知られているように、今までに挿入されたうるう秒は1月1日と7月1日の直前だけです。」</p>

<pre><code class="diff">diff --git a/lib/DateTime/LeapSecond.pm b/lib/DateTime/LeapSecond.pm
index 66e1b2b..4a38be2 100644
--- a/lib/DateTime/LeapSecond.pm
+++ b/lib/DateTime/LeapSecond.pm
@@ -108,7 +108,7 @@ sub _initialize {
             1999  Jan. 1  +1
             2006  Jan. 1  +1
             2009  Jan. 1  +1
-            2012  Jun. 1  +1
+            2012  Jul. 1  +1
             2015  Jul. 1  +1
             2017  Jan. 1  +1
             )
</code></pre>

<p>なぜ4年間誰も気が付かなかった。</p>

<h2>このバグの影響</h2>

<p>結論から言うと、<strong>この修正によるDateTime.pmの挙動への影響はありません</strong>。
これを書いている時点で最新版のver1.41には、上記の修正は取り込まれていませんが、
うるう秒は2012年7月1日に正しく挿入されます。</p>

<p>以前<a href="//shogo82148.github.io/blog/2015/12/09/perl-datetime/">Perl の DateTime 利用上の注意点</a>で
うるう秒の確認をしたときと同様に検証してみましょう。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 7, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 6, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59

$ PERL_DATETIME_PP=1 perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59
</code></pre>

<p>DateTime.pmにはXSの実装とPurePerlの実装が含まれていますが、
どちらの実装でも2012年7月1日に正しくうるう秒が挿入され、2012年6月1日にはうるう秒はありません。</p>

<p><a href="https://twitter.com/kazoo04/status/808195587518578688">https://twitter.com/kazoo04/status/808195587518578688</a>">https://twitter.com/kazoo04/status/808195587518578688">https://twitter.com/kazoo04/status/808195587518578688</a></a></p>

<p>まさに、「コード見たら絶対動かないはずなのになぜか思った通りにちゃんと動く」といった感じです。</p>

<h2>なぜ正しく動くのか</h2>

<p>なぜ正しく動くのか、その答えはうるう秒一覧の解析を行う部分にありました。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/blob/ff0e3780ea1c841eb17a0245f5f8061cf10c28d3/lib/DateTime/LeapSecond.pm#L40-L41">DateTime.pm/lib/DateTime/LeapSecond.pm</a></li>
</ul>


<pre><code class="perl">my $utc_epoch
    = DateTime-&gt;_ymd2rd( $year, ( $mon =~ /Jan/i ? 1 : 7 ), $mday );
</code></pre>

<p><strong>Jan.(1月)以外はすべて7月として扱っている！</strong></p>

<p>Janか否かが重要なので、JunだろうがJulだろうが7月として扱われるので、結果的に正しく動くわけです。
「バグを埋め込んでいたけど、実装が適当でたまたま動いていた」というよくあるパターンですね。
将来3月末や9月末に挿入されるようになったとき大丈夫なんでしょうか・・・。
まあ、必要になるのは数百年後とかなので、僕には関係ない・・・そう、関係ないのです・・・。</p>

<h2>まとめ</h2>

<ul>
<li>DateTime.pmのうるう秒一覧にbug fix</li>
<li>動作に影響は無いので、ユーザ側では特に気にする必要はない

<ul>
<li>うるう秒自体を気にしないといけないのは仕方がない・・・</li>
</ul>
</li>
<li>JanとかJunとかJulとか似てて紛らわしいんだよ！！数字書け！！</li>
</ul>


<h2>ちなみに</h2>

<p>最新版のver1.41は来年(2017年)の1月1日のうるう秒に対応済みです。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2017, month =&gt; 1, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2017-01-01T08:59:60
</code></pre>

<p>みなさん準備は出来ていますか 😇</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlでもGoでも実行できるQuine書いた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/"/>
    <updated>2016-04-06T10:07:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/">昨日のPolyglot</a>を元にPerlでもGoでも実行できるQuine書いた。</p>

<!-- More -->


<pre><code>package main;import("fmt");var(q=`printf'package main;import("fmt");var(q%c%c%s%c/*%c);sub import{}sub var{$_%cshift%c~s!%c(.*)%c/\*!$1!gr;eval}%c__END__%c',61,96,$_,96,61,61,61,96,96,10,10;print&lt;DATA&gt;`/*=);sub import{}sub var{$_=shift=~s!`(.*)`/\*!$1!gr;eval}
__END__
*/);func main(){s:=`package main;import("fmt");var(q=%c%s%c/*=);sub import{}sub var{$_=shift=~s!%c(.*)%c/\*!$1!gr;eval}
__END__
*/);func main(){s:=%c%s%c;fmt.Printf(s,96,q,96,96,96,96,s,96)}
`;fmt.Printf(s,96,q,96,96,96,96,s,96)}
</code></pre>

<p>Perlで実行してもGoで実行しても自分自身を出力します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlとGolangで実行できるPolyglot書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/"/>
    <updated>2016-04-05T12:27:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang</id>
    <content type="html"><![CDATA[<p>Rubyの会社をPerlの会社に変えてしまおう計画。
Golangのフリをして忍び込ませれば行けるのではという話になったので、
GoでもPerlでも実行できるコードを書いてみた。</p>

<!-- More -->


<p>出来上がったのがこちら。</p>

<pre><code class="plain">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>一番のポイントは<code>var (s=0/*==);</code>の行ですね。
Perlで解釈すると正規表現置換<code>s///</code>として解釈され、<code>/*</code>が無視されます。
Goで解釈すると変数<code>s</code>への代入として解釈され、<code>/*</code>がコメントとして扱われます。</p>

<p>あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。</p>

<ul>
<li><code>package main</code> はGoでもPerlでも似たような意味で解釈されるのでそのまま</li>
<li>Goの <code>import</code>, <code>var</code> はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする</li>
<li>省略可能なセミコロンをちゃんと書く</li>
</ul>


<p>GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、
<code>import</code> だけGoでもPerlでも解釈されてしまうというという制限があります。
<code>import</code> するパッケージが一個だけなら問題ないんですが、
複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。
(Perlでは文字列結合として解釈される。Goでは<code>var</code>のあとに<code>import</code>かけないっぽいので、ここに押し込むしかない。)</p>

<pre><code class="plain">package main;
import (
  "fmt"
  . "math"
);
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu", Pi) }
</code></pre>

<p>もっと簡潔にかけないかな。</p>

<h2>追記</h2>

<p>シンタックスハイライトしてみたらわかりやすいかなと思ってやってみた。</p>

<p>Perlのシンタックスハイライト。</p>

<pre><code class="perl">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>Goのシンタックスハイライト。</p>

<pre><code class="go">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="https://golang.org/ref/spec">The Go Programming Language Specification</a></li>
<li><a href="http://d.hatena.ne.jp/sugyan/20110306/1299418878">polyglot 基礎の基礎</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを公開しました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules/"/>
    <updated>2016-03-18T22:16:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules</id>
    <content type="html"><![CDATA[<p>以前<a href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/">Redisでスコアを複数設定できるランキングを作ってみた</a>けど、
Githubの肥やしになっていてもあれなので、CPANizeしました。
あわせて、この実装のために作ったユーティリティモジュールも別モジュールとして公開しました。</p>

<ul>
<li><a href="https://metacpan.org/pod/Redis::LeaderBoardMulti">Redis::LeaderBoardMulti</a></li>
<li><a href="https://metacpan.org/pod/Redis::Script">Redis::Script</a></li>
<li><a href="https://metacpan.org/pod/Redis::Transaction">Redis::Transaction</a></li>
</ul>


<!-- More -->


<h2>Redis::LeaderBoardMulti</h2>

<p>最初の基準で順位を決められなかった場合の第二基準が欲しいというときに使うモジュールです。
インターフェースがRedis::LeaderBoard互換になるように調整したので、
前回とインターフェースがちょっと変わっています。</p>

<pre><code class="perl">se Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
# Redis::LeaderBoardに合わせて複数指定できるようになりました
$lb-&gt;set_score(
    'one' =&gt; [100, time],
    'two' =&gt; [ 50, time],
);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p>Redis::LeaderBoard互換なのでそのまま入れ替えられるはずですが、以下のような実装上の制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
<li>同順の場合の出現順

<ul>
<li>Redis::LeaderBoard は ZRANK, ZREVRANK を使い分けているので、orderパラメータによって昇順/降順が変わります</li>
<li>Redis::LaederBoardMulti は ZRANK しか使わないので、必ず昇順になります</li>
</ul>
</li>
</ul>


<p>一応 Lua Script を使わないオプションもそのまま残してありますが、特に理由がない限りデフォルト(Lua Script を使う)で使うといいと思います。
どうしてもロックの範囲が広くなってしまう場合があり、楽観的ロックでは効率が悪いケースがあるためです。</p>

<h2>Redis::Script</h2>

<p>EVALSHAを簡単に使うためのモジュールです。
EVALコマンドを使うとLua Scriptの実装ができますが、毎回毎回実行するスクリプト全体を送る必要があります。
EVALSHAコマンドはその代わりにスクリプトのSHA1ハッシュを送ることで、帯域の節約ができるというコマンドです。
しかしEVALSHAはSHA1ハッシュを事前に登録する必要があり、どのタイミングで登録を行うかが問題になってきます。</p>

<p><a href="http://redis.io/commands/eval">EVALコマンドのドキュメント</a>によると、
「EVALSHAで実行してみて <code>NOSCRIPT No matching script</code> で失敗したらEVALでやり直す」というのがおすすめらしいです。
EVALコマンドはSHA1ハッシュの登録も行ってくれるので、初回 <code>NOSCRIPT</code> になっても次回からはEVALSHAが成功します。</p>

<p>そんなに複雑なことではないのですが、毎回書くのも大変なのでモジュールとして切り出したのが Redis::Script です。
以下のようにスクリプトオブジェクトを作っておいて、パラメータを渡して実行します。</p>

<pre><code class="perl">use Redis;
use Redis::Script;
my $script = Redis::Script-&gt;new(script =&gt; "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}");
my ($key1, $key2, $arg1, $arg2) = $script-&gt;eval(Redis-&gt;new, ['key1', 'key2'], ['arg1', 'arg2']);
</code></pre>

<p><code>$script</code> が計算済みのSHA1ハッシュを保存しておいてくれるので、計算リソースの節約にもなるはずです。
(ベンチとってみたところ、スクリプトのサイズが1kBから10kBくらいにならないと効果なさそうでしたが・・・)</p>

<h2>Redis::Transaction</h2>

<p>Redisのトランザクションを簡単に行うためのモジュールです。</p>

<p>MULTI-EXECは単に実行するだけなら、MULTIとEXECで囲うだけでよいので簡単です。
例えば、 <code>foo</code> と <code>bar</code> を同時にインクリメントしたい場合、以下のようにすると実現できます。</p>

<pre><code class="perl">$redis-&gt;multi;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
$redis-&gt;exec; # 他のクライアントからはfooとbarが全く同時にインクリメントされたように見える
</code></pre>

<p>ただ、このような素朴な実装だと、途中でネットワークが不調になった場合などに再接続処理が止まったままになる可能性があります。
例えば以下のようにトランザクションの中で例外が発生すると、以後そのコネクションを使おうとしたときにエラーになります。
コネクションの永続化をしている場合はしばらくエラーが出続けることになり問題です。</p>

<pre><code class="perl">eval {
    $redis-&gt;multi; # トランザクション開始
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
    $redis-&gt;exec;
};
$redis-&gt;ping; # 繋がらなくなる
</code></pre>

<p>Redis::Transaction はこのような問題を防ぐためのモジュールです。
トランザクションが失敗したときの後始末をよしなにやってくれるので、万が一エラーになっても安心です。</p>

<pre><code class="perl">multi_exec Redis-&gt;new, 1, sub { # 1は失敗したときのリトライ回数
    my $redis = shift;
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
};
$redis-&gt;ping; # 繋がる！
</code></pre>

<p>WATCH-MULTI-EXECを使った楽観的ロックも扱えます。
Redisのトランザクションは楽観的ロックなので、
処理中に他のクライアントが書き換えを行った場合に失敗する可能性があります。
その場合でもリトライを行ってくれて便利です。</p>

<pre><code class="perl"># $redis-&gt;incr('mykey') をトランザクションを使って実現する
watch_multi_exec Redis-&gt;new, ['mykey'], 10, sub {
    my $redis = shift;
    return $redis-&gt;get('mykey');
}, sub {
    my ($redis, $value) = @_;
    $redis-&gt;set('mykey', $value + 1);
};
</code></pre>

<h2>まとめ</h2>

<p>Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを紹介しました。
それぞれは小さなモジュールですが、
トラブル発生時にも問題にならないようちゃんとした実装しようとすると、
意外と考えることが多く面倒なものです(特にトランザクション周りとか)。
適当に実装してしまったこころ当たりのある人は、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
</feed>
