<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2013-10-13T23:30:01+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis::Fastをcpanize＆アップデートしました]]></title>
    <link href="http://shogo82148.github.io/blog/2013/10/13/cpanize-redis-fast/"/>
    <updated>2013-10-13T22:39:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/10/13/cpanize-redis-fast</id>
    <content type="html"><![CDATA[<p>Redis::Fastを<a href="https://metacpan.org/release/Redis-Fast">cpanizeしました！</a></p>

<p>さらに！早速不具合が見つかったので0.01から0.02にアップデートしました！</p>

<!-- More -->


<p>CPANに上げてから24時間も経たないうちにpull requestがやってきてCPAN怖いところです。</p>

<p>最初のバージョンである0.01ではタイムアウト処理をちゃんと書いていなかったので、
タイムアウト時に無限ループに陥る不具合がありました。
LinuxとMacとでコネクションを張るのに失敗したときの挙動が違うらしく、
Linuxでは問題なくテストが通るのに、Mac上でのテストでは再現するという面倒バグでした。
さらに面倒なことにRedisの起動のタイミングによって、
Macでもテストが通ったり通らなかったりするという・・・。</p>

<p>主に開発はLinux上でやって、Linux上でしかテスト動かしてなかったので全く気がついていませんでした。
CPANデビューのモジュールがネットワーク関連でXSで少しハードルを上げ過ぎた感じがします。
環境依存な部分が多くてつらいです。</p>

<p>pull requestを送ってくださったsyohexさん、実際にインストールを試みてテストが通らないことを教えてくださったみなさん、ありがとうございました。
アップデートした0.02では、タイムアウト時の処理を少し書きなおして、pull requestも取り込みました。
Mac上でも問題なくテストが通ってインストールできるはずです(きっとね)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ISUCON3の予選に参加してきた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/10/07/isucon3-qualify/"/>
    <updated>2013-10-07T13:03:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/10/07/isucon3-qualify</id>
    <content type="html"><![CDATA[<p>こんにちは、いつの間にかチームぽわわ2のメンバーになっていたいっちーです。</p>

<p><a href="https://twitter.com/9re">@9re</a>さんと
<a href="https://twitter.com/mackee_w">@mackee_w</a>さんとでISUCON3の予選に参加してきました。
主にアプリの書き換えを担当していたので、やったことを残しておきます。
チーム全体の方針とか役割分担とかはまこぴー先生の<a href="http://mackee.hatenablog.com/entry/2013/10/06/230412">#isucon 予選でとりあえず10位だった</a>を参照。</p>

<!-- More -->


<h2>お題</h2>

<p>gistみたいなWebアプリ。
<a href="http://shogo82148.github.io/blog/2013/04/13/isucon/">社内ISUCON</a>のときと似たようなお題ですね。
違いは...</p>

<ul>
<li>スターは無い</li>
<li>Recent Postsのサイドバーが無い代わりに、ページングしてたどっていけるページがある</li>
<li>privateな投稿ができる</li>
<li>Markdown形式で投稿できて、表示はHTMLでレンダリングされる</li>
</ul>


<p>詳しくは、れもんさんの<a href="http://isucon.net/archives/32853582.html">#isucon 2013年予選問題の解説など</a>を参照。</p>

<h2>やったこと</h2>

<p>一言で言えば、Redisにキャッシュするようにしました。</p>

<h3>RecentをRedisのリストで管理</h3>

<p>Recentの表示で日付順ソートしているのが重たそうだったので、
公開メモのソート結果をあらかじめRedisのリストに入れておく作戦。</p>

<p>Redisの<code>SORT</code>コマンドが高機能で面白いなーって思ってたので使ってみました。
リストにはメモのIDだけ入れておいて、メモの実体は別のキーを参照する、なんてことができます。
このコマンド、<code>SORT</code>って名前なのに「ソートしない」ってオプションあるところがいいですよね！</p>

<p>MySQLがボトルネックになっているのはこれで解消できました。</p>

<h3>bin/markdownを使わない＆レンダリング結果をキャッシュ</h3>

<p>Markdownのレンダリングを外部コマンド叩いてやっていたので、
<a href="https://metacpan.org/module/Text::Markdown::Discount">Text::Markdown::Discount</a>を使ってレンダリングするように変更。
qx{hoge}って記法はじめて見ました。Perlってやつはいろんな書き方があってよくわからないです。</p>

<p>Markdownの文法って亜種が結構あるので、レンダラをかえるのはちょっと怖かったんですが、全く問題なし。
スコアも3000くらい上がってかなり効果がありました。</p>

<p>さらにレンダリング結果をRedisに入れてキャッシュで+1000くらい。</p>

<h3>Recentのレンダリング結果をキャッシュ</h3>

<p>RecentをRedisでさばくようにしたけど、そもそも100要素もあるHTMLのレンダリングそうとう重いはず。
と、いうわけでここもRedisにキャッシュするようにしました。
公開メモが投稿されたらRecent/:pageのキャッシュを全部削除。
Postのたびにキャッシュクリアされるのであんまり効果ないかなーと思っていたけど、わりと効果あったみたい？
(正確なスコアよく見てなかった)</p>

<h3>Redis::Fast!!</h3>

<p>残り時間も少なくなり時間内にできることも限られれきたので、最後の最後で<a href="https://github.com/shogo82148/Redis-Fast">Redis::Fast</a>を投入。
これで+1000くらい上がったらしい。(正確なスコアよく見てなかった)</p>

<p>s/Redis/Redis::Fast/ するだけの簡単なお仕事の予定が、githubからのインストールに一番手間取った。
cpanfileにgitのレポジトリを書くと(非公式だけど)インストールできるよ！ってどこかで見た気がするけどなかなかうまく行かず、
自分で<code>git clone</code>してそのディレクトリを指定してインストール(したってまこぴー先生が言ってた)。
(<code>hiredis.h</code>が無い！って叫んでいたから、cartonがsubmoduleをうまく処理できていなかったと予想。
非公式の機能に頼るの良くないね。)</p>

<h2>できなかったこと</h2>

<ul>
<li>my.cnf？なにそれ美味しいの？</li>
<li>SQLクエリをいじる余裕がなかった

<ul>
<li>Newer/Olderのクエリが残念なのはわかってたけど、結局いじってない</li>
</ul>
</li>
<li>Nginxでキャッシュしたい</li>
<li>必要なモジュールは事前にCPANにあげておこう。</li>
</ul>


<h2>まとめ</h2>

<p>結果は13192.1点で10位でした。
特に問題がなければこのまま予選突破できるはず・・・！</p>

<p>ところで、魔王軍が学生枠を制圧していて恐ろしいですね。
てか、<a href="http://shiro-goma.hatenablog.com/entry/2013/10/07/202913">僕らのチームとの差、500点程度しか無いじゃないですか</a>。怖！！！
これ以上の侵攻はなんとしてでも食い止めなければ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::NamespaceのPerl版書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/09/14/redis-namespace-perl/"/>
    <updated>2013-09-14T18:36:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/09/14/redis-namespace-perl</id>
    <content type="html"><![CDATA[<p><a href="http://redis.io/">Redis</a> のキーにプリフィックスつけるの面倒だなー自動的につけてくれないかなーと思い、
調べてみると Ruby に <a href="https://github.com/resque/redis-namespace">Redis-Namespace</a> というものがあるらしい。
だけども、Perl では探しても見つからなかったので書いてみた。</p>

<p>レポジトリはこちら→<a href="https://github.com/shogo82148/Redis-Namepace">Redis::Namespace</a></p>

<!-- More -->


<h2>使い方</h2>

<p>インターフェースは <a href="http://search.cpan.org/~melo/Redis/">Perl Redis</a> と一緒。
コマンドのキー名に当たる部分に、自動的にプレフィックスをつけてくれる。</p>

<p>``` perl
use Redis;
use Redis::Namespace;</p>

<p>my $redis = Redis->new;
my $ns = Redis::Namespace(redis => $redis, namespace => 'fugu');</p>

<p>$ns->set('foo', 'bar');    # $redis->set('fugu:foo', 'bar');
my $foo = $ns->get('foo'); # my $foo = $redis->get('fugu:foo');
```</p>

<p>大体のコマンドには対応したつもり。
別のプレフィックスがついたキーには基本的にアクセスできなくなるので、
キー名の管理が少し楽になると思います。</p>

<p>でも、flushdb とか flushall すると全部消えるので気をつけてね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl の Redis ライブラリを調べた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/08/24/perl-redis-libraries/"/>
    <updated>2013-08-24T17:51:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/08/24/perl-redis-libraries</id>
    <content type="html"><![CDATA[<p>最近<a href="http://redis.io/">Redis</a> を使ったコードを書くようになったのですが、
キー名を毎回指定するのがだるいです。
Ruby には <a href="https://github.com/nateware/redis-objects">redis-objects</a> というのがあって、
Redisのキーをオブジェクトとして扱うことができるようです。
きっと、Perl にも似たようなのあるだろ、って思って調べてみました。</p>

<!-- More -->


<h2>ほしいもの</h2>

<p>低レベルなRedisのライブラリはたいていメソッドとRedisのコマンドが一対一対応していて、
次のようなコードになると思います。</p>

<p><code>perl hogehoge.pl
$redis-&gt;set('key-name', 'piyopiyo');
$redis-&gt;get('key_name');
</code></p>

<p>でも、Redisに何か操作をしたいわけじゃなくて、
Redisのキーに対して操作をしたいので、
次のように書けるべきだと思うんです。</p>

<p><code>perl expected.pl
my $key = key($redis, 'key-name');
$key-&gt;set('piyopiyo');
$key-&gt;get();
</code></p>

<h2>Redis::Hash, Redis::List</h2>

<p><a href="http://search.cpan.org/~melo/Redis/lib/Redis/Hash.pm">Redis::Hash</a>と
<a href="http://search.cpan.org/~melo/Redis/lib/Redis/List.pm">Redis::List</a>は
Perlのハッシュや配列と同じ操作で Redis にアクセスできるようにするライブラリ。</p>

<p>``` perl Redis::Hash
use utf8;
use warnings;
use strict;
use 5.014;</p>

<p>use Redis::Hash;</p>

<p>tie my %my_hash, 'Redis::Hash', 'hash_prefix', (server => 'localhost:6379');</p>

<h1>set hash_prefix:hogehoge piyopiyo</h1>

<h1>set hash_prefix:fugafuga fugufugu</h1>

<p>$my_hash{hogehoge} = 'piyopiyo';
$my_hash{fugafuga} = 'fugufugu';</p>

<h1>get hash_prefix:hogehoge piyopiyo</h1>

<p>say $my_hash{hogehoge}; # piyopiyo</p>

<h1>keys hash_prefix:*</h1>

<p>say join ',', keys %my_hash; #fugafuga,hogehoge</p>

<h1>keys hash_prefix:*</h1>

<h1>get hash_prefix:fugafuga</h1>

<h1>get hash_prefix:hogehoge</h1>

<p>say join ',', values %my_hash; #fugufugu,piyopiyo</p>

<h1>del hash_prefix:hogehoge</h1>

<p>delete $my_hash{hogehoge};
```</p>

<p>tie とかよくわかない。
Perl の黒魔術を見た気がしました。</p>

<p>普通のハッシュや配列に見えるのは面白いけど、
Redisっぽい機能がまったく使えないのはつらい。
<code>tied(%my_hash)-&gt;cmd</code> って書けばコマンド発行できるけど、
それなら最初から直接 <a href="http://search.cpan.org/~melo/Redis/lib/Redis.pm">Redis.pm</a> を
使えよって話になります。</p>

<p>あと、tie するごとにコネクションを張り直しているようなので、
たくさんのハッシュやリストを作ると大変なことになりそうです。</p>

<h2>Redis::Client</h2>

<p>これも tie すると、Redis上のデータをハッシュや配列として扱うことができます。
tie できるのは <a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/String.pm">String</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/List.pm">List</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Hash.pm">Hash</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Set.pm">Set</a>,
<a href="http://search.cpan.org/~friedo/Redis-Client/lib/Redis/Client/Zset.pm">Zset</a>。
それぞれがRedisで使えるデータ型に対応している。</p>

<p>``` perl Redis::Client::String
use utf8;
use warnings;
use strict;
use 5.014;</p>

<p>use Redis::Client;</p>

<p>my $client = Redis::Client->new;
tie my $str, 'Redis::Client::String', key => 'my_string', client => $client;</p>

<p>$str = 'foo';
say $str;
```</p>

<p>ひとつのキーに対してひとつのオブジェクトを割り当てるのは良さげ。
また、ハッシュ型、セット型、ソート済みセット型といった、Redis特有のデータ型に対応しているのもGood。
でも、ただストアするだけならこれで十分だけど、もう少し高度な機能も使いたい・・・。</p>

<h2>Tie::Redis</h2>

<p><a href="http://search.cpan.org/~dgl/Tie-Redis/lib/Tie/Redis/Hash.pm">Tie::Redis</a> も
tie を使ってPerlのデータ構造っぽく扱えるようにするライブラリ。</p>

<p>Redis全体を一つのハッシュとして扱ったり、
Redisの文字列型、ハッシュ型、リスト型を扱えるみたい。</p>

<h2>Redis::Object</h2>

<p><a href="http://search.cpan.org/~ukautz/Redis-Object/README.pod">Redis::Oject</a>は
ORM風なRedis用ライブラリ。</p>

<p>``` perl RedisDatabase.pm
package MyRedisDatabase;</p>

<p>use Moose;
extends qw/ Redis::Object /;</p>

<p>has tables => (</p>

<pre><code>isa     =&gt; 'ArrayRef[Str]',
is      =&gt; 'ro',
default =&gt; sub { [ qw/SomeTable/ ] },
</code></pre>

<p>);</p>

<p><strong>PACKAGE</strong>->meta->make_immutable;
```</p>

<p>``` perl RedisDatabase/SomeTable.pm
package MyRedisDatabase::SomeTable;</p>

<p>use Moose;
with qw/ Redis::Object::Table /;</p>

<p>has hoge => ( isa => 'Str', is => 'rw', default => 'Something' );</p>

<p><strong>PACKAGE</strong>->meta->make_immutable;
```</p>

<p>``` perl redis-object.pl
use utf8;
use strict;
use warnings;
use 5.014;</p>

<p>use MyRedisDatabase;</p>

<h1>init database</h1>

<p>my $db = MyRedisDatabase->new(</p>

<pre><code>server =&gt; 'localhost:6379'
</code></pre>

<p>);</p>

<h1>create item</h1>

<p>my $item = $db->create( SomeTable => {</p>

<pre><code>hoge =&gt; "Hello",
</code></pre>

<p>} );</p>

<h1>fetch item by id</h1>

<p>$item = $db->find( SomeTable => $item->id );</p>

<h1>update item</h1>

<p>$item->hoge( "piyo" );
```</p>

<p>ORMっぽいけど、あんまり複雑な検索はできないらしい。
ここまでするなら普通にMySQLとORMつかったほうが良さそう。</p>

<h2>まとめ</h2>

<p>みんな tie が大好き。</p>

<p>tie しないのがほしいな・・・。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ランダム抽出アルゴリズムについて考える]]></title>
    <link href="http://shogo82148.github.io/blog/2013/07/13/random-sample/"/>
    <updated>2013-07-13T22:13:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/07/13/random-sample</id>
    <content type="html"><![CDATA[<p>数日前に社内IRCで「スマートな非復元抽出の方法はないか」と話題になったので、
ランダムサンプリングのアルゴリズムについて調べたり考えたりしてみた。</p>

<!-- More -->


<h2>復元抽出</h2>

<p>非復元抽出の手法って調べてもなかなか出てこない・・・。
ひとまず、復元抽出についてまとめてみましょう。</p>

<h3>線形検索</h3>

<p>一番簡単な実装方法。
どの区間に入るかを線形検索して求める。
選択肢の個数nとすると計算量はO(n)。</p>

<p>``` perl linear_search_method.pl
use strict;
use warnings;
use List::Util qw(sum);</p>

<p>sub linear_search_method {</p>

<pre><code>my $weights = shift;
my $num = shift;
my $sum = sum @$weights;
my $length = @$weights;
my @a;

for (1..$num) {
    my $r = rand($sum);
    for my $i(0..$length-1) {
        $r -= $weights-&gt;[$i];
        if($r &lt; 0) {
            push @a, $i;
            last;
        }
    }
}
return \@a;
</code></pre>

<p>}</p>

<p>print join ', ', @{linear_search_method [1,2,3], 100};
```</p>

<h3>バイナリサーチ</h3>

<p>あらかじめ累積分布表を作っておき、どの区間に入るかをバイナリサーチ。
準備にO(n)、選択に O(log n)かかる。</p>

<p>``` perl binary_search_method.pl
use strict;
use warnings;
use List::Util qw(sum);</p>

<p>sub binary_search_method {</p>

<pre><code>my $weights = shift;
my $num = shift;
my $length = @$weights;
my @a;
my @b;

my $sum = 0;
for my $i(@$weights) {
    push @a, $sum;
    $sum += $i;
}
push @a, $sum;

for (1..$num) {
    my $r = rand($sum);
    my ($l, $h) = (0, $length + 1);
    while($h - $l &gt; 1) {
        my $i = ($l + $h) &gt;&gt; 1;
        if($r &lt; $a[$i]) {
            $h = $i;
        } else {
            $l = $i;
        }
    }
    push @b, $l;
}
return \@b;
</code></pre>

<p>}</p>

<p>print join ', ', @{binary_search_method [1,2,3], 100};
```</p>

<h3>Walker's alias method</h3>

<p>今回調べて初めて知ったアルゴリズム。
準備にO(n)、ランダム選択はなんと定数時間O(1)でできる。</p>

<p>``` perl walers_alias_method.pl
use strict;
use warnings;
use List::Util qw(sum);</p>

<p>sub walkers_alias_method {</p>

<pre><code>my $weights = shift;
my $num = shift;
my $sum = sum @$weights;
my $length = @$weights;

my @p = map { $_ / $sum * $length} @$weights;
my @a = (0..$length-1);

my ($h, $l) = (0, $length - 1);
my @hl;
for my $i(0..$length-1) {
    if ( $p[$i] &gt;= 1) {
        $hl[$h++] = $i;
    } else {
        $hl[$l--] = $i;
    }
}

while($h != 0 &amp;&amp; $l != $length - 1) {
    my ($j, $k) = @hl[$l+1, $h-1];
    $a[$j] = $k;
    $p[$k] += $p[$j] - 1;
    $l++;
    if ( $p[$k] &lt; 1 ) {
        $hl[$l--] = $k;
        $h--;
    }
}

return [map {
    my $r = rand($length);
    my $k = int($r);
    $r -= $k;
    $r &lt; $p[$k] ? $k : $a[$k];
} 1..$num];
</code></pre>

<p>}</p>

<p>print join ', ', @{walkers_alias_method [1,2,3], 100};
```</p>

<h2>非復元抽出</h2>

<p>復元抽出のアルゴリズムを応用して、非復元抽出について考えてみましょう。
一度出たものが2回でないよう、出たものの重みを0にします。</p>

<h3>線形検索</h3>

<p>線形検索の場合は、重みリストをほぼそのまま使っているので、更新は簡単。
一度出たものの重みを0にして、総和を更新するだけ。</p>

<p>``` perl linear_method.pl
use strict;
use warnings;
use List::Util qw(sum);</p>

<p>sub linear_method {</p>

<pre><code>my $weights = shift;
my $num = shift;
my $sum = sum @$weights;
my $length = @$weights;
my @w = @$weights;
my @a;

for (1..$num) {
    my $r = rand($sum);
    for my $i(0..$length-1) {
        $r -= $w[$i];
        if($r &lt; 0) {
            push @a, $i;

             # 一度出たものの重みを0にする
            $sum -= $w[$i];
            $w[$i] = 0;
            last;
        }
    }
}
return \@a;
</code></pre>

<p>}</p>

<p>print join ',', linear_method([1 .. 100000], 500);
```</p>

<h3>二分木</h3>

<p>バイナリサーチでは累積分布表を作成したけど、
これの更新にはO(n)かかってしまうのでバイナリサーチの意味がなくなってしまう。
そこで重みを二分木を使って管理することで、O(log n)で重みの更新ができる。</p>

<p>``` perl tree.pl
use strict;
use warnings;
use List::Util qw(sum);</p>

<p>sub binary_search_method {</p>

<pre><code>my $weights = shift;
my $num = shift;
my $length = @$weights;

# 二分木を構築
my @left_weight = (0) x ($length * 2);
my @right_weight = ((0) x $length, @$weights);
for (my $i = $length-1; $i&gt;0; --$i) {
    $left_weight[$i] = $left_weight[$i*2] + $right_weight[$i*2];
    $right_weight[$i] = $left_weight[$i*2+1] + $right_weight[$i*2+1];
}

my @a;
for (1..$num) {
    # 二分木から検索
    my $i = 1;
    my $r = rand($left_weight[$i] + $right_weight[$i]);
    while($i &lt; $length) {
        if($r &lt; $left_weight[$i]) {
            $i = $i * 2;
        } else {
            $r -= $left_weight[$i];
            $i = $i * 2 + 1;
        }
    }
    push @a, $i - $length;

    # 木を更新
    my $w = $weights-&gt;[$i-$length];
    while($i &gt; 0) {
        if($i % 2 == 0) {
            $left_weight[$i&gt;&gt;1] -= $w;
        } else {
            $right_weight[$i&gt;&gt;1] -= $w;
        }
        $i &gt;&gt;= 1;
    }
}

return \@a;
</code></pre>

<p>}</p>

<p>print join ',', binary_search_method([1..100000], 500);
```</p>

<h2>その他</h2>

<p>Walker's alias method でも更新法を考えたけど、
テーブルを一から再生成する以外にいい方法が思いつかない。</p>

<p>抽出が高速であるという特徴を利用して、
同じ物が出たらもう一度実行するというのが手っ取り早そう。
Walker's alias method が必要なときは n が十分に大きいはずなので、
重複が起こる確率は小さく、これで十分なきがする。</p>

<h2>まとめ</h2>

<table>
<tr>
  <th>手法</th><th>準備</th><th>抽出</th><th>重み更新</th>
</tr>
<tr>
  <td>線形検索</td><td>O(n)</td><td>O(n)</td><td>O(1)</td>
</tr>
<tr>
  <td>バイナリサーチ</td><td>O(n)</td><td>O(log n)</td><td>O(log n)</td>
</tr>
<tr>
  <td>Walker's alias</td><td>O(n)</td><td>O(1)</td><td>O(n)</td>
</tr>
</table>


<h2>参考</h2>

<ul>
<li><a href="http://d.hatena.ne.jp/koiti_yano/20070826/p1">比較的高速な復元抽出アルゴリズム</a></li>
<li><a href="http://tolstoy.newcastle.edu.au/R/devel/05/06/1403.html">efficiency of sample() with prob</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
