<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2015-03-20T18:51:16+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis::Fastってモジュールを書いた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/09/28/redis-fast/"/>
    <updated>2013-09-28T00:18:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/09/28/redis-fast</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/redis/hiredis">hiredis</a>をPerlから扱うためのライブラリとして
<a href="http://search.cpan.org/~neophenix/Redis-hiredis/lib/Redis/hiredis.pm">Redis::hiredis</a>ってのがあるけど、
なんだか微妙だって聞いたので自分でPerlのhiredisバインディング書いてみたよ。</p>

<ul>
<li><a href="https://github.com/shogo82148/Redis-Fast">https://github.com/shogo82148/Redis-Fast</a></li>
</ul>


<p>(READMEからRedis.pmをそのまま持ってきたことがまるわかりですね。なんとかしよう。)</p>

<!-- More -->


<h2>使い方</h2>

<p><a href="http://search.cpan.org/~melo/Redis-1.961/lib/Redis.pm">Redis.pm</a>と全く同じインターフェースなので、
そのまま置換できる、はず。</p>

<p>``` perl
use Redis::Fast;
my $redis = Redis::Fast->new;</p>

<h3>synchronize mode</h3>

<p>$redis->set('hoge', 'piyo');
print $redis->get('hoge');  # piyo</p>

<h3>asynchronize mode</h3>

<p>$redis->get('hoge', sub {</p>

<pre><code>my ($result, $error) = @_;
print $result;  # piyo
</code></pre>

<p>});
$redis->wait_all_responses;</p>

<h3>pubsub</h3>

<p>$redis->publish('fugu', 'fuga');
$redis->subscribe('fugu', sub {</p>

<pre><code>my ($message, $topic, $subscribed_topic) = @_;
</code></pre>

<p>});</p>

<p>my $timeout = 10;
$redis->wait_for_messages($timeout) while 1;
```</p>

<p>以前作った、<a href="https://github.com/shogo82148/Redis-Namepace">Redis::Namespace</a>にもそのまま使えます。</p>

<p>``` perl
use Redis::Fast;
use Redis::Namespace;</p>

<p>my $redis = Redis::Fast->new;
my $ns = Redis::Namespace(redis => $redis, namespace => 'fugu');</p>

<p>$ns->set('foo', 'bar');    # $redis->set('fugu:foo', 'bar');
my $foo = $ns->get('foo'); # my $foo = $redis->get('fugu:foo');
```</p>

<h2>ベンチマーク</h2>

<h3>Redis.pm</h3>

<p>``` plain Redis.pm
Benchmark: running 00_ping, 10_set, 11_set_r, 20_get, 21_get_r, 30_incr, 30_incr_r, 40_lpush, 50_lpop, 90_h_get, 90_h_set for at least 5 CPU seconds...
   00_ping:  8 wallclock secs ( 0.69 usr +  4.77 sys =  5.46 CPU) @ 5538.64/s (n=30241)</p>

<pre><code>10_set:  8 wallclock secs ( 1.07 usr +  4.01 sys =  5.08 CPU) @ 5794.09/s (n=29434)
</code></pre>

<p>  11_set_r:  7 wallclock secs ( 0.42 usr +  4.84 sys =  5.26 CPU) @ 5051.33/s (n=26570)</p>

<pre><code>20_get:  8 wallclock secs ( 0.69 usr +  4.82 sys =  5.51 CPU) @ 5080.40/s (n=27993)
</code></pre>

<p>  21_get_r:  7 wallclock secs ( 2.21 usr +  3.09 sys =  5.30 CPU) @ 5389.06/s (n=28562)
   30_incr:  7 wallclock secs ( 0.69 usr +  4.73 sys =  5.42 CPU) @ 5671.77/s (n=30741)
 30_incr_r:  7 wallclock secs ( 0.85 usr +  4.31 sys =  5.16 CPU) @ 5824.42/s (n=30054)
  40_lpush:  8 wallclock secs ( 0.60 usr +  4.77 sys =  5.37 CPU) @ 5832.59/s (n=31321)
   50_lpop:  7 wallclock secs ( 1.24 usr +  4.17 sys =  5.41 CPU) @ 5112.75/s (n=27660)
  90_h_get:  7 wallclock secs ( 0.63 usr +  4.65 sys =  5.28 CPU) @ 5716.29/s (n=30182)
  90_h_set:  7 wallclock secs ( 0.65 usr +  4.74 sys =  5.39 CPU) @ 5593.14/s (n=30147)
```</p>

<h3>Redis::hiredis</h3>

<p>``` plain Redis::hiredis
Benchmark: running 00_ping, 10_set, 11_set_r, 20_get, 21_get_r, 30_incr, 30_incr_r, 40_lpush, 50_lpop for at least 5 CPU seconds...
   00_ping: 10 wallclock secs ( 0.15 usr +  5.13 sys =  5.28 CPU) @ 8998.48/s (n=47512)</p>

<pre><code>10_set:  9 wallclock secs ( 0.12 usr +  4.90 sys =  5.02 CPU) @ 8552.39/s (n=42933)
</code></pre>

<p>  11_set_r:  9 wallclock secs ( 0.14 usr +  4.95 sys =  5.09 CPU) @ 8555.01/s (n=43545)</p>

<pre><code>20_get:  9 wallclock secs ( 0.09 usr +  5.42 sys =  5.51 CPU) @ 8785.48/s (n=48408)
</code></pre>

<p>  21_get_r:  9 wallclock secs ( 0.20 usr +  4.94 sys =  5.14 CPU) @ 8181.52/s (n=42053)
   30_incr:  9 wallclock secs ( 0.12 usr +  5.29 sys =  5.41 CPU) @ 8622.55/s (n=46648)
 30_incr_r:  8 wallclock secs ( 0.16 usr +  4.92 sys =  5.08 CPU) @ 8113.39/s (n=41216)
  40_lpush:  9 wallclock secs ( 0.21 usr +  5.15 sys =  5.36 CPU) @ 8547.57/s (n=45815)
   50_lpop:  8 wallclock secs ( 0.12 usr +  4.91 sys =  5.03 CPU) @ 9024.06/s (n=45391)
```</p>

<h3>Redis::Fast</h3>

<p>Redis.pm の3〜5割増しくらいで速くなる。
Redis::hiredisと比べると1割〜2割くらい遅い。</p>

<p>``` plain Redis::Fast
Benchmark: running 00_ping, 10_set, 11_set_r, 20_get, 21_get_r, 30_incr, 30_incr_r, 40_lpush, 50_lpop, 90_h_get, 90_h_set for at least 5 CPU seconds...
   00_ping:  9 wallclock secs ( 0.18 usr +  4.84 sys =  5.02 CPU) @ 7939.24/s (n=39855)</p>

<pre><code>10_set: 10 wallclock secs ( 0.31 usr +  5.40 sys =  5.71 CPU) @ 7454.64/s (n=42566)
</code></pre>

<p>  11_set_r:  9 wallclock secs ( 0.31 usr +  4.87 sys =  5.18 CPU) @ 7993.05/s (n=41404)</p>

<pre><code>20_get: 10 wallclock secs ( 0.27 usr +  4.84 sys =  5.11 CPU) @ 8350.68/s (n=42672)
</code></pre>

<p>  21_get_r: 10 wallclock secs ( 0.32 usr +  5.17 sys =  5.49 CPU) @ 8238.62/s (n=45230)
   30_incr:  9 wallclock secs ( 0.23 usr +  5.27 sys =  5.50 CPU) @ 8221.82/s (n=45220)
 30_incr_r:  8 wallclock secs ( 0.28 usr +  4.91 sys =  5.19 CPU) @ 8092.29/s (n=41999)
  40_lpush:  9 wallclock secs ( 0.18 usr +  5.06 sys =  5.24 CPU) @ 8312.02/s (n=43555)
   50_lpop:  9 wallclock secs ( 0.20 usr +  4.84 sys =  5.04 CPU) @ 8010.12/s (n=40371)
  90_h_get:  9 wallclock secs ( 0.19 usr +  5.51 sys =  5.70 CPU) @ 7467.72/s (n=42566)
  90_h_set:  8 wallclock secs ( 0.28 usr +  4.83 sys =  5.11 CPU) @ 7724.07/s (n=39470)
```</p>

<h3>pipeline mode</h3>

<p>毎回レスポンスを待っているとI/Oがボトルネックになってあんまり速度上がらないけど、
レスポンスを待たずにコマンドをどんどん送りつけると差が原著になります。</p>

<p>``` perl bench.pl</p>

<h1>!/usr/bin/perl</h1>

<p>use warnings;
use strict;</p>

<p>use Time::HiRes qw/time/;
use Redis;
use Redis::Fast;
use Redis::hiredis;</p>

<p>my $count = 100000;</p>

<p>{</p>

<pre><code>my $r = Redis-&gt;new;
my $start = time;
for(1..$count) {
    $r-&gt;set('hoge', 'fuga', sub{});
}
$r-&gt;wait_all_responses;
printf "Redis.pm:\n%.2f/s\n", $count / (time - $start);
</code></pre>

<p>}</p>

<p>{</p>

<pre><code>my $r = Redis::hiredis-&gt;new;
$r-&gt;connect("127.0.0.1", 6379);
my $start = time;
for(1..$count) {
    $r-&gt;append_command('set hoge fuga');
}
for(1..$count) {
    $r-&gt;get_reply();
}
printf "Redis::hiredis:\n%.2f/s\n", $count / (time - $start);
</code></pre>

<p>}</p>

<p>{</p>

<pre><code>my $r = Redis::Fast-&gt;new;
my $start = time;
for(1..$count) {
    $r-&gt;set('hoge', 'fuga', sub{});
}
$r-&gt;wait_all_responses;
printf "Redis::Fast:\n%.2f/s\n", $count / (time - $start);
</code></pre>

<p>}
```</p>

<p>大体Redis.pmの4倍速い。でもRedis::hiredisと比べると2割ほど遅い。
Fastを名乗るのは早すぎた。</p>

<p><code>plain bench
Redis.pm:
22588.95/s
Redis::hiredis:
105159.88/s
Redis::Fast:
81098.01/s
</code></p>

<p>Perl API よくわからない。Socket通信まったくわからない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YAPCへ行ってきた(二日目)]]></title>
    <link href="http://shogo82148.github.io/blog/2013/09/24/yapc-second-day/"/>
    <updated>2013-09-24T07:52:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/09/24/yapc-second-day</id>
    <content type="html"><![CDATA[<p>前回のポストにつづいてYAPC二日目。
聞いたトークの内容を簡単にメモ。</p>

<h2>Perl で書く結合テスト</h2>

<p>前半はSWET(Software Engineer in Test), TE(Test Engineer)といった業種の話。
後半はテスト手法の分類(誰がする？テストの対象は？方法は？目的は？)について。</p>

<p>スライドはこちら→[Perlで書く結合テスト(]http://ikasama.hateblo.jp/entry/2013/09/22/234521)</p>

<h2>これからのPerlプロダクトのかたち</h2>

<p>世界一高速な処理系を目指して開発中の<a href="https://github.com/goccy/gperl">gperl</a>と、
その過程でできたツールの紹介。
PerlをLLVMにコンパイルすることがで、高速動作するらしい。
恐ろしい・・・。</p>

<p>Perlは文脈によってトークンの意味が変わってしまうから、トークナイザーを作るのに苦労したとのこと。
(例えば、<code>hoge * fuga</code> とあったときに、<code>*</code>が掛け算なのかブロブなのかわからない)
コンパイルの高速化のために文法を工夫しているKuinを見習って欲しいですね。</p>

<h2>Emacs実践入門 Perl編</h2>

<p>typester先生によるEmacs入門。
PerlCompletion とか helm とか便利そう。
あんまりEmacsカスタマイズできていないので、今度いろいろ入れて遊んでみよう。</p>

<h2>Perlでレコメンデーション</h2>

<p>登壇者はJubatusのPerlモジュールを書いたりしているらしい。
Jubatus に触ってみようと考え始めてからどれだけの月日が経っただろう・・・
そのうち触ってみます。そのうち。</p>

<h2>中規模チャットサービスの運用事例</h2>

<p>handlename先生のLobi運用のお話。
今日もcronのメールが迷惑メールフィルタによって闇に葬りさられる悲しいことがあったので、
cronの結果をIRCに飛ばすのとか参考にして何とかしたい。</p>

<h2>PhantomJSによる多岐にわたる広告枠の確実な表示テスト</h2>

<p>最近の広告はJavascriptを使った遅延読み込みをするので、
ちゃんと表示されるかを静的に判断することができない。
そこで PhantomJS を使ってテストするお話。</p>

<h2>フルテストも50msで終わらせたい 〜 FreakOutの取り組み 〜</h2>

<p>さすがにフルテストは50msで終わりません。
Ukigumoを使って複数台のサーバでテストを分散実行する取り組みを紹介。</p>

<p>スライド→http://yapcasia.org/2013/talk/show/767463b0-d8fd-11e2-971a-72936aeab6a4</p>

<h2>LT</h2>

<p>前日にアイデアだけLTで紹介したHTTP::Body::Builderが、別の人の手によって実現されていたのには驚いた。
YAPC恐ろしいところだ・・・。</p>

<h2>HUB</h2>

<p>懇親会参加しない組だったので、
@sasaplus1 さん, @kazuph さん, @aokcub とHUBで飲み会。
なぜ学内にHUBがあるんだ・・・？</p>

<p>NDS勢やNiigata.pm勢、あと何故かスタッフになっていた @jewel_x12 とも会えて楽しかったです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YAPCへ行ってきた(一日目)]]></title>
    <link href="http://shogo82148.github.io/blog/2013/09/20/yapc-first-day/"/>
    <updated>2013-09-20T21:48:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/09/20/yapc-first-day</id>
    <content type="html"><![CDATA[<p>YAPCの一日目に行ってきたよ。</p>

<!-- More -->


<h2>いまどきのカジュアルなデータベース関連開発</h2>

<p>Songmu先生のセッション。</p>

<p>DBIx::Schema::DSL とか GitDDL::Migrator とかの説明や、
DBのスキーマ設計、Redisの紹介なんかがありました。
自分もMySQLやRedisを触る機会が増えて、DB周りでつらい思いをしたことが何度かあるので
(外部キー制約でデッドロック起こしたり、無駄なインデックスを必死に削除したり・・・)
大いに参考に参考にさせていただきます。</p>

<p>スライドはこちらから→<a href="http://songmu.github.io/slides/yapc-asia2013/">いまどきのカジュアルなデータベース関連開発</a></p>

<h2>学術分野におけるPerlの活用例</h2>

<p>Perlを使ったアンケートの結果と、PerCUDAの紹介。
GPGPUをPerlのコードで実現しようとのお話。</p>

<h2>大規模Perl初心者研修を支える技術</h2>

<p>:DeNAさんが行った研修の紹介です。
顔覚えられない、
研修生の状況把握が大変、
信頼関係を作るのが大変
といった問題をどうやって解決したかについてのお話がありました。</p>

<p>トークの中で紹介された本何冊か持っているけど、全然読んでない・・・。
というか研修生みんなこれ読んだんですか。</p>

<p>スライドはこちらから→<a href="http://www.slideshare.net/DaisukeTamada/perl-26371335">大規模Perl初心者研修を支える技術</a></p>

<h2>mod_perlの展望とApacheの超絶技巧</h2>

<p>最近僕の周辺ではあまり Apache の話題を聞かなくなってしまいましたね。
しかし、その知名度の高さからか、他のオープンソースのプロダクトはダメでも、
Apache はOKという案件があるらしい。
「Apache使いました！」っていうために、mod_perl で代替品を作ろう、というお話。
おそろしい・・・。</p>

<p>スライドはこちらから→<a href="http://www.slideshare.net/xtetsuji/apachemodperl-yapcasia">mod_perlの展望とApacheの超絶技巧</a></p>

<h2>0から学んだポストモダンPerl</h2>

<p>ルーティングとかORMはWAFにはいらない。
blessで十分！これぞ、ポスト・モダンPerl！とのことでした。</p>

<p>僕もフルスタックのフレームワークより、
各機能が別になっているほうが好きですね。
(でもblessよりはクラスを扱うためのライブラリ使ったほうがよいと思う)
まあ、あんまり大規模なWebアプリ作ったこと無いので、
実際に作ってみると意見が変わるかもしれませんが。</p>

<p>スライドはこちらから→<a href="http://www.slideshare.net/TasukuSuenaga/yapc2013">0から学んだポストモダンPerl</a></p>

<h2>Dist::Zilla</h2>

<p>英語のトークに紛れ込んでしまい、正直良くわからなかった。
英語能力全く向上していない。</p>

<p>モジュールを作成、テスト、アップロード等の管理をするためのプログラムらしい。
Redis::Namespace でつらい思いをしたので、
次モジュールを作りたくなったら試してみよう。</p>

<h2>perl な web application のためのテスト情報</h2>

<p>スライドの順番が正しいか、今使っているのは本当にマイクなのかのテストが必要ですね！
335さん自らテストの必要性を教えてくれました。
「なぜテストが必要か」言葉では語らず行動で示す335さんかっこいい。</p>

<p>Test::Deep は Redis::Namespace のテストでも一部使っていますが、これ便利ですね。
Test::More の is_deeply はちょっと不便だと思っていたので、今後も使っていこうと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Cloud Messaging for Chrome を試してみた]]></title>
    <link href="http://shogo82148.github.io/blog/2013/05/15/google-cloud-messaging-for-chrome/"/>
    <updated>2013-05-15T11:26:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2013/05/15/google-cloud-messaging-for-chrome</id>
    <content type="html"><![CDATA[<p>少し前に<a href="http://developer.chrome.com/apps/cloudMessaging.html">Google Cloud Messaging for Chrome</a>
が発表されました。
Android向けに提供されていた Push 通信の仕組みである GCM の Chrome 版です。
ちょうど GCM for Android に触っていたところだったので、
for Chrome のほうも試してみることにしました。</p>

<!-- More -->


<h2>拡張機能の登録</h2>

<p>公式ページの説明にしたがって、
APIを使えるようにします。
GCMはOAuth2.0で認証を行うので、</p>

<ol>
<li>クライアントIDを作る</li>
<li>Refresh Token を作る</li>
</ol>


<p>という2ステップが必要。</p>

<h3>クライアントIDを作る</h3>

<p>まず、新しい OAuth2.0 のアプリを作成。
拡張機能をアップロードする予定のGoogleアカウントで以下の作業して
Client IDを作ります。</p>

<ol>
<li><a href="https://code.google.com/apis/console/">Google APIs Console</a> にログインする</li>
<li><strong> Create... </strong> メニューから新しいプロジェクトを作成</li>
<li>"Services" を開いて <strong> Google Cloud Messaging for Chrome API </strong> を有効化</li>
<li>"API Access" を開いて <strong> Create an OAuth 2.0 cliend ID... </strong> というボタンをクリック</li>
<li>branding information を適当に入力</li>
<li>"Application Type" という項目の "Web application" を選択</li>
<li>"Create client ID"！！</li>
</ol>


<p>Client ID と Client Secret が表示されるのでメモしておきましょう。</p>

<h3>Refresh Token を取得する</h3>

<p>次に作成したクライアントIDを使って、
OAuth2.0認証。</p>

<ol>
<li>シークレットウィンドウを開く(複数アカウント持ってない場合は必要ない)</li>
<li><a href="https://developers.google.com/oauthplayground/">OAuth 2.0 Playground</a>へアクセス</li>
<li><strong> OAuth2.0 Configuration </strong> をクリック</li>
<li>"Use your own OAuth credentials" にチェックを入れ、Client ID と Client Secret を入力。"Close"を押して画面を閉じる</li>
<li>"Step 1"セクションの"Input your own scopes"に <code>https://www.googleapis.com/auth/gcm_for_chrome</code> を入力して、"Authorize APIs"ボタンを押す</li>
<li>ログインページにリダイレクトされるので、拡張機能をアップロードする予定のアカウントで認証</li>
<li>今度はアプリの認証画面に飛ぶので "Allow Access" をクリック</li>
<li>"Step 2" セクションの "Exchange authorization code for tokens" ボタンをクリック</li>
</ol>


<p>以上の手順で Access Token と Refresh Token がもらえる。
通知を送るには Access Token があれば十分なんだけど、有効期間が1時間程度しかない。
有効期間が切れたら Refresh Token を使って再取得する必要がある。
Refresh Token の方には有効期間は無いので、大事にとっておこう。</p>

<p>(GCM for Android みたいに Sever key 作るだけじゃダメだったのかな・・・OAuth2.0認証面倒・・・)</p>

<h2>拡張機能でGCMを使う</h2>

<p>次は通知を受け取る拡張機能を作ります。</p>

<h3>パーミッションを追加</h3>

<p>まずはマニフェストを作成。
permissions という項目に "pushMessaging" を追加しておくのがポイント。</p>

<p>``` javascript manifest.json
{</p>

<pre><code>"manifest_version": 2,
"name": "Shogo GCM Test",
"description": "It's test extension",
"version": "1.0",

"permissions": [
    "pushMessaging",
    "notifications"
],

"background": {
    "scripts": ["background.js"]
}
</code></pre>

<p>}
```</p>

<h3>JavaScript を書く</h3>

<p>通知を受け取るプログラムを書いてみます。</p>

<p>``` javascript background.js
// ChannelIDを取得
chrome.pushMessaging.getChannelId(false, function (response){</p>

<pre><code>console.log(response); // 本当はサーバに送るんだけど、とりあえず、コンソールに出力しておく
</code></pre>

<p>});</p>

<p>// 通知を受け取るイベントハンドラを登録
chrome.pushMessaging.onMessage.addListener(function (message) {</p>

<pre><code>// デスクトップ通知で表示
var notification = webkitNotifications.createNotification(
    '',
    'Message',
    message.payload
);
notification.show();
</code></pre>

<p>});
```</p>

<h3>マーケットに公開！</h3>

<p>ローカル環境でも Channel ID の取得まではできるんだけど、
実際に Push 通知を受信するには、マーケットへのアップロードが必要。</p>

<p><a href="https://chrome.google.com/webstore/developer/dashboard">デベロッパーダッシュボード</a>で
新しいアイテムを追加ボタンを押し、さっきのファイルをzipで固めたファイルを送ります。
公開するには初回のみ5ドル必要です。
さすがに開発中のものを全世界に公開するのはまずいので、
テスターにのみ公開というオプションを選択しておきましょう。</p>

<h2>Push 通知を送る</h2>

<p>さあ、Push通知を送ってみましょう。</p>

<h3>新しい Access Token を取得する</h3>

<p>と、そのまえに</p>

<p>そろそろ最初にもらった Access Token の有効期間が切れているころだと思うので、
新しいものを取得しておきましょう。</p>

<p>最近 Perler になりつつあるので、Perlで書いてみます。
Client ID, Client Secret, Refresh Token を Post するだけの簡単なスクリプトです。</p>

<p>``` perl refresh_token.pl</p>

<h1>!/usr/bin/env perl</h1>

<p>use warnings;
use strict;
use Encode;
use Data::Dumper;</p>

<p>use Furl;
use JSON::XS;</p>

<p>my $refresh = 'your_refresh_token';
my $client_id = 'your_client_id.apps.googleusercontent.com';
my $client_secret = 'your_client_secret';</p>

<p>my $furl = Furl->new;
my $res = $furl->post(</p>

<pre><code>'https://accounts.google.com/o/oauth2/token',
[ ],
[
    client_id =&gt; $client_id,
    client_secret =&gt; $client_secret,
    refresh_token =&gt; $refresh,
    grant_type =&gt; 'refresh_token',
],
</code></pre>

<p>);</p>

<p>print Dumper decode_json($res->content);
```</p>

<h3>Push! Push! Push!</h3>

<p>さあ、ようやくPush！</p>

<p>Access Token をヘッダにつけ、
メッセージをChannel IDと一緒に POST するだけ。</p>

<p>Channel ID は <code>chrome://extensions/</code> から自分の拡張機能の選択、
ビューを調査: _generated_background_page.html というところをクリックすると、
Consoleが見れるのでそこから確認できます。</p>

<p>``` perl push.pl</p>

<h1>!/usr/bin/env perl</h1>

<p>use warnings;
use strict;
use Encode;</p>

<p>use Furl;
use JSON::XS;</p>

<p>my $access = 'your_access_token';
my $channelId = 'your_channel_id';</p>

<p>my $data = {</p>

<pre><code>channelId =&gt; $channelId,
subchannelId =&gt; "0",
payload =&gt; decode_utf8(join(' ', @ARGV)),
</code></pre>

<p>};</p>

<p>my $furl = Furl->new;
my $res = $furl->post(</p>

<pre><code>'https://www.googleapis.com/gcm_for_chrome/v1/messages',
[
    'Content-Type' =&gt; 'application/json',
    'Authorization' =&gt; "Bearer $access",
],
encode_json $data,
</code></pre>

<p>);
```</p>

<p><code>bash Command
$ perl push.pl hogehoge
</code></p>

<p>うまくいくと、デスクトップ通知が出るはず！</p>

<h2>参考</h2>

<ul>
<li><a href="http://developer.chrome.com/apps/cloudMessaging.html">Google Cloud Messaging for Chrome</a></li>
<li><a href="http://blog.maripo.org/2013/05/gcm-for-chrome/">Google Cloud Messaging for Chromeを体験してみた</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
