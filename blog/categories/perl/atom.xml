<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2016-03-23T22:43:44+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを公開しました]]></title>
    <link href="http://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules/"/>
    <updated>2016-03-18T22:16:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules</id>
    <content type="html"><![CDATA[<p>以前<a href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/">Redisでスコアを複数設定できるランキングを作ってみた</a>けど、
Githubの肥やしになっていてもあれなので、CPANizeしました。
あわせて、この実装のために作ったユーティリティモジュールも別モジュールとして公開しました。</p>

<ul>
<li><a href="https://metacpan.org/pod/Redis::LeaderBoardMulti">Redis::LeaderBoardMulti</a></li>
<li><a href="https://metacpan.org/pod/Redis::Script">Redis::Script</a></li>
<li><a href="https://metacpan.org/pod/Redis::Transaction">Redis::Transaction</a></li>
</ul>


<!-- More -->


<h2>Redis::LeaderBoardMulti</h2>

<p>最初の基準で順位を決められなかった場合の第二基準が欲しいというときに使うモジュールです。
インターフェースがRedis::LeaderBoard互換になるように調整したので、
前回とインターフェースがちょっと変わっています。</p>

<p>``` perl
se Redis;
use Redis::LeaderBoard;
my $redis = Redis->new;
my $lb = Redis::LeaderBoardMulti->new(</p>

<pre><code>redis =&gt; $redis,
key   =&gt; 'leader_board:1',
order =&gt; ['asc', 'desc'], # asc/desc, desc as default
</code></pre>

<p>);</p>

<h1>Redis::LeaderBoardに合わせて複数指定できるようになりました</h1>

<p>$lb->set_score(</p>

<pre><code>'one' =&gt; [100, time],
'two' =&gt; [ 50, time],
</code></pre>

<p>);
my ($rank, $score, $time) = $lb->get_rank_with_score('one');
```</p>

<p>Redis::LeaderBoard互換なのでそのまま入れ替えられるはずですが、以下のような実装上の制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
<li>同順の場合の出現順

<ul>
<li>Redis::LeaderBoard は ZRANK, ZREVRANK を使い分けているので、orderパラメータによって昇順/降順が変わります</li>
<li>Redis::LaederBoardMulti は ZRANK しか使わないので、必ず昇順になります</li>
</ul>
</li>
</ul>


<p>一応 Lua Script を使わないオプションもそのまま残してありますが、特に理由がない限りデフォルト(Lua Script を使う)で使うといいと思います。
どうしてもロックの範囲が広くなってしまう場合があり、楽観的ロックでは効率が悪いケースがあるためです。</p>

<h2>Redis::Script</h2>

<p>EVALSHAを簡単に使うためのモジュールです。
EVALコマンドを使うとLua Scriptの実装ができますが、毎回毎回実行するスクリプト全体を送る必要があります。
EVALSHAコマンドはその代わりにスクリプトのSHA1ハッシュを送ることで、帯域の節約ができるというコマンドです。
しかしEVALSHAはSHA1ハッシュを事前に登録する必要があり、どのタイミングで登録を行うかが問題になってきます。</p>

<p><a href="http://redis.io/commands/eval">EVALコマンドのドキュメント</a>によると、
「EVALSHAで実行してみて <code>NOSCRIPT No matching script</code> で失敗したらEVALでやり直す」というのがおすすめらしいです。
EVALコマンドはSHA1ハッシュの登録も行ってくれるので、初回 <code>NOSCRIPT</code> になっても次回からはEVALSHAが成功します。</p>

<p>そんなに複雑なことではないのですが、毎回書くのも大変なのでモジュールとして切り出したのが Redis::Script です。
以下のようにスクリプトオブジェクトを作っておいて、パラメータを渡して実行します。</p>

<p><code>perl
use Redis;
use Redis::Script;
my $script = Redis::Script-&gt;new(script =&gt; "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}");
my ($key1, $key2, $arg1, $arg2) = $script-&gt;eval(Redis-&gt;new, ['key1', 'key2'], ['arg1', 'arg2']);
</code></p>

<p><code>$script</code> が計算済みのSHA1ハッシュを保存しておいてくれるので、計算リソースの節約にもなるはずです。
(ベンチとってみたところ、スクリプトのサイズが1kBから10kBくらいにならないと効果なさそうでしたが・・・)</p>

<h2>Redis::Transaction</h2>

<p>Redisのトランザクションを簡単に行うためのモジュールです。</p>

<p>MULTI-EXECは単に実行するだけなら、MULTIとEXECで囲うだけでよいので簡単です。
例えば、 <code>foo</code> と <code>bar</code> を同時にインクリメントしたい場合、以下のようにすると実現できます。</p>

<p><code>perl
$redis-&gt;multi;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
$redis-&gt;exec; # 他のクライアントからはfooとbarが全く同時にインクリメントされたように見える
</code></p>

<p>ただ、このような素朴な実装だと、途中でネットワークが不調になった場合などに再接続処理が止まったままになる可能性があります。
例えば以下のようにトランザクションの中で例外が発生すると、以後そのコネクションを使おうとしたときにエラーになります。
コネクションの永続化をしている場合はしばらくエラーが出続けることになり問題です。</p>

<p>``` perl
eval {</p>

<pre><code>$redis-&gt;multi; # トランザクション開始
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
die "ネットワークトラブル！"
$redis-&gt;exec;
</code></pre>

<p>};
$redis->ping; # 繋がらなくなる
```</p>

<p>Redis::Transaction はこのような問題を防ぐためのモジュールです。
トランザクションが失敗したときの後始末をよしなにやってくれるので、万が一エラーになっても安心です。</p>

<p>``` perl
multi_exec Redis->new, 1, sub { # 1は失敗したときのリトライ回数</p>

<pre><code>my $redis = shift;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
die "ネットワークトラブル！"
</code></pre>

<p>};
$redis->ping; # 繋がる！
```</p>

<p>WATCH-MULTI-EXECを使った楽観的ロックも扱えます。
Redisのトランザクションは楽観的ロックなので、
処理中に他のクライアントが書き換えを行った場合に失敗する可能性があります。
その場合でもリトライを行ってくれて便利です。</p>

<p>``` perl</p>

<h1>$redis->incr('mykey') をトランザクションを使って実現する</h1>

<p>watch_multi_exec Redis->new, ['mykey'], 10, sub {</p>

<pre><code>my $redis = shift;
return $redis-&gt;get('mykey');
</code></pre>

<p>}, sub {</p>

<pre><code>my ($redis, $value) = @_;
$redis-&gt;set('mykey', $value + 1);
</code></pre>

<p>};
```</p>

<h2>まとめ</h2>

<p>Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを紹介しました。
それぞれは小さなモジュールですが、
トラブル発生時にも問題にならないようちゃんとした実装しようとすると、
意外と考えることが多く面倒なものです(特にトランザクション周りとか)。
適当に実装してしまったこころ当たりのある人は、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisでスコアを複数設定できるランキングを作ってみた]]></title>
    <link href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/"/>
    <updated>2016-02-06T02:30:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi</id>
    <content type="html"><![CDATA[<p>ランキングを作っているとスコアを複数設定したいことがよくあると思います。
例えば「得点が同じだったら早くその得点を出した人優先」とか「勝ち点が同じだったら得失点差が大きい方優先」とかのように、
最初の基準で順位を決められなかった場合の第二基準が欲しいみたいな場合です。</p>

<p>ランキングを作るのにはRedisのSorted Setを使うのが便利ですが、残念ながらSorted Setはひとつしかスコアを設定できません。
少し前にどうやったら実装できるかと社内チャットで話題に上ったので、試しにRedis::LeaderBoardMulti(仮名)という名前で書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/p5-Redis-LeaderBoardMulti">shogo82148/p5-Redis-LeaderBoardMulti</a></li>
</ul>


<!-- More -->


<h2>使い方</h2>

<p>メソッドの名前は<a href="http://www.songmu.jp/riji/archives/2013/06/redisleaderboar.html">Redis::LeaderBoard</a>にあわせてありますが、
スコアが複数指定できるようになった関係でちょっと変わってます。</p>

<p>``` perl
use Redis;
use Redis::LeaderBoard;
my $redis = Redis->new;
my $lb = Redis::LeaderBoardMulti->new(</p>

<pre><code>redis =&gt; $redis,
key   =&gt; 'leader_board:1',
order =&gt; ['asc', 'desc'], # asc/desc, desc as default
</code></pre>

<p>);
$lb->set_score('one' => 100, time); # 第二基準は時間=得点が同じだったら早くその得点を出した人優先
$lb->set_score('two' =>  50, time);
my ($rank, $score, $time) = $lb->get_rank_with_score('one');
```</p>

<p><code>set_score</code>の第二引数以降はすべてスコアとして扱われます。(そのためRedis::LeaderBoardと互換性はない)
上の例では「得点が同じだったら早くその得点を出した人優先」になってます。</p>

<h2>制限事項</h2>

<p>実装の都合により、以下のような制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数です

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
</ul>


<h2>実装の仕組み</h2>

<p>Sorted Setの同じスコアを持つメンバーは辞書順にソートされます(zaddの<a href="http://redis.io/commands/zadd#elements-with-the-same-score">同じスコアを持つ要素</a>の項を参照)。
例えば以下の様にメンバー「a」「b」「c」を追加すると、必ず「abc」の順番になることが保証されています。</p>

<p><code>plain
127.0.0.1:6379&gt; ZADD ranking 0 "a" 0 "b" 0 "c"
(integer) 3
127.0.0.1:6379&gt; ZRANK ranking "b"
(integer) 1
</code></p>

<p>これを利用して、メンバーの先頭にスコアをエンコードして付けておきます。
もちろんエンコードしたあとでもスコアの大小関係が保たれている必要があります。
以下はエンコード方式にビッグエンディアンの16bit整数を使った例です。
Redis 2.8.9から辞書順比較に特化したコマンド(LEXがつくやつ)が追加されているので、
ランクを求める処理は以下のように書くことができます。</p>

<p><code>plain
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x02b"    (bをスコア2で追加)
(integer) 1
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x01a"    (aをスコア1で追加)
(integer) 1
127.0.0.1:6379&gt; ZLEXCOUNT ranking - "(\x00\x02"    (スコア2未満の個数=bのランク)
(integer) 1
</code></p>

<p>さすがに16bit符号なし整数だと範囲が狭いので、実際の実装は以下のようになっています。</p>

<ul>
<li>エンコードはビッグエンディアンの64bit符号付き整数</li>
<li>負数も扱えるように下駄を履かせる

<ul>
<li>1と-1を単純にエンコードすると-1の方が大きくなってしまう</li>
<li>0x8000000000000000を足して符号なし整数の範囲で比較できるように補正</li>
</ul>
</li>
</ul>


<h2>アトミック性について</h2>

<p>この方法だとSorted Setだけでは現在のスコアを取得できないので、
スコアだけ別管理にする必要があります。
スコアの更新とランキングの更新があるので、
片方だけ更新される状況がないようにアトミック性に注意する必要があります。
更新途中の間違った結果を返すだけならすぐに復旧するのでまだマシですが、
途中でネットワーク障害が起こって不整合なデータが残ってしまうと面倒です。</p>

<p>アトミック性を確保するためのパターンをいくつか実装してみました。
<code>use_script</code>と<code>use_hash</code>で制御が可能です。</p>

<h3>トランザクションを使った方法</h3>

<p>Redisには<a href="http://redis.io/topics/transactions">トランザクション</a>の仕組みがあるのでこれを使った方法です。
<code>use_script=&gt;0</code>が指定されるとこの方法で更新を行います。</p>

<p><code>plain
127.0.0.1:6379&gt; WATCH ranking:a   (他のクライアントが更新を行っていないか監視)
OK
127.0.0.1:6379&gt; GET ranking:a   (ranking:aに入っている現在のスコアを取得)
"\x00\x01"
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; ZREM ranking "\x00\x01a"
QUEUED
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x03a"
QUEUED
127.0.0.1:6379&gt; SET ranking:a "\x00\x03"
QUEUED
127.0.0.1:6379&gt; EXEC   (スコアの更新とランキングの更新をアトミックに行う)
1) (integer) 1
2) (integer) 1
3) OK
</code></p>

<p>Redisのトランザクションは楽観的ロックなので、他のクライアントがスコアを更新していると失敗する場合があります。
失敗した場合はリトライが必要です。
(この機構、いろいろと注意点があって毎回実装するのはつらすぎるので、別モジュールとして分離したいけど、いい名前とインターフェース募集中)</p>

<p><code>use_hash=&gt;1</code>が指定されていると、スコアの記録にHashを使います。
「Hashの特定のキーの更新をWATCHする」という命令はないため、ランキング全体を<code>WATCH</code>で監視します。
(<code>use_hash=&gt;0</code>の場合、そのメンバのスコアだけ監視する)</p>

<h3>Luaスクリプトを使った方法</h3>

<p>RedisはLuaスクリプトを実行する機能があります。
Luaスクリプト実行中は他の命令の実行をブロックするので、アトミック性が確保されます。</p>

<p><code>lua
local s=redis.call('GET', 'ranking:a')
if s then
  redis.call('ZREM', 'ranking', s..'a')
end
redis.call('ZADD', 'ranking', 0, '\x00\x03a')
redis.call('SET', 'ranking:a', '\x00\x03')
</code></p>

<p>Luaスクリプトを実行するには<code>EVAL</code>と<code>EVALSHA</code>の二種類のコマンドがあります。
<code>EVALSHA</code>は転送量を抑えられて便利ですが、事前に<code>SCRIPT LOAD</code>で使うスクリプトを登録しておく必要があります。
(ココらへんも別モジュールに分離したいけど、いい名前とインターフェース募集中)
<code>use_evalsha</code>オプションでどちらを使うか制御可能です。</p>

<p>ちなみに<code>EVAL</code>で実行したスクリプトも<a href="http://redis.io/commands/eval#script-cache-semantics">永遠にキャッシュされる</a>らしいです。
上の例はわかりやすいようにキー名や値を直接埋め込んでいますが、同じことをしようとLuaスクリプトの動的生成なんてすると死にます。
スクリプト内で<code>KEYS</code>や<code>ARGV</code>を使うと<code>EVAL</code>時にパラメータを渡せるようになるので、これを活用しましょう。</p>

<h3>諦める</h3>

<p><a href="https://metacpan.org/pod/Redis::LeaderBoard">Redis::LeaderBoard</a>の実装を見て気がついたんですが、
<code>get_rank</code>の実装は「スコアの取得」「スコアに対応するランクの取得」がアトミックでないため、
以下の条件を満たすと実際のランクより1大きい結果を返します。</p>

<ul>
<li>同じメンバーのスコア更新とランク取得が同時に行われる</li>
<li>ランクが上がるようにスコアが更新される</li>
</ul>


<p>確かに厳密性は欠けますがたかだか1結果が変わるだけですし、
そもそも更新と取得が同時に行われないようにモジュールを使う側が排他制御するべきですね。
こういうケースでは諦めるというのも一つの手かなと思いました。
もちろんデータの整合性が壊れる場合は頑張ってアトミック性を確保するべきでしょう。</p>

<h2>まとめ</h2>

<ul>
<li>Redisでランキングをつくる際に、スコアを複数設定する方法を紹介しました</li>
<li>アトミック性を確保する方法を紹介しました

<ul>
<li>トランザクションを使った方法</li>
<li>Luaスクリプトを使った方法</li>
<li>諦める</li>
</ul>
</li>
</ul>


<p>もうちょっとドキュメントを整備したらCPANにあげてみますかね。
トランザクション管理・Luaスクリプト管理も分離したい(いい名前を思いついたら)。
「こんな名前がいい！」「こんなインターフェースがいい！」等あればコメントください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.17 をリリースしました]]></title>
    <link href="http://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released/"/>
    <updated>2016-01-23T16:20:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/release/SHOGO/Redis-Fast-0.17">Redis::Fast 0.17</a> をリリースしました。
主な変更点は以下のとおりです。</p>

<ul>
<li>I/Oの待ち合わせに使うシステムコールをselect(2)からpoll(2)に変更</li>
<li>hiredisをv0.13.3にアップデート</li>
</ul>


<!-- More -->


<p>macでテストが終わらない問題がありましたが、この変更によって修正されています。</p>

<p>hiredisは<a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man2/connect.2.html">connect(2)</a>をnonblokingモードで呼び出しています。
nonblockingなので接続が未完了であってもすぐに制御を返し、errnoにEINPROGRESSが設定されます。
この場合、manにあるようにselect(2)で書き込み可能になるのを待つことで、接続完了を検知できます。</p>

<blockquote><p>select(2) で書き込み可能になった後に、 getsockopt(2) を使って SOL_SOCKET レベルで SO_ERROR オプションを読み出すこ とにより、 connect() が成功したか、失敗したかを判断できる。</p></blockquote>

<p>linuxの場合はこれで上手く動くのですが、macだと何故かselect(2)が永遠に制御を返さない場合があるようです。
接続先が存在しない場合に起こるのですが、制御を返す場合もあるので謎です。</p>

<p>いろいろ調べてはみたのですがselect(2)だとどうやっても上手く動かなかったので、poll(2)に変更しました。
poll(2)変更版でテストしてみると、接続先が存在しない場合にPOLLOUTを返すケースとPOLLHUPを返すケースがあるようです。
どうやらPOLLHUPにあたるイベントが来た時の挙動がlinuxとmacとで違うらしい？
謎です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlのDBIx::Class利用上の注意点]]></title>
    <link href="http://shogo82148.github.io/blog/2015/12/17/dbix-class/"/>
    <updated>2015-12-17T18:35:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/12/17/dbix-class</id>
    <content type="html"><![CDATA[<p>この記事は、<a href="http://qiita.com/advent-calendar/2015/perl5">Perl 5 Advent Calendar</a>の17日目の記事です。</p>

<p><a href="http://tech.kayac.com/archive/reconnect_redisfast.html">Redis::Fast の reconnect について</a>の中で
<a href="https://metacpan.org/release/DBIx-Class">DBIx::Class</a>のreconnectについても触れています。
DBIx::Classの安全にreconnectionが行えるように考慮されていますが、色々と注意点があります。
reconnection周りで調べてみたので、Advent Calendarの枠を借りてまとめたいと思います。</p>

<h2>DBIx::Classとは</h2>

<p><a href="https://metacpan.org/release/DBIx-Class">DBIx::Class</a>はPerlのO/Rマッピングモジュールです。
テーブル間のリレーションを定義でき、JOIN句の入ったクエリもサポートする等、かなり高機能なモジュールです。
もう僕はJOIN句をDBIx::Class以外で書ける気がしません。
詳しくはtypester先生の解説記事をどうぞ。</p>

<ul>
<li><a href="http://gihyo.jp/dev/serial/01/perl-hackers-hub">Perl Hackers Hub</a>

<ul>
<li><a href="http://gihyo.jp/dev/serial/01/perl-hackers-hub/000301">第3回　DBIx::Classでデータベース操作（1）</a></li>
<li><a href="http://gihyo.jp/dev/serial/01/perl-hackers-hub/000302">第3回　DBIx::Classでデータベース操作（2）</a></li>
<li><a href="http://gihyo.jp/dev/serial/01/perl-hackers-hub/000303">第3回　DBIx::Classでデータベース操作（3）</a></li>
</ul>
</li>
</ul>


<h2>サンプル</h2>

<p>サンプルとしてユーザの所持金を管理する簡単なアプリを作ってみます。
Webアプリとか作るの面倒だったので、コンソールアプリです。</p>

<p>``` perl
package My::Schema::User {</p>

<pre><code>use base 'DBIx::Class::Core';

__PACKAGE__-&gt;table('user');

__PACKAGE__-&gt;add_columns(
    id =&gt; {
        data_type         =&gt; 'INTEGER',
        is_nullable       =&gt; 0,
        is_auto_increment =&gt; 1,
    },
    username =&gt; {
        data_type   =&gt; 'VARCHAR',
        size        =&gt; 255,
        is_nullable =&gt; 0,
    },
);

__PACKAGE__-&gt;set_primary_key('id');

# userとmoneyは1対1の関係で、userに対応するmoneyが必ず存在しなければならない
__PACKAGE__-&gt;has_one(
    'money' =&gt; 'My::Schema::Money',
    { 'foreign.user_id' =&gt; 'self.id' },
);

1;
</code></pre>

<p>};</p>

<p>package My::Schema::Money {</p>

<pre><code>use base 'DBIx::Class::Core';

__PACKAGE__-&gt;table('money');

__PACKAGE__-&gt;add_columns(
    user_id =&gt; {
        data_type   =&gt; 'INTEGER',
        is_nullable =&gt; 0,
    },
    yen =&gt; {
        data_type   =&gt; 'INTEGER',
        is_nullable =&gt; 0,
    },
);

__PACKAGE__-&gt;set_primary_key('user_id');

__PACKAGE__-&gt;belongs_to(
    'user' =&gt; 'My::Schema::User',
    { 'foreign.id' =&gt; 'self.user_id' },
);

1;
</code></pre>

<p>};</p>

<p>package My::Schema {</p>

<pre><code>use base 'DBIx::Class::Schema';

__PACKAGE__-&gt;load_classes(qw/User Money/);

1;
</code></pre>

<p>};</p>

<p>use feature 'say';</p>

<p>my $schema = My::Schema->connect('dbi:mysql:host=127.0.0.1;port=3306;database=test;mysql_write_timeout=1;mysql_read_timeout=1', 'root', '');
$schema->storage->dbh->do('DROP TABLE IF EXISTS money, user');
$schema->deploy;
```</p>

<p>実行するとMySQLのデータベースに以下のようなテーブルが作成されます。
userテーブルはユーザの名前を管理するテーブル、moneyはユーザの所持金を管理するテーブルです。</p>

<p>```
mysql> desc user;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| id       | int(11)      | NO   | PRI | NULL    | auto_increment |
| username | varchar(255) | NO   |     | NULL    |                |
+----------+--------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)</p>

<p>mysql> desc money;
+---------+---------+------+-----+---------+-------+
| Field   | Type    | Null | Key | Default | Extra |
+---------+---------+------+-----+---------+-------+
| user_id | int(11) | NO   | PRI | NULL    |       |
| yen     | int(11) | NO   |     | NULL    |       |
+---------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```</p>

<h2>タイムアウトとロールバックの微妙な関係</h2>

<h3>ユーザの初期化プログラムを実装してみる</h3>

<p>テーブル作っただけではつまらないので、データを入れてみます。</p>

<p>``` perl</p>

<h1>スキーマ定義等略</h1>

<h1>ユーザ作成</h1>

<p>my $user_rs = $schema->resultset('User');
eval {</p>

<pre><code>my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ(ちょっと時間がかかる)
$user_rs-&gt;search({}, {select =&gt; \'SLEEP(1)'})-&gt;all;
$user-&gt;create_related(money =&gt; { yen =&gt; 1000 });
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money-&gt;yen;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p>実行してみると、1000円持ったユーザが作成されます。</p>

<p><code>plain
$ perl dbic-test.pl
名前: ok_macopy
所持金: 1000
</code></p>

<h3>タイムアウトと戦う</h3>

<p>一件上手く動いていそうに見えますが、上記コードを何回か実行すると、ときたま以下のように失敗します。</p>

<p><code>
$ perl dbic-test.pl
DBIx::Class::Storage::DBI::_dbh_execute(): DBI Exception: DBD::mysql::st execute failed: Lost connection to MySQL server during query [for Statement "SELECT SLEEP(1) FROM user me"] at dbic-test.pl line 80
名前: ok_macopy
所持金: 0
</code></p>

<p>所持金が0円になってしまいました。
<code>SELECT SLEEP(1) FROM user me</code> という時間のかかるクエリを投げたので、コネクションがタイムアウトしてしまったようです。
データベースの状態を確認すると、userに行はあるけど、moneyは空っぽの状態です。
「userに対応するmoneyが必ず存在しなければならない」とスキーマで定義したのに、その条件を満たしていませんね。
たとえタイムアウトしたとしても、このような状態にはならないで欲しいです。</p>

<p>```
mysql> SELECT * FROM user;
+----+-----------+
| id | username  |
+----+-----------+
|  1 | ok_macopy |
+----+-----------+
1 row in set (0.00 sec)</p>

<p>mysql> SELECT * FROM money;
Empty set (0.00 sec)
```</p>

<h3>トランザクションを使ってみる</h3>

<p>リレーショナルデータベースにはこれを実現するためにトランザクションという便利なものがあります。
DBIx::Classから扱うにはいくつか方法がありますが、例えばガードオブジェクトを使って以下のように書けます。</p>

<p>``` perl</p>

<h1>ユーザ作成</h1>

<p>my $user_rs = $schema->resultset('User');
eval {</p>

<pre><code>my $txn = $schema-&gt;txn_scope_guard;
my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ(ちょっと時間がかかる)
$user_rs-&gt;search({}, {select =&gt; \'SLEEP(1)'})-&gt;all;
$user-&gt;create_related(money =&gt; { yen =&gt; 1000 });

$txn-&gt;commit;
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money ? $user-&gt;money-&gt;yen : 0;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p>これで片一方だけ更新されるのが防げるはず！
ところが、片一方だけ更新自体は防げはするのですが、
今度は所持金を表示するところでコケてしまいます。
トランザクションを使っていないときは正常に表示できていたし、
表示部分は一切いじってないのに不思議ですね。</p>

<p>``` plain
$ perl dbic-test.pl
Transaction aborted: DBIx::Class::Storage::DBI::<em>dbh_execute(): DBI Exception: DBD::mysql::st execute failed: Lost connection to MySQL server during query [for Statement "SELECT SLEEP(1) FROM user me"] at dbic-test.pl line 80
 Rollback failed: DBIx::Class::Storage::DBI::</em>exec_txn_rollback(): DBI Exception: DBD::mysql::db rollback failed: Turning on AutoCommit failed at dbic-test.pl line 72
DBIx::Class::Storage::DBI::_dbh_execute(): DBI Exception: DBD::mysql::st execute failed: MySQL server has gone away [for Statement "SELECT me.id, me.username FROM user me WHERE ( id = ? )" with ParamValues: 0=1] at dbic-test.pl line 89</p>

<h1>※「ユーザが見つかりませんでした」と表示されて欲しいがされない</h1>

<p>```</p>

<p>実はコネクションがタイムアウトしたとはMySQLとの再接続をする必要があるのですが、
DBIx::Classが裏で再接続処理を自動的にやってくれるので、普段は意識する必要はありません。
ただし例外があって、 <strong>トランザクションの中では再接続処理を行ってくれません</strong> 。</p>

<p>トランザクション内で勝手に再接続が行われると逆に困るので、この挙動自体は正しいのですが、
これにロールバックが絡むと少し不思議なことが起こります。
<strong>ロールバックしてトランザクションを抜けても、DBIx::Classはトランザクションの中にいると判断してしまうのです。</strong>
このことは<code>transaction_depth</code>を見ることで確認できます。</p>

<p>``` perl</p>

<h1>ユーザ作成</h1>

<p>my $user_rs = $schema->resultset('User');
say 'transaction_depth = ', $schema->storage->{transaction_depth};
eval {</p>

<pre><code>my $txn = $schema-&gt;txn_scope_guard;
say 'transaction_depth = ', $schema-&gt;storage-&gt;{transaction_depth};
my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ(ちょっと時間がかかる)
$user_rs-&gt;search({}, {select =&gt; \'SLEEP(1)'})-&gt;all;
$user-&gt;create_related(money =&gt; { yen =&gt; 1000 });

$txn-&gt;commit;
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}
say 'transaction_depth = ', $schema->storage->{transaction_depth};</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money ? $user-&gt;money-&gt;yen : 0;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p><code>plain
$ perl dbic-test.pl
transaction_depth = 0
transaction_depth = 1
Transaction aborted: DBIx::Class::Storage::DBI::_dbh_execute(): DBI Exception: DBD::mysql::st execute failed: Lost connection to MySQL server during query [for Statement "SELECT SLEEP(1) FROM user me"] at dbic-test.pl line 82
 Rollback failed: DBIx::Class::Storage::DBI::_exec_txn_rollback(): DBI Exception: DBD::mysql::db rollback failed: Turning on AutoCommit failed at dbic-test.pl line 73
transaction_depth = 1 # ※トランザクションの外なのに1になってる
DBIx::Class::Storage::DBI::_dbh_execute(): DBI Exception: DBD::mysql::st execute failed: MySQL server has gone away [for Statement "SELECT me.id, me.username FROM user me WHERE ( id = ? )" with ParamValues: 0=1] at dbic-test.pl line 92
</code></p>

<p>この状態になるといつまで経っても再接続は行われません。
都度接続なら大きな問題にはならないのですが、Webアプリでコネクションの永続化を行っている場合は深刻です。
一度タイムアウトすると以後のリクエストがすべて失敗してしまいます。</p>

<h3>確実に再接続を行う</h3>

<p>これを防ぐには確実に再接続をおこなって欲しいところで <code>$schema-&gt;storage-&gt;ensure_connected;</code> を実行します。</p>

<p>``` perl</p>

<h1>ユーザ作成</h1>

<p>my $user_rs = $schema->resultset('User');
eval {</p>

<pre><code>my $txn = $schema-&gt;txn_scope_guard;
my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ(ちょっと時間がかかる)
$user_rs-&gt;search({}, {select =&gt; \'SLEEP(1)'})-&gt;all;
$user-&gt;create_related(money =&gt; { yen =&gt; 1000 });

$txn-&gt;commit;
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}</p>

<p>$schema->storage->ensure_connected;</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money ? $user-&gt;money-&gt;yen : 0;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p>こうすることで、何度実行しても「所持金1000のユーザが作られる」or「ユーザが見つかりませんでした」の状態になり、
中途半端な状態のユーザが作られたり、再接続に失敗したりということはなくなります。</p>

<p>``` plain
$ perl dbic-test.pl
Transaction aborted: DBIx::Class::Storage::DBI::<em>dbh_execute(): DBI Exception: DBD::mysql::st execute failed: Lost connection to MySQL server during query [for Statement "SELECT SLEEP(1) FROM user me"] at dbic-test.pl line 80
 Rollback failed: DBIx::Class::Storage::DBI::</em>exec_txn_rollback(): DBI Exception: DBD::mysql::db rollback failed: Turning on AutoCommit failed at dbic-test.pl line 72</p>

<pre><code>    (in cleanup) {UNKNOWN}: DBI Exception: DBD::mysql::db DESTROY failed: MySQL server has gone away  at /home/ichinose/.plenv/versions/5.20.2/lib/perl5/site_perl/5.20.2/DBIx/Class/Schema.pm line 1077.
    DBIx::Class::Schema::throw_exception(My::Schema=HASH(0x118d088), "DBI Exception: DBD::mysql::db DESTROY failed: MySQL server ha"...) called at /home/ichinose/.plenv/versions/5.20.2/lib/perl5/site_perl/5.20.2/DBIx/Class/Storage.pm line 113
    DBIx::Class::Storage::throw_exception(DBIx::Class::Storage::DBI::mysql=HASH(0x118d718), "DBI Exception: DBD::mysql::db DESTROY failed: MySQL server ha"...) called at /home/ichinose/.plenv/versions/5.20.2/lib/perl5/site_perl/5.20.2/DBIx/Class/Storage/DBI.pm line 1473
    DBIx::Class::Storage::DBI::__ANON__("DBD::mysql::db DESTROY failed: MySQL server has gone away", DBI::db=HASH(0x16efbb8), undef) called at dbic-test.pl line 91
    eval {...} called at dbic-test.pl line 91
</code></pre>

<p>ユーザが見つかりませんでした
```</p>

<h2>ネストしたトランザクションとロールバックの微妙な関係</h2>

<h3>トランザクションをネストする</h3>

<p>キャンペーン期間中なので通常1000円のところ2000円で初期化してあげることになりました。
<strong>2000円への更新処理の途中で何かエラーが起こった場合は1000円で初期化して欲しい</strong> ので、
以下のようにトランザクションをネストしてみました。</p>

<p>``` perl
eval {</p>

<pre><code>my $txn = $schema-&gt;txn_scope_guard;
my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ
my $money = $user-&gt;create_related(money =&gt; { yen =&gt; 1000 });

# キャンペーン期間中なので2000円で初期化してげよう
{
    my $txn2 = $schema-&gt;txn_scope_guard;
    $money-&gt;update({yen =&gt; 2000});
    undef $txn2; # エラーが起こったのでロールバックして欲しい！1000円にもどって!!
}

$txn-&gt;commit;
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}</p>

<p>$schema->storage->ensure_connected;</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money-&gt;yen;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p>わざとエラーが起こるようにして実行してみましょう。</p>

<p><code>plain
$ perl dbic-test.pl
DBIx::Class::Storage::TxnScopeGuard::DESTROY(): A DBIx::Class::Storage::TxnScopeGuard went out of scope without explicit commit or error. Rolling back. at dbic-test.pl line 88
名前: ok_macopy
所持金: 2000
</code></p>

<p>2000円！</p>

<p><strong>「Rolling back」って出てるのに全然ロールバックされてない！</strong></p>

<h3>SAVE POINTを使う</h3>

<p>接続時に<code>auto_savepoint</code>オプションを有効にすると、<code>SAVE POINT</code>を使った部分的なロールバックが使用可能になります。</p>

<p>``` perl
my $schema = My::Schema->connect('dbi:mysql:host=127.0.0.1;port=3306;database=test;mysql_write_timeout=1;mysql_read_timeout=1', 'root', '', {</p>

<pre><code>auto_savepoint =&gt; 1,
</code></pre>

<p>});
```</p>

<p><code>plain
$ perl dbic-test.pl
DBIx::Class::Storage::TxnScopeGuard::DESTROY(): A DBIx::Class::Storage::TxnScopeGuard went out of scope without explicit commit or error. Rolling back. at dbic-test.pl line 90
名前: ok_macopy
所持金: 1000
</code></p>

<h3>大人しく全部ロールバックする</h3>

<p>MySQLにはSAVE POINTという便利機能があるとはいえ、どこまでロールバックするべきかを管理するのはすごく大変です。
現実的には ALL or NOTHING、失敗したら全部ロールバックで十分なのではと思ってます。
このサンプルではdieしてしまえばいいですね。</p>

<p>``` perl
eval {</p>

<pre><code>my $txn = $schema-&gt;txn_scope_guard;
my $user = $user_rs-&gt;create({
    id       =&gt; 1,
    username =&gt; 'ok_macopy',
});

# ユーザを初期化するためクエリ
my $money = $user-&gt;create_related(money =&gt; { yen =&gt; 1000 });

# キャンペーン期間中なので2000円で初期化してげよう
{
    my $txn2 = $schema-&gt;txn_scope_guard;
    $money-&gt;update({yen =&gt; 2000});
    die 'something error!'; # エラーが起こったのでロールバックして欲しい！1000円にもどって!!
}

$txn-&gt;commit;
</code></pre>

<p>};
if (my $err = $@) {</p>

<pre><code>warn $err;
</code></pre>

<p>}</p>

<p>$schema->storage->ensure_connected;</p>

<p>my $user = $user_rs->search({ id => 1 })->single;
if ($user) {</p>

<pre><code>say "名前: ", $user-&gt;username;
say "所持金: ", $user-&gt;money-&gt;yen;
</code></pre>

<p>} else {</p>

<pre><code>say "ユーザが見つかりませんでした";
</code></pre>

<p>}
```</p>

<p><code>plain
something error! at dbic-test.pl line 85.
ユーザが見つかりませんでした
</code></p>

<p>途中で<code>eval</code>して例外キャッチしているとロールバックしたのにコミットされる現象が起こる
(その場合警告すら出ないっぽいので更に怖い)ので、例外握り潰していたら要注意です。</p>

<p>部分的なロールバックができない場合は、
「子トランザクションがロールバックされていたら親トランザクションのコミットが失敗する」
が安全だと思うんですが、なぜこんな挙動になっているんでしょうね。
誰か経緯についてご存知のかたは教えていただきたいです。</p>

<h2>まとめ</h2>

<ul>
<li>トランザクション外では自動的に再接続してくれるが、トランザクション内では行われない</li>
<li>必ず再接続して欲しいところで <code>$schema-&gt;storage-&gt;ensure_connected;</code></li>
<li>部分的なロールバックはやらないのが吉</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl の DateTime 利用上の注意点]]></title>
    <link href="http://shogo82148.github.io/blog/2015/12/09/perl-datetime/"/>
    <updated>2015-12-09T00:00:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/12/09/perl-datetime</id>
    <content type="html"><![CDATA[<p>この投稿は <a href="http://qiita.com/advent-calendar/2015/perl5">Perl 5 Advent Calendar 2015</a> の 9日目の記事です。</p>

<p><a href="http://developer.hatenastaff.com/entry/2015/12/02/050000">Perl の Time::Piece 利用上の注意点</a>
という記事の最後に<a href="https://metacpan.org/release/DateTime">DateTime</a>への言及があったのですが、
DateTimeはDateTimeでいろいろとハマりどころがあるんですよね・・・。
僕も今年いくつか罠にハマりました。ちょうどアドベントカレンダーの季節ですし、この機会にハマりどころをまとめてみることにします。</p>

<!-- More -->


<h2>遅い</h2>

<p>いろんなところで言われていることですが <strong>遅い</strong> です。
試しに代表的な日付を扱うモジュールでベンチをとってみました。
(比較のために時間をとるためのPerlの組み込み関数も入れてあります)</p>

<p>``` perl</p>

<h1>いろんな形式で今の時間を取得する</h1>

<p>use Benchmark qw/ cmpthese /;
use Time::HiRes ();
use Time::Moment;
use Time::Piece ();
use DateTime;</p>

<p>cmpthese 0, {</p>

<pre><code>'time'         =&gt; sub { time },
'Time::HiRes'  =&gt; sub { Time::HiRes::time },
'localtime'    =&gt; sub { () = localtime },
'Time::Moment' =&gt; sub { Time::Moment-&gt;now },
'Time::Piece'  =&gt; sub { Time::Piece-&gt;localtime },
'DateTime'     =&gt; sub { DateTime-&gt;now( time_zone=&gt;'Asia/Tokyo' ) },
</code></pre>

<p>};
```</p>

<p><code>
Rate DateTime Time::Piece Time::Moment localtime Time::HiRes  time
DateTime         5303/s       --        -95%         -98%      -99%       -100% -100%
Time::Piece    103765/s    1857%          --         -67%      -71%        -98%  -99%
Time::Moment   313599/s    5814%        202%           --      -11%        -93%  -98%
localtime      354215/s    6580%        241%          13%        --        -92%  -98%
Time::HiRes   4706723/s   88658%       4436%        1401%     1229%          --  -72%
time         16536995/s  311751%      15837%        5173%     4569%        251%    --
</code></p>

<p>それにしてもTime::Moment速いですね。組み込みのlocaltimeと互角とは。</p>

<h2>演算は破壊的</h2>

<p>add, subtract等の演算を行うメソッドは破壊的です。
例えば、一時間後の日時を求めたい場合に以下のように書くと、
もとの日時が失われてしまいます。</p>

<p>``` perl</p>

<h1>1時間後の日時を求める間違った例</h1>

<p>use feature 'say';
use DateTime;</p>

<p>my $dt = DateTime->new(year => 2015, month => 12, day => 9);
my $after_an_hour = $dt->add(hours => 1);</p>

<p>say $dt; # 2015-12-09T01:00:00
say $after_an_hour; # 2015-12-09T01:00:00
```</p>

<p>以下のようにcloneしてから演算することで防ぐことができます。</p>

<p>``` perl</p>

<h1>1時間後の日時を求める間違った例</h1>

<p>use feature 'say';
use DateTime;</p>

<p>my $dt = DateTime->new(year => 2015, month => 12, day => 9);
my $after_an_hour = $dt->clone->add(hours => 1);</p>

<p>say $dt; # 2015-12-09T00:00:00
say $after_an_hour; # 2015-12-09T01:00:00
```</p>

<h2>うるう秒の存在</h2>

<p>さて問題です。
「日本時間2015年7月1日午前9時の1秒前は何時何分何秒でしょう？」</p>

<p>簡単そうな問題ですが、一応DateTimeに計算してもらって確かめてもらいましょう。</p>

<p><code>perl datetime.pl
use feature qw(say);
use DateTime;
my $dt = DateTime-&gt;new( year =&gt; 2015, month =&gt; 7, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></p>

<p>これを現時点での最新バージョンであるDateTime-1.21を使って実行してみます。</p>

<p><code>bash
$ perl datetime.pl
2015-07-01T08:59:60
</code></p>

<p>はい、正解は <strong>「8時59分60秒」</strong> です。
「60秒はおかしい。8時59分59秒では？？？」という声が聞こえてきそうですが、60秒が正解です。
今年の7月1日は<a href="http://gigazine.net/news/20150701-leap-second-insert/">3年ぶりにうるう秒が挿入された日</a>でした。
そのため <strong>通常は存在しない60秒がこの日だけ存在します。</strong>
うるう秒についてはWikipediaの<a href="https://ja.wikipedia.org/wiki/%E9%96%8F%E7%A7%92">閏秒</a>の項目どうぞ。
インフラを担当されているかたは対応に苦労したかたも多いのではないでしょうか。</p>

<p>うるう秒は存在だけでも厄介ですが、さらに厄介なことに <strong>うるう秒調整のタイミングは実施される半年前になるまでわかりません</strong> 。
次調整が入るとすれば2016年7月1日ですが、2015年の現時点では調整が入るのか入らないのか確かなことは言えません(今までの傾向からないとは思いますが)。
事前に分からないものに対してDateTimeがどう対処しているかというと、<strong>うるう秒の調整が行われることがわかった時点でバージョンアップして対応</strong> しています。
そのため、2015年7月1日のうるう秒の存在を知らないバージョン(具体的には1.17以前)で先ほどのコードを実行すると、
最新版とは異なった結果が帰ってきます。</p>

<p><code>bash
$ cpanm DateTime@1.17
$ perl datetime.pl
2015-07-01T08:59:59
</code></p>

<p>さて、うるう秒を正確に扱いたい場合は便利な機能ですが、
DateTimeモジュール以外のプログラムがうるう秒を正しく扱えるとは限らないので無視したいケースも多いと思います。
パッと思いつくのは以下のような対応でしょうか・・・。</p>

<ul>
<li>タイムゾーンに <code>floating</code> を指定する

<ul>
<li>「タイムゾーン情報を持っていない」ことを表す特殊なタイムゾーンです</li>
<li>うるう秒の調整のようなタイムゾーン情報が必要な機能はすべて無効になります</li>
<li>タイムゾーンを扱えるのがDateTimeの利点だったのに・・・</li>
</ul>
</li>
<li>うるう秒に関する定義を削除した自前ビルドを用意する

<ul>
<li>DateTimeのレポジトリに<a href="https://github.com/autarch/DateTime.pm/blob/master/leaptab.txt">うるう秒の挿入タイミング一覧</a>が定義されているので、これを削除した自前ビルドを用意する方法</li>
<li>なお、この一覧はビルド時にXSのコードの一部として組み込まれるようなので、ランタイムに何とかすることはできない模様</li>
</ul>
</li>
<li>一度DateTimeをインストールしたら絶対にバージョンアップを行わない。インストールした日時よりも半年以上未来の日時だけ扱う

<ul>
<li>通常半年前にうるう秒の調整は決定されるので、DateTimeはリリース後半年以上未来のうるう秒は知りません</li>
<li>そのため、半年以上未来の日時を扱う限りはうるう秒とは無縁でいられます</li>
</ul>
</li>
</ul>


<p>どれもBK臭溢れる対応なので、もっとスマートな対応方法をご存知のかたはご教授いただけると幸いです。</p>

<h2>ある日からある日までの日数を知りたい</h2>

<p>DateTimeは演算子オーバーロードされているため、通常の数値を同じように引き算が可能です。
引き算を使ったほうが手軽にできるからと以下のように書いてしまうとハマります。</p>

<p>``` perl</p>

<h1>日数計算の間違った例</h1>

<p>my $dt1 = DateTime->new( year => 2015, month => 12, day => 25, time_zone => 'Asia/Tokyo' );
my $dt2 = DateTime->new( year => 2015, month => 12, day => 9, time_zone => 'Asia/Tokyo' );
my $dur = $dt1 - $dt2;
say $dur->in_units('days'); # 16
```</p>

<p>一見動いているように見えますが、期間が一ヶ月を超えるような場合に間違った結果を返します。</p>

<p>``` perl</p>

<h1>日数計算の間違った例</h1>

<p>my $dt1 = DateTime->new( year => 2015, month => 12, day => 25, time_zone => 'Asia/Tokyo' );
my $dt2 = DateTime->new( year => 2015, month => 11, day => 9, time_zone => 'Asia/Tokyo' );
my $dur = $dt1 - $dt2;
say $dur->in_units('days'); # 16
```</p>

<p>引き算で帰ってくるDateTime::Durationオブジェクトは「1ヶ月と16日」という情報を持っているのですが、
「1ヶ月」の日数が月によってことなるため計算ができないのです。
以下のように差分を求める時点で日数を計算するように伝えるのが正しいやり方です。</p>

<p>``` perl</p>

<h1>正しいやりかた</h1>

<p>my $dt1 = DateTime->new( year => 2015, month => 12, day => 25, time_zone => 'Asia/Tokyo' );
my $dt2 = DateTime->new( year => 2015, month => 11, day => 9, time_zone => 'Asia/Tokyo' );
my $dur = $dt1->delta_days($dt2);
say $dur->in_units('days'); # 46
```</p>

<h2>ある日時からある日時までの秒数を知りたい</h2>

<p>日数がわかったところで、次は秒数を求めてみましょう。
これも演算子オーバーロードを使うとハマります。</p>

<p>``` perl</p>

<h1>秒数計算の間違った例</h1>

<p>my $dt1 = DateTime->new( year => 2015, month => 12, day => 10, time_zone => 'Asia/Tokyo' );
my $dt2 = DateTime->new( year => 2015, month => 12, day =>  9, time_zone => 'Asia/Tokyo' );
my $dur = $dt1-$dt2;
say $dur->in_units('seconds'); # 0
```</p>

<p>$durには「1日」という情報が入っているはずなので、普通に考えるとこれから秒数は求められそうです。
1分は60秒で、1時間は60分で、1日は24時間なので、「1日=60×60×24秒」ですよね。
なぜ求められないのでしょう？</p>

<p>・・・そう、<strong>うるう秒</strong> です。
うるう秒が存在するため、1分は59秒の場合もあれば、61秒の場合もあります。
日数を求めるときと同じように、差分を求める時点で秒数の計算を行うように伝えるとうまくいきます。</p>

<p>``` perl</p>

<h1>正しいやりかた</h1>

<p>my $dt1 = DateTime->new( year => 2015, month => 12, day => 10, time_zone => 'Asia/Tokyo' );
my $dt2 = DateTime->new( year => 2015, month => 12, day =>  9, time_zone => 'Asia/Tokyo' );
my $dur = $dt1->subtract_datetime_absolute($dt2);
say $dur->in_units('seconds'); # 86400
```</p>

<p>ちなみに今年はうるう秒の挿入があったので、 <strong>DateTimeの最新版で今年の秒数を計算すると 365×24×60×60秒よりも1秒だけ長くなります</strong> 。
そして今年のうるう秒の挿入を知らない <strong>DateTime1.17では365×24×60×60秒</strong>が帰ってきます。</p>

<p><code>perl
my $dt1 = DateTime-&gt;new( year =&gt; 2016, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1-&gt;subtract_datetime_absolute($dt2);
say $dur-&gt;in_units('seconds'); # 31536001 or 31536000 (DateTimeのバージョンによって異なります)
</code></p>

<p><code>epoch</code>は1970年1月1日午前0時(UTC)からの経過秒数を返すメソッドですが、
これは実際の経過時間ではなく形式的な経過秒数(つまりうるう秒を考慮しない)を返します。
そのため、以下のように秒数を求めるとどのバージョンでも同じ結果が帰ってくるはずです。</p>

<p><code>perl
my $dt1 = DateTime-&gt;new( year =&gt; 2016, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
say $dt1-&gt;epoch() - $dt2-&gt;epoch(); # 31536000
</code></p>

<p>もうDateTimeなんか使うのやめて<code>epoch</code>使おうぜ！！
(もちろん実際の経過時間はうるう秒の+1があるのが正しいので、ケースバイケースですが)</p>

<h2>まとめ</h2>

<p>DateTimeは日時をしっかり扱ってくれる素晴らしいモジュールです。
きっと <strong>あなたが思っている以上に日時を正確に厳密に扱ってくれます</strong> 。
そこまで厳密にやるか・・・というところまでしっかり扱ってくれるので、
日時計算に潜んだ様々な闇に触れることになるでしょう。
使う側もそれらのことについてしっかりと理解しておく必要があります。</p>

<p>まあ、具体的に言うと <strong>うるう秒</strong> とか <strong>うるう秒</strong> とかですね！
廃止論とかありましたけど、<a href="http://internet.watch.impress.co.jp/docs/news/20151120_731707.html">とりあえず2023年までは調整がはいる</a>そうです・・・。</p>

<p>他にもいろいろ罠がありそう・・・知っているかたがいれば教えて下さい。</p>
]]></content>
  </entry>
  
</feed>
