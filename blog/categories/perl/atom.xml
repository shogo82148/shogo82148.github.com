<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-08-25T07:20:49+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Perl 5.26 & Unicode 9.0 で変わる書記素クラスタ(grapheme cluster)のお話]]></title>
    <link href="https://shogo82148.github.io/blog/2017/08/25/unicode9-grapheme-cluster/"/>
    <updated>2017-08-25T07:08:44+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/08/25/unicode9-grapheme-cluster</id>
    <content type="html"><![CDATA[<p><a href="http://gihyo.jp/magazine/wdpress/archive/2017/vol100">WEB+DB PRESS Vol.100</a>が発売されましたね。
記念すべき Vol.100 おめでとうございます！</p>

<p><a href="https://www.amazon.co.jp/WEB-DB-PRESS-Vol-100-%E6%B2%B3%E5%8E%9F/dp/4774191299/ref=as_li_ss_il?_encoding=UTF8&psc=1&refRID=KWT48YN41EFBHYXPM8YQ&linkCode=li2&tag=shogo82148-22&linkId=c41e466f8dad4ea5b2c2287f1e6c5efc" target="_blank"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4774191299&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=shogo82148-22" ></a><img src="https://ir-jp.amazon-adsystem.com/e/ir?t=shogo82148-22&l=li2&o=9&a=4774191299" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<p>WEB+DB PRESS の連載「Perl Hackers Hub」今回のテーマは「【第46回】Perl 5.26で変わること」です。
Perl 5.26 で追加になった機能、アップグレードの際に気をつけなければならないところ( 特に @INC 問題とか )などに触れられているので、
Perl Monger の方はぜひ読むとよいと思います。</p>

<p>追加された機能のひとつとして Unicode 9.0 サポートが挙げられているのですが、以下のような簡単な紹介に留まっています。</p>

<blockquote><p>Unicode 9.0にはオリンピックで活躍するであろう金銀 銅メダルの絵文字などが追加されました。</p></blockquote>

<p>Unicode 9.0 で変わるのはそれだけではありません！
Unicode 9.0 での <strong>書記素クラスタ(grapheme cluster)</strong> の扱いを少し前に調査したので紹介します。</p>

<!-- More -->


<h2>書記素クラスタ(grapheme cluster)とは</h2>

<p>書記素クラスタ(grapheme cluster)とは、人間にとって自然な1文字を表すものです。</p>

<p>たとえば &ldquo;é&rdquo; という文字は一見1文字に見えますが、 <code>length</code> で文字数をカウントすると2文字としてカウントされます。</p>

<pre><code>$ perl -Mutf8 -E 'say length "é"'
2
</code></pre>

<p>これは <code>length</code> がUnicodeのコードポイント数を数えており、
&ldquo;é"が"e&rdquo;(U+0065) + アクセント記号(U+0301) の2つのコードポイントで構成されているためです。</p>

<p>他にも<a href="https://ja.wikipedia.org/wiki/%E7%95%B0%E4%BD%93%E5%AD%97%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF">異字体セレクタ</a>というのがあったり、
<a href="http://qiita.com/_sobataro/items/47989ee4b573e0c2adfc#%E7%B5%B5%E6%96%87%E5%AD%97%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9">絵文字シーケンス</a>というのがあったりして、
コードポイントの数＝文字数とは限りません。</p>

<p>これらの文字たちを1文字として数えるための概念が書記素クラスタ(grapheme cluster)です。</p>

<h2>Unicode 9.0での変更点</h2>

<p>Unicode 8.0以前も書記素クラスタはあるのですが、
&ldquo;👨‍👨‍👦"のような家族の絵文字が3文字とカウントされてしまったり、
"🇯🇵🇯🇵🇯🇵"のように国旗が連続していると1文字にカウントされてしまったりと、
問題がありました。
Unicode 9.0からはこれらの問題が解決されています。</p>

<p>詳しくは<a href="http://qiita.com/_sobataro/items/47989ee4b573e0c2adfc#%E6%9B%B8%E8%A8%98%E7%B4%A0%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B-unicode-90-%E4%BB%A5%E9%99%8D%E3%81%A8-80-%E4%BB%A5%E5%89%8D%E3%81%AE%E9%81%95%E3%81%84">書記素クラスタに関する Unicode 9.0 以降と 8.0 以前の違い</a>を参照してください。</p>

<h2>Perlでの書記素クラスタ</h2>

<h3>書記素クラスタの使い方</h3>

<p>Perlでは正規表現<code>\X</code>が書記素クラスタにマッチします
(<a href="https://perldoc.perl.org/perlrebackslash.html#Misc">Misc in perlrebackslash</a>)。</p>

<pre><code class="perl">use utf8;
use 5.24.1;
binmode(STDOUT, ":utf8");

my $str = "eé";
my @characters;

@characters = split //, $str;
say "splitを使った場合: ", join " ", @characters;

# 書記素クラスタ
@characters = $str =~ /\X/g;
say "書記素クラスタを使った場合: ", join " ", @characters;
</code></pre>

<ul>
<li><a href="https://wandbox.org/permlink/ImSQW7QAkadczlqt">[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ</a></li>
</ul>


<p>文字数をカウントは「<a href="https://shogo82148.github.io/blog/2015/04/09/count-substrings-in-perl/">Perlで文字列の出現回数を調べる</a>」の
方法が使えます。</p>

<pre><code class="perl">use utf8;
use 5.24.1;

my $str = "eé";

my $length =()= $str =~ /\X/g;
say $length;
</code></pre>

<p>(後から知ったことですが、この <code>=()=</code> を使ったハックには <a href="https://metacpan.org/pod/distribution/perlsecret/lib/perlsecret.pod#Goatse">画像検索してはいけない名前</a> がついているらしいです)</p>

<h3>Perl5.24とPerl5.26の違い</h3>

<p>Perl 5.26 は Unicode 8.0 をサポートしているので、書記素クラスタの問題点が改善されています。
たとえば、Perl 5.24では &ldquo;🇯🇵🇯🇵🇯🇵"が1文字としてカウントされてしまいますが・・・</p>

<pre><code class="perl">use utf8;
use 5.24.1;

my $length =()= "🇯🇵🇯🇵🇯🇵" =~ /\X/g;
say $length; # =&gt; 1
</code></pre>

<ul>
<li><a href="https://wandbox.org/permlink/QKl5K45F8BvvPMfz">[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ</a></li>
</ul>


<p>Perl 5.26 では3文字としてカウントされます。</p>

<pre><code class="perl">use utf8;
use 5.26.0;

my $length =()= "🇯🇵🇯🇵🇯🇵" =~ /\X/g;
say $length; # =&gt; 3
</code></pre>

<ul>
<li><a href="https://wandbox.org/permlink/s05vJF33MlCj9Qvl">[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ</a></li>
</ul>


<h2>FYI: 他の言語の対応状況</h2>

<h3>Ruby</h3>

<p><a href="http://qiita.com/_sobataro/items/47989ee4b573e0c2adfc">Unicode 絵文字にまつわるあれこれ (絵文字の標準とプログラム上でのハンドリング)</a>で紹介されているように、
<a href="https://github.com/ruby/ruby/blob/17c2828581a4dcd9babb5c754f240aa86523c673/NEWS#L133-L143">Ruby 2.4.0</a>から対応してます。
Ruby 2.4.0は2016年12月25日に正式リリースされているので、この記事を書いている現在(2017年8月25日)は安心して使えます。</p>

<h3>Python</h3>

<p>残念ながら標準の正規表現ライブラリ <a href="https://docs.python.jp/3/library/re.html">re</a> は書記素クラスタに対応していません。
サードパーティーの<a href="https://pypi.python.org/pypi/regex/">reqex</a>がUnicode 10に対応しているらしいので、
そちらを使うと書記素クラスタを扱えるようです。</p>

<h3>Golang</h3>

<blockquote><p><a href="https://github.com/google/re2/wiki/Syntax">https://github.com/google/re2/wiki/Syntax</a>
extended Unicode sequence (NOT SUPPORTED)</p></blockquote>

<p>正規表現は対応していません、残念・・・</p>

<ul>
<li><a href="https://github.com/golang/go/issues/14820">https://github.com/golang/go/issues/14820</a></li>
</ul>


<p><code>x/text</code> に書記素クラスタを扱う機能を追加しようというIssueはありますが、今のところ進捗はないようです。</p>

<h2>参考</h2>

<ul>
<li><a href="https://hydrocul.github.io/wiki/blog/2015/1025-unicode-grapheme-clusters.html">Unicodeのgrapheme cluster (書記素クラスタ)</a></li>
<li><a href="http://qiita.com/_sobataro/items/47989ee4b573e0c2adfc">Unicode 絵文字にまつわるあれこれ (絵文字の標準とプログラム上でのハンドリング)</a></li>
<li><a href="https://engineering.linecorp.com/ja/blog/detail/52">文字数をカウントする7つの方法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl+List::Utilの64bit整数の罠にはまった話]]></title>
    <link href="https://shogo82148.github.io/blog/2017/04/13/perl-int64/"/>
    <updated>2017-04-13T19:52:13+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/04/13/perl-int64</id>
    <content type="html"><![CDATA[<p>先日 <a href="https://code.google.com/codejam/contest/3264486/dashboard">Google Code Jam Qualification Round 2017</a> が開催されました
(って何？というひとは<a href="https://code.google.com/codejam/about">About</a>のページを確認。本題では無いので説明略)。</p>

<p>僕もこれに参加して、D以外の問題A,B,Cを解いて、無事Round1へ進むことができました。
しかしPerlで解いたC-largeだけ何故か間違いの判定。
原因を探ってみたところ、PerlおよびList::Utilの64bit整数の罠にはまっていたことに気が付いたので、その備忘録として残しておきます。</p>

<!-- More -->


<h2>問題が発生したコード</h2>

<p>問題が発生するのは以下の計算をするコードです。</p>

<ul>
<li>max: 250000000000000000と249999999999999999で大きい方を返す</li>
<li>div: 249999999999999999を2で割った商を求める</li>
</ul>


<p>この計算をそれぞれ二通りの計算方法で実装してみます。</p>

<pre><code class="perl">use 5.24.0;
use List::Util qw(max);

say "max:";
say max(250000000000000000, 249999999999999999);
say max(249999999999999999, 250000000000000000);

say "div:";
say int(249999999999999999/2);
say 249999999999999999 &gt;&gt; 1;
</code></pre>

<ul>
<li>max: 順番を変えただけなので、同じ結果をになるはず</li>
<li>div: 割り算と等価なビットシフトに置き換えたので、同じ結果になるはず</li>
</ul>


<p>僕は「同じ結果になるはず」と期待していました。
しかし、これを実行してみると以下のようになります。</p>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/5fUBzLmBCRKUo4xZ">https://wandbox.org/permlink/5fUBzLmBCRKUo4xZ</a></li>
</ul>


<pre><code class="plain">max:
249999999999999999
250000000000000000
div:
125000000000000000
124999999999999999
</code></pre>

<h2>原因</h2>

<p>250000000000000000は大体2<sup>57</sup>.8なので、64bitの整数で十分表現できます。
しかし倍精度浮動小数点数として扱われると、精度が53bit分しかないので正確に表現できないのです。</p>

<p>例えば以下のコードは"true"を出力します(ここだけ何故かGo)。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    fmt.Println(float64(250000000000000000) == float64(250000000000000000-1))
}
</code></pre>

<p>いわゆる<a href="https://ja.wikipedia.org/wiki/%E8%AA%A4%E5%B7%AE#.E6.83.85.E5.A0.B1.E8.90.BD.E3.81.A1">情報落ち</a>ってやつです。
Perlが演算の途中で倍精度浮動小数点数に変換してしまうので、250000000000000000と249999999999999999を区別できないんですね。</p>

<h2>maxの解決策1 Reduceを使う</h2>

<p>最大値を求める<code>max</code>は<code>reduce</code>を使っても簡単に作ることが出来ます。
この実装方だと、順番にかかわらず同じ結果を返します。</p>

<pre><code class="perl">use 5.24.0;
use List::Util qw(reduce);

say "reduce:";
say reduce { $a &gt; $b ? $a : $b } 250000000000000000, 249999999999999999;
say reduce { $a &gt; $b ? $a : $b } 249999999999999999, 250000000000000000;
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/lzKkOXzqx2fXlr69">https://wandbox.org/permlink/lzKkOXzqx2fXlr69</a></li>
</ul>


<p>個人的には<code>max</code>を使っても<code>reduce</code>を使っても同じ結果が変えるのが正しいのでは、と思うのですがどうでしょう？</p>

<ul>
<li><a href="https://rt.cpan.org/Public/Bug/Display.html?id=95902">Bug #95902 for Scalar-List-Utils: sum, min, and max use NV, truncating integers on 64-bit machines</a></li>
</ul>


<p>(なんかそれっぽいチケットを見つけたけど、英語の議論についていける気がしないので、静かに見守る・・・)</p>

<h2>maxの解決策2 bigintを使う</h2>

<p><code>max</code>の引数に<code>bigint</code>を渡してやると、正しい結果を返してくれます。</p>

<pre><code class="perl">use 5.24.0;
use bigint;
use List::Util qw(max);

say "max:";
say max(250000000000000000, 249999999999999999);
say max(249999999999999999, 250000000000000000);
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/QTnEkQJ2698VWkgG">https://wandbox.org/permlink/QTnEkQJ2698VWkgG</a></li>
</ul>


<p>ただし、今回の僕のケースでは「ハッシュのキーの中で一番大きいものを取得する」処理が必要だったので、<code>bigint</code>だけでは解決しません。</p>

<pre><code class="perl">use 5.24.0;
use bigint;
use List::Util qw(max);

for (1..10) {
    my %h = (250000000000000000 =&gt; 1, 249999999999999999 =&gt; 1);
    say max(keys %h);
}
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/af0YXdjRlVzYvm0u">https://wandbox.org/permlink/af0YXdjRlVzYvm0u</a></li>
</ul>


<p>Perlのハッシュは文字列しか使えないので、強制的に文字列にされてしまうんですね。
さらにややこしいことに<a href="http://akiym.hateblo.jp/entry/2013/05/22/122438">hash randomization</a>によって、
時々正しい結果を返すというのも面倒なところです。</p>

<p>そのため今回のケースでは、<code>bigint</code>に戻す操作を明示的に書いてあげる必要があります。</p>

<pre><code class="perl">use 5.24.0;
use bigint;
use List::Util qw(max);

for (1..10) {
    my %h = (250000000000000000 =&gt; 1, 249999999999999999 =&gt; 1);
    say max(map {$_+0} keys %h);
}
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/zeKfT7TrYaogz00g">https://wandbox.org/permlink/zeKfT7TrYaogz00g</a></li>
</ul>


<h2>divの解決策1: bignumを使う</h2>

<p><code>bignum</code>を使った方法は割り算の計算でも有効です。
ちなみに影響範囲はスコープで制限できるので、全体への影響を避けたい時は<code>{}</code>で囲ってあげましょう。</p>

<pre><code class="perl">use 5.24.0;
{
    use bigint;
    say 249999999999999999/2;
}

say 249999999999999999/2;
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/yIGEXqwtuG9CmR0h">https://wandbox.org/permlink/yIGEXqwtuG9CmR0h</a></li>
</ul>


<h2>divの解決策2: integerを使う</h2>

<p>64bit環境で動くことがわかっているときは<code>bignum</code>の代わりに<code>integer</code>が使えます
(扱えるbit数以外にも違いがあるので、詳細は<a href="http://perldoc.jp/docs/modules/bignum-0.23/bigint.pod">bigintのpod</a>を参照)。
<code>bignum</code>と同様に影響範囲はスコープ内に限定されます。</p>

<pre><code class="perl">use 5.24.0;
say do { use integer; 249999999999999999/2 };
say 249999999999999999/2;
</code></pre>

<ul>
<li>[Wandbox]三へ( へ՞ਊ ՞)へ ﾊｯﾊｯ <a href="https://wandbox.org/permlink/P0ijy2i9qVcY614L">https://wandbox.org/permlink/P0ijy2i9qVcY614L</a></li>
</ul>


<p>Pythonみたいに <code>249999999999999999 // 2</code> と書かせて欲しい・・・
(しかし <code>//</code> は既に別の用途で使われているのであった)</p>

<h2>まとめ</h2>

<ul>
<li>Perlで64bitの整数を扱うときは割り算と<code>min</code>と<code>max</code>と<code>sum</code>に注意</li>
<li>次のRound1ではPerlは使わない</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WEB+DB PRESS Vol.97にPerlとRedisの記事を寄稿しました]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97/"/>
    <updated>2017-02-23T18:27:53+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/23/perl-webdb-vol97</id>
    <content type="html"><![CDATA[<p>昨年末に<a href="https://twitter.com/songmu">Songmu</a>さんからお話を頂き、
<a href="http://gihyo.jp/magazine/wdpress/archive/2017/vol97">WEB+DB PRESS Vol.97</a>内の連載「第43回Perl Hackers Hub」に
「PerlでのRedis活用法」というタイトルで寄稿しました。
発売日は<strong>2月24日</strong>です。</p>

<!-- More -->


<h2>内容</h2>

<p>簡単に内容を紹介しておきます。
Perl使いではじめてRedisを使う人向けに書いたつもりです。</p>

<h3>Redisの簡単な説明</h3>

<p>Redisのインストール方と、Perlからの接続方法、そしてRedisの型の説明です。
記事の中でも紹介していますが、Redisはその豊富な型が特長です。
読者はきっとPerl使いだろうということで、Perlの型(Perlにも型はあるんだよ！！)と
比較しながら簡単に紹介しています。</p>

<h3>Redisの応用例とCPANモジュールの紹介</h3>

<p>Redisを使うとこんなことができるよ、という紹介です。
CPANで公開されているRedis関連のモジュールも合わせて紹介しています。</p>

<h3>Redis自体の注意点</h3>

<p>以前Redisを使ったサービスの運用に携わっていたのですが、
そのなかで実際に起きたことを元に、Redisの注意点について書きました。
さいわいサービスが停止するような事故にはありませんでしたが、
メトリックスを眺めながらエンジニア勢でヤバイヤバイ騒いでましたね・・・。
みなさんも気をつけて下さい。</p>

<h2>執筆してみての感想</h2>

<p>昔から文章を書くのにはだいぶ苦手意識があり、
今回の執筆も非常に苦労しました。
一文の前半を書いた時点で
「今から書こうとしている情報は本当に必要なのか」
「自分の記憶違いで間違った情報なのでは」と不安になり、
色々考えているうちに、何書こうとしてたのかわからなくなるんですよね。
まずは適当に書き上げて、後からちゃんと推敲しよう、
とは思いつつもなかなか進められず・・・。
スループットを上げたい。</p>

<p>細かい表現とかも気になってなかなか進まないので、
こういうの入れて頑張ろうと思います！</p>

<ul>
<li><a href="http://qiita.com/azu/items/2c565a38df5ed4c9f4e1">VS Codeでtextlintを使って文章をチェックする</a></li>
<li><a href="http://takemikami.com/2017/02/14/gitbook.html">gitbookで技術書を書く環境の構築手順</a></li>
</ul>


<p>(執筆が進まないと、こういう環境構築に時間をかけてしまうのもよくないと思うんだ・・・)</p>

<h2>余談</h2>

<p>ところで、<strong>Vol.97</strong>と<strong>第43回</strong>ってどっちも<strong>素数</strong>ですね！
雑なプログラムを書いて調べてみたところ、
両方素数になるのはVol.83, 第29回以来、<strong>7回目</strong>(これも<strong>素数</strong>だ！)。
次はVol.101, 第47回です。
そのときのPerl Hackerは誰になるのでしょうか。楽しみですね！</p>

<pre><code class="perl">use warnings;
use strict;

sub is_prime {
    my $n = shift;
    return 0 if $n &lt; 2;
    my $i = 2;
    while($i*$i&lt;=$n) {
        return 0 if $n % $i == 0;
        $i++;
    }
    return 1;
}

my $i = 1;
for my $n(1..200) {
    my $m = $n-43+97;
    if (is_prime($n) &amp;&amp; is_prime($m)) {
        printf "%3d: Vol.%3d, No.%3d\n", $i, $m, $n;
        $i++;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.19リリースのお知らせ]]></title>
    <link href="https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/"/>
    <updated>2016-12-20T22:38:27+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/pod/Redis::Fast">Redis::Fast 0.19</a> をリリースしました。
主な変更点は以下の通りです。</p>

<ul>
<li><code>reconnect_on_error</code> オプションの追加</li>
<li>Sentinelのノード一覧が更新されない不具合の修正</li>
<li>IPv6の実験的サポート</li>
</ul>


<!-- More -->


<h2><code>reconnect_on_error</code> オプションの追加</h2>

<p><a href="https://github.com/yoheimuta">@yoheimuta</a>さんからのプルリクエストです。
今まではネットワークエラーが発生した時のみ再接続処理が走っていましたが、
Redisがエラーを返した場合にも再接続を行うようになります。
マスタースレーブ構成をしているときに、
何らかの原因によりRedis::Fastからのコネクションを維持したまま、
マスターがスレーブに降格してしまった場合に対処するための機能です。
以下のように設定することで、新しいマスターに再接続を行うことが可能になります。</p>

<pre><code class="perl">my $r = Redis::Fast-&gt;new(
    reconnect          =&gt; 1, # 0以上で再接続有効
    reconnect_on_error =&gt; sub {
        my ($error, $ret, $command) = @_;
        if ($error =~ /READONLY You can't write against a read only slave/) {
            return 1; # 再接続を行う。次の再接続まで最低1秒空ける
        }
        return -1; # 再接続は行わない
    },
);
</code></pre>

<h2>Sentinelのノード一覧が更新されない不具合の修正</h2>

<p>Redis::FastにはどれかひとつのSentinelノードに接続すると、
他のノードの情報を自動的に収集する機能があります。
この機能が最新のRedisでは動いていなかったので修正しました。
具体的にいつからなのかまでは追ってないのですが、
Redisのバージョン3.0.6から3.2.6の間のどこかで
ノード一覧の形式が変わってしまったようです。</p>

<p>(最近Sentinelの話題を聞かないけど、みんな使ってるのかな・・・)</p>

<h2>IPv6の実験的サポート</h2>

<p>サーバの指定にIPv6のアドレスが使えるようになりました。
<code>Redis::Fast-&gt;new(server =&gt; "[::1]:6379")</code> のような指定ができます。</p>

<p>バックエンドのhiredis自体は以前からIPv6に対応していたのですが、
今までRedis::Fastでは正しく動きませんでした。</p>

<p>とりあえずlocalhostに接続できることは確認しましたが、
手元にIPv6のネットワークがなくて検証もできていないため、
実験的サポートという扱いで・・・。
 誰かIPv6に詳しい方、検証お願いします。</p>

<h2>感想</h2>

<ul>
<li>テストがなかなか通らず辛かった</li>
<li>CPAN Autherを変な幾何学模様から変えたい</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DateTime.pmにうるう秒の修正が入った話]]></title>
    <link href="https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/"/>
    <updated>2016-12-15T22:17:47+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm</id>
    <content type="html"><![CDATA[<p>こんにちは、<a href="https://metacpan.org/pod/DateTime">DateTime.pm</a> Watcherのいっちーです。
本日面白いパッチがDateTime.pmに取り込まれたので、ご紹介したいと思います。</p>

<!-- More -->


<p>そのpullreqがこちらです。Closedになっていますが、該当コミットはmasterに取り込まれています。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/pull/48">The leap second in 2012 was on 2012-07-01 not 2012-06-01. #48</a></li>
</ul>


<blockquote><p>per <a href="https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction">https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction</a> the leap second in 2012 was on 2012-07-01 not 2012-06-01. It&rsquo;s is well known that leap seconds only occur directly before Jan 1st or July 1st.</p></blockquote>

<p>適当な和訳「2012年に挿入されたうるう秒は2012年6月1日ではなく2012年7月1日です。よく知られているように、今までに挿入されたうるう秒は1月1日と7月1日の直前だけです。」</p>

<pre><code class="diff">diff --git a/lib/DateTime/LeapSecond.pm b/lib/DateTime/LeapSecond.pm
index 66e1b2b..4a38be2 100644
--- a/lib/DateTime/LeapSecond.pm
+++ b/lib/DateTime/LeapSecond.pm
@@ -108,7 +108,7 @@ sub _initialize {
             1999  Jan. 1  +1
             2006  Jan. 1  +1
             2009  Jan. 1  +1
-            2012  Jun. 1  +1
+            2012  Jul. 1  +1
             2015  Jul. 1  +1
             2017  Jan. 1  +1
             )
</code></pre>

<p>なぜ4年間誰も気が付かなかった。</p>

<h2>このバグの影響</h2>

<p>結論から言うと、<strong>この修正によるDateTime.pmの挙動への影響はありません</strong>。
これを書いている時点で最新版のver1.41には、上記の修正は取り込まれていませんが、
うるう秒は2012年7月1日に正しく挿入されます。</p>

<p>以前<a href="//shogo82148.github.io/blog/2015/12/09/perl-datetime/">Perl の DateTime 利用上の注意点</a>で
うるう秒の確認をしたときと同様に検証してみましょう。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 7, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 6, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59

$ PERL_DATETIME_PP=1 perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59
</code></pre>

<p>DateTime.pmにはXSの実装とPurePerlの実装が含まれていますが、
どちらの実装でも2012年7月1日に正しくうるう秒が挿入され、2012年6月1日にはうるう秒はありません。</p>

<p><a href="https://twitter.com/kazoo04/status/808195587518578688">https://twitter.com/kazoo04/status/808195587518578688</a>">https://twitter.com/kazoo04/status/808195587518578688">https://twitter.com/kazoo04/status/808195587518578688</a></a></p>

<p>まさに、「コード見たら絶対動かないはずなのになぜか思った通りにちゃんと動く」といった感じです。</p>

<h2>なぜ正しく動くのか</h2>

<p>なぜ正しく動くのか、その答えはうるう秒一覧の解析を行う部分にありました。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/blob/ff0e3780ea1c841eb17a0245f5f8061cf10c28d3/lib/DateTime/LeapSecond.pm#L40-L41">DateTime.pm/lib/DateTime/LeapSecond.pm</a></li>
</ul>


<pre><code class="perl">my $utc_epoch
    = DateTime-&gt;_ymd2rd( $year, ( $mon =~ /Jan/i ? 1 : 7 ), $mday );
</code></pre>

<p><strong>Jan.(1月)以外はすべて7月として扱っている！</strong></p>

<p>Janか否かが重要なので、JunだろうがJulだろうが7月として扱われるので、結果的に正しく動くわけです。
「バグを埋め込んでいたけど、実装が適当でたまたま動いていた」というよくあるパターンですね。
将来3月末や9月末に挿入されるようになったとき大丈夫なんでしょうか・・・。
まあ、必要になるのは数百年後とかなので、僕には関係ない・・・そう、関係ないのです・・・。</p>

<h2>まとめ</h2>

<ul>
<li>DateTime.pmのうるう秒一覧にbug fix</li>
<li>動作に影響は無いので、ユーザ側では特に気にする必要はない

<ul>
<li>うるう秒自体を気にしないといけないのは仕方がない・・・</li>
</ul>
</li>
<li>JanとかJunとかJulとか似てて紛らわしいんだよ！！数字書け！！</li>
</ul>


<h2>ちなみに</h2>

<p>最新版のver1.41は来年(2017年)の1月1日のうるう秒に対応済みです。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2017, month =&gt; 1, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2017-01-01T08:59:60
</code></pre>

<p>みなさん準備は出来ていますか 😇</p>
]]></content>
  </entry>
  
</feed>
