<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2016-11-24T18:30:48+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PerlでもGoでも実行できるQuine書いた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl/"/>
    <updated>2016-04-06T10:07:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/06/ployglot-quine-of-golang-and-perl</id>
    <content type="html"><![CDATA[<p><a href="http://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/">昨日のPolyglot</a>を元にPerlでもGoでも実行できるQuine書いた。</p>

<!-- More -->


<pre><code>package main;import("fmt");var(q=`printf'package main;import("fmt");var(q%c%c%s%c/*%c);sub import{}sub var{$_%cshift%c~s!%c(.*)%c/\*!$1!gr;eval}%c__END__%c',61,96,$_,96,61,61,61,96,96,10,10;print&lt;DATA&gt;`/*=);sub import{}sub var{$_=shift=~s!`(.*)`/\*!$1!gr;eval}
__END__
*/);func main(){s:=`package main;import("fmt");var(q=%c%s%c/*=);sub import{}sub var{$_=shift=~s!%c(.*)%c/\*!$1!gr;eval}
__END__
*/);func main(){s:=%c%s%c;fmt.Printf(s,96,q,96,96,96,96,s,96)}
`;fmt.Printf(s,96,q,96,96,96,96,s,96)}
</code></pre>

<p>Perlで実行してもGoで実行しても自分自身を出力します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlとGolangで実行できるPolyglot書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/"/>
    <updated>2016-04-05T12:27:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang</id>
    <content type="html"><![CDATA[<p>Rubyの会社をPerlの会社に変えてしまおう計画。
Golangのフリをして忍び込ませれば行けるのではという話になったので、
GoでもPerlでも実行できるコードを書いてみた。</p>

<!-- More -->


<p>出来上がったのがこちら。</p>

<pre><code class="plain">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>一番のポイントは<code>var (s=0/*==);</code>の行ですね。
Perlで解釈すると正規表現置換<code>s///</code>として解釈され、<code>/*</code>が無視されます。
Goで解釈すると変数<code>s</code>への代入として解釈され、<code>/*</code>がコメントとして扱われます。</p>

<p>あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。</p>

<ul>
<li><code>package main</code> はGoでもPerlでも似たような意味で解釈されるのでそのまま</li>
<li>Goの <code>import</code>, <code>var</code> はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする</li>
<li>省略可能なセミコロンをちゃんと書く</li>
</ul>


<p>GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、
<code>import</code> だけGoでもPerlでも解釈されてしまうというという制限があります。
<code>import</code> するパッケージが一個だけなら問題ないんですが、
複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。
(Perlでは文字列結合として解釈される。Goでは<code>var</code>のあとに<code>import</code>かけないっぽいので、ここに押し込むしかない。)</p>

<pre><code class="plain">package main;
import (
  "fmt"
  . "math"
);
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu", Pi) }
</code></pre>

<p>もっと簡潔にかけないかな。</p>

<h2>追記</h2>

<p>シンタックスハイライトしてみたらわかりやすいかなと思ってやってみた。</p>

<p>Perlのシンタックスハイライト。</p>

<pre><code class="perl">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>Goのシンタックスハイライト。</p>

<pre><code class="go">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="https://golang.org/ref/spec">The Go Programming Language Specification</a></li>
<li><a href="http://d.hatena.ne.jp/sugyan/20110306/1299418878">polyglot 基礎の基礎</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを公開しました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules/"/>
    <updated>2016-03-18T22:16:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/03/18/releaes-redis-modules</id>
    <content type="html"><![CDATA[<p>以前<a href="http://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/">Redisでスコアを複数設定できるランキングを作ってみた</a>けど、
Githubの肥やしになっていてもあれなので、CPANizeしました。
あわせて、この実装のために作ったユーティリティモジュールも別モジュールとして公開しました。</p>

<ul>
<li><a href="https://metacpan.org/pod/Redis::LeaderBoardMulti">Redis::LeaderBoardMulti</a></li>
<li><a href="https://metacpan.org/pod/Redis::Script">Redis::Script</a></li>
<li><a href="https://metacpan.org/pod/Redis::Transaction">Redis::Transaction</a></li>
</ul>


<!-- More -->


<h2>Redis::LeaderBoardMulti</h2>

<p>最初の基準で順位を決められなかった場合の第二基準が欲しいというときに使うモジュールです。
インターフェースがRedis::LeaderBoard互換になるように調整したので、
前回とインターフェースがちょっと変わっています。</p>

<pre><code class="perl">se Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
# Redis::LeaderBoardに合わせて複数指定できるようになりました
$lb-&gt;set_score(
    'one' =&gt; [100, time],
    'two' =&gt; [ 50, time],
);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p>Redis::LeaderBoard互換なのでそのまま入れ替えられるはずですが、以下のような実装上の制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
<li>同順の場合の出現順

<ul>
<li>Redis::LeaderBoard は ZRANK, ZREVRANK を使い分けているので、orderパラメータによって昇順/降順が変わります</li>
<li>Redis::LaederBoardMulti は ZRANK しか使わないので、必ず昇順になります</li>
</ul>
</li>
</ul>


<p>一応 Lua Script を使わないオプションもそのまま残してありますが、特に理由がない限りデフォルト(Lua Script を使う)で使うといいと思います。
どうしてもロックの範囲が広くなってしまう場合があり、楽観的ロックでは効率が悪いケースがあるためです。</p>

<h2>Redis::Script</h2>

<p>EVALSHAを簡単に使うためのモジュールです。
EVALコマンドを使うとLua Scriptの実装ができますが、毎回毎回実行するスクリプト全体を送る必要があります。
EVALSHAコマンドはその代わりにスクリプトのSHA1ハッシュを送ることで、帯域の節約ができるというコマンドです。
しかしEVALSHAはSHA1ハッシュを事前に登録する必要があり、どのタイミングで登録を行うかが問題になってきます。</p>

<p><a href="http://redis.io/commands/eval">EVALコマンドのドキュメント</a>によると、
「EVALSHAで実行してみて <code>NOSCRIPT No matching script</code> で失敗したらEVALでやり直す」というのがおすすめらしいです。
EVALコマンドはSHA1ハッシュの登録も行ってくれるので、初回 <code>NOSCRIPT</code> になっても次回からはEVALSHAが成功します。</p>

<p>そんなに複雑なことではないのですが、毎回書くのも大変なのでモジュールとして切り出したのが Redis::Script です。
以下のようにスクリプトオブジェクトを作っておいて、パラメータを渡して実行します。</p>

<pre><code class="perl">use Redis;
use Redis::Script;
my $script = Redis::Script-&gt;new(script =&gt; "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}");
my ($key1, $key2, $arg1, $arg2) = $script-&gt;eval(Redis-&gt;new, ['key1', 'key2'], ['arg1', 'arg2']);
</code></pre>

<p><code>$script</code> が計算済みのSHA1ハッシュを保存しておいてくれるので、計算リソースの節約にもなるはずです。
(ベンチとってみたところ、スクリプトのサイズが1kBから10kBくらいにならないと効果なさそうでしたが・・・)</p>

<h2>Redis::Transaction</h2>

<p>Redisのトランザクションを簡単に行うためのモジュールです。</p>

<p>MULTI-EXECは単に実行するだけなら、MULTIとEXECで囲うだけでよいので簡単です。
例えば、 <code>foo</code> と <code>bar</code> を同時にインクリメントしたい場合、以下のようにすると実現できます。</p>

<pre><code class="perl">$redis-&gt;multi;
$redis-&gt;incr('foo');
$redis-&gt;incr('bar');
$redis-&gt;exec; # 他のクライアントからはfooとbarが全く同時にインクリメントされたように見える
</code></pre>

<p>ただ、このような素朴な実装だと、途中でネットワークが不調になった場合などに再接続処理が止まったままになる可能性があります。
例えば以下のようにトランザクションの中で例外が発生すると、以後そのコネクションを使おうとしたときにエラーになります。
コネクションの永続化をしている場合はしばらくエラーが出続けることになり問題です。</p>

<pre><code class="perl">eval {
    $redis-&gt;multi; # トランザクション開始
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
    $redis-&gt;exec;
};
$redis-&gt;ping; # 繋がらなくなる
</code></pre>

<p>Redis::Transaction はこのような問題を防ぐためのモジュールです。
トランザクションが失敗したときの後始末をよしなにやってくれるので、万が一エラーになっても安心です。</p>

<pre><code class="perl">multi_exec Redis-&gt;new, 1, sub { # 1は失敗したときのリトライ回数
    my $redis = shift;
    $redis-&gt;incr('foo');
    $redis-&gt;incr('bar');
    die "ネットワークトラブル！"
};
$redis-&gt;ping; # 繋がる！
</code></pre>

<p>WATCH-MULTI-EXECを使った楽観的ロックも扱えます。
Redisのトランザクションは楽観的ロックなので、
処理中に他のクライアントが書き換えを行った場合に失敗する可能性があります。
その場合でもリトライを行ってくれて便利です。</p>

<pre><code class="perl"># $redis-&gt;incr('mykey') をトランザクションを使って実現する
watch_multi_exec Redis-&gt;new, ['mykey'], 10, sub {
    my $redis = shift;
    return $redis-&gt;get('mykey');
}, sub {
    my ($redis, $value) = @_;
    $redis-&gt;set('mykey', $value + 1);
};
</code></pre>

<h2>まとめ</h2>

<p>Redisのトランザクション・スクリプト・ランキングを扱うPerlモジュールを紹介しました。
それぞれは小さなモジュールですが、
トラブル発生時にも問題にならないようちゃんとした実装しようとすると、
意外と考えることが多く面倒なものです(特にトランザクション周りとか)。
適当に実装してしまったこころ当たりのある人は、ぜひ試してみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redisでスコアを複数設定できるランキングを作ってみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi/"/>
    <updated>2016-02-06T02:30:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/02/06/redis-leader-board-multi</id>
    <content type="html"><![CDATA[<p>ランキングを作っているとスコアを複数設定したいことがよくあると思います。
例えば「得点が同じだったら早くその得点を出した人優先」とか「勝ち点が同じだったら得失点差が大きい方優先」とかのように、
最初の基準で順位を決められなかった場合の第二基準が欲しいみたいな場合です。</p>

<p>ランキングを作るのにはRedisのSorted Setを使うのが便利ですが、残念ながらSorted Setはひとつしかスコアを設定できません。
少し前にどうやったら実装できるかと社内チャットで話題に上ったので、試しにRedis::LeaderBoardMulti(仮名)という名前で書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/p5-Redis-LeaderBoardMulti">shogo82148/p5-Redis-LeaderBoardMulti</a></li>
</ul>


<!-- More -->


<h2>使い方</h2>

<p>メソッドの名前は<a href="http://www.songmu.jp/riji/archives/2013/06/redisleaderboar.html">Redis::LeaderBoard</a>にあわせてありますが、
スコアが複数指定できるようになった関係でちょっと変わってます。</p>

<pre><code class="perl">use Redis;
use Redis::LeaderBoard;
my $redis = Redis-&gt;new;
my $lb = Redis::LeaderBoardMulti-&gt;new(
    redis =&gt; $redis,
    key   =&gt; 'leader_board:1',
    order =&gt; ['asc', 'desc'], # asc/desc, desc as default
);
$lb-&gt;set_score('one' =&gt; 100, time); # 第二基準は時間=得点が同じだったら早くその得点を出した人優先
$lb-&gt;set_score('two' =&gt;  50, time);
my ($rank, $score, $time) = $lb-&gt;get_rank_with_score('one');
</code></pre>

<p><code>set_score</code>の第二引数以降はすべてスコアとして扱われます。(そのためRedis::LeaderBoardと互換性はない)
上の例では「得点が同じだったら早くその得点を出した人優先」になってます。</p>

<h2>制限事項</h2>

<p>実装の都合により、以下のような制限があります。</p>

<ul>
<li>スコアはすべて64bit符号付き整数です

<ul>
<li>Redis::LeaderBoardのスコアは倍精度浮動小数点型なので小数も扱えるが、Redis::LeaderBoardMultiは整数だけ</li>
</ul>
</li>
<li>Redis 2.8.9以降のみで動きます</li>
</ul>


<h2>実装の仕組み</h2>

<p>Sorted Setの同じスコアを持つメンバーは辞書順にソートされます(zaddの<a href="http://redis.io/commands/zadd#elements-with-the-same-score">同じスコアを持つ要素</a>の項を参照)。
例えば以下の様にメンバー「a」「b」「c」を追加すると、必ず「abc」の順番になることが保証されています。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "a" 0 "b" 0 "c"
(integer) 3
127.0.0.1:6379&gt; ZRANK ranking "b"
(integer) 1
</code></pre>

<p>これを利用して、メンバーの先頭にスコアをエンコードして付けておきます。
もちろんエンコードしたあとでもスコアの大小関係が保たれている必要があります。
以下はエンコード方式にビッグエンディアンの16bit整数を使った例です。
Redis 2.8.9から辞書順比較に特化したコマンド(LEXがつくやつ)が追加されているので、
ランクを求める処理は以下のように書くことができます。</p>

<pre><code class="plain">127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x02b"    (bをスコア2で追加)
(integer) 1
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x01a"    (aをスコア1で追加)
(integer) 1
127.0.0.1:6379&gt; ZLEXCOUNT ranking - "(\x00\x02"    (スコア2未満の個数=bのランク)
(integer) 1
</code></pre>

<p>さすがに16bit符号なし整数だと範囲が狭いので、実際の実装は以下のようになっています。</p>

<ul>
<li>エンコードはビッグエンディアンの64bit符号付き整数</li>
<li>負数も扱えるように下駄を履かせる

<ul>
<li>1と-1を単純にエンコードすると-1の方が大きくなってしまう</li>
<li>0x8000000000000000を足して符号なし整数の範囲で比較できるように補正</li>
</ul>
</li>
</ul>


<h2>アトミック性について</h2>

<p>この方法だとSorted Setだけでは現在のスコアを取得できないので、
スコアだけ別管理にする必要があります。
スコアの更新とランキングの更新があるので、
片方だけ更新される状況がないようにアトミック性に注意する必要があります。
更新途中の間違った結果を返すだけならすぐに復旧するのでまだマシですが、
途中でネットワーク障害が起こって不整合なデータが残ってしまうと面倒です。</p>

<p>アトミック性を確保するためのパターンをいくつか実装してみました。
<code>use_script</code>と<code>use_hash</code>で制御が可能です。</p>

<h3>トランザクションを使った方法</h3>

<p>Redisには<a href="http://redis.io/topics/transactions">トランザクション</a>の仕組みがあるのでこれを使った方法です。
<code>use_script=&gt;0</code>が指定されるとこの方法で更新を行います。</p>

<pre><code class="plain">127.0.0.1:6379&gt; WATCH ranking:a   (他のクライアントが更新を行っていないか監視)
OK
127.0.0.1:6379&gt; GET ranking:a   (ranking:aに入っている現在のスコアを取得)
"\x00\x01"
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; ZREM ranking "\x00\x01a"
QUEUED
127.0.0.1:6379&gt; ZADD ranking 0 "\x00\x03a"
QUEUED
127.0.0.1:6379&gt; SET ranking:a "\x00\x03"
QUEUED
127.0.0.1:6379&gt; EXEC   (スコアの更新とランキングの更新をアトミックに行う)
1) (integer) 1
2) (integer) 1
3) OK
</code></pre>

<p>Redisのトランザクションは楽観的ロックなので、他のクライアントがスコアを更新していると失敗する場合があります。
失敗した場合はリトライが必要です。
(この機構、いろいろと注意点があって毎回実装するのはつらすぎるので、別モジュールとして分離したいけど、いい名前とインターフェース募集中)</p>

<p><code>use_hash=&gt;1</code>が指定されていると、スコアの記録にHashを使います。
「Hashの特定のキーの更新をWATCHする」という命令はないため、ランキング全体を<code>WATCH</code>で監視します。
(<code>use_hash=&gt;0</code>の場合、そのメンバのスコアだけ監視する)</p>

<h3>Luaスクリプトを使った方法</h3>

<p>RedisはLuaスクリプトを実行する機能があります。
Luaスクリプト実行中は他の命令の実行をブロックするので、アトミック性が確保されます。</p>

<pre><code class="lua">local s=redis.call('GET', 'ranking:a')
if s then
  redis.call('ZREM', 'ranking', s..'a')
end
redis.call('ZADD', 'ranking', 0, '\x00\x03a')
redis.call('SET', 'ranking:a', '\x00\x03')
</code></pre>

<p>Luaスクリプトを実行するには<code>EVAL</code>と<code>EVALSHA</code>の二種類のコマンドがあります。
<code>EVALSHA</code>は転送量を抑えられて便利ですが、事前に<code>SCRIPT LOAD</code>で使うスクリプトを登録しておく必要があります。
(ココらへんも別モジュールに分離したいけど、いい名前とインターフェース募集中)
<code>use_evalsha</code>オプションでどちらを使うか制御可能です。</p>

<p>ちなみに<code>EVAL</code>で実行したスクリプトも<a href="http://redis.io/commands/eval#script-cache-semantics">永遠にキャッシュされる</a>らしいです。
上の例はわかりやすいようにキー名や値を直接埋め込んでいますが、同じことをしようとLuaスクリプトの動的生成なんてすると死にます。
スクリプト内で<code>KEYS</code>や<code>ARGV</code>を使うと<code>EVAL</code>時にパラメータを渡せるようになるので、これを活用しましょう。</p>

<h3>諦める</h3>

<p><a href="https://metacpan.org/pod/Redis::LeaderBoard">Redis::LeaderBoard</a>の実装を見て気がついたんですが、
<code>get_rank</code>の実装は「スコアの取得」「スコアに対応するランクの取得」がアトミックでないため、
以下の条件を満たすと実際のランクより1大きい結果を返します。</p>

<ul>
<li>同じメンバーのスコア更新とランク取得が同時に行われる</li>
<li>ランクが上がるようにスコアが更新される</li>
</ul>


<p>確かに厳密性は欠けますがたかだか1結果が変わるだけですし、
そもそも更新と取得が同時に行われないようにモジュールを使う側が排他制御するべきですね。
こういうケースでは諦めるというのも一つの手かなと思いました。
もちろんデータの整合性が壊れる場合は頑張ってアトミック性を確保するべきでしょう。</p>

<h2>まとめ</h2>

<ul>
<li>Redisでランキングをつくる際に、スコアを複数設定する方法を紹介しました</li>
<li>アトミック性を確保する方法を紹介しました

<ul>
<li>トランザクションを使った方法</li>
<li>Luaスクリプトを使った方法</li>
<li>諦める</li>
</ul>
</li>
</ul>


<p>もうちょっとドキュメントを整備したらCPANにあげてみますかね。
トランザクション管理・Luaスクリプト管理も分離したい(いい名前を思いついたら)。
「こんな名前がいい！」「こんなインターフェースがいい！」等あればコメントください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis::Fast 0.17 をリリースしました]]></title>
    <link href="https://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released/"/>
    <updated>2016-01-23T16:20:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/01/23/redis-fast-0-dot-17-released</id>
    <content type="html"><![CDATA[<p><a href="https://metacpan.org/release/SHOGO/Redis-Fast-0.17">Redis::Fast 0.17</a> をリリースしました。
主な変更点は以下のとおりです。</p>

<ul>
<li>I/Oの待ち合わせに使うシステムコールをselect(2)からpoll(2)に変更</li>
<li>hiredisをv0.13.3にアップデート</li>
</ul>


<!-- More -->


<p>macでテストが終わらない問題がありましたが、この変更によって修正されています。</p>

<p>hiredisは<a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man2/connect.2.html">connect(2)</a>をnonblokingモードで呼び出しています。
nonblockingなので接続が未完了であってもすぐに制御を返し、errnoにEINPROGRESSが設定されます。
この場合、manにあるようにselect(2)で書き込み可能になるのを待つことで、接続完了を検知できます。</p>

<blockquote><p>select(2) で書き込み可能になった後に、 getsockopt(2) を使って SOL_SOCKET レベルで SO_ERROR オプションを読み出すこ とにより、 connect() が成功したか、失敗したかを判断できる。</p></blockquote>

<p>linuxの場合はこれで上手く動くのですが、macだと何故かselect(2)が永遠に制御を返さない場合があるようです。
接続先が存在しない場合に起こるのですが、制御を返す場合もあるので謎です。</p>

<p>いろいろ調べてはみたのですがselect(2)だとどうやっても上手く動かなかったので、poll(2)に変更しました。
poll(2)変更版でテストしてみると、接続先が存在しない場合にPOLLOUTを返すケースとPOLLHUPを返すケースがあるようです。
どうやらPOLLHUPにあたるイベントが来た時の挙動がlinuxとmacとで違うらしい？
謎です。</p>
]]></content>
  </entry>
  
</feed>
