<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2016-06-09T12:29:12+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PerlとGolangで実行できるPolyglot書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/"/>
    <updated>2016-04-05T12:27:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang</id>
    <content type="html"><![CDATA[<p>Rubyの会社をPerlの会社に変えてしまおう計画。
Golangのフリをして忍び込ませれば行けるのではという話になったので、
GoでもPerlでも実行できるコードを書いてみた。</p>

<!-- More -->


<p>出来上がったのがこちら。</p>

<p><code>plain
package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></p>

<p>一番のポイントは<code>var (s=0/*==);</code>の行ですね。
Perlで解釈すると正規表現置換<code>s///</code>として解釈され、<code>/*</code>が無視されます。
Goで解釈すると変数<code>s</code>への代入として解釈され、<code>/*</code>がコメントとして扱われます。</p>

<p>あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。</p>

<ul>
<li><code>package main</code> はGoでもPerlでも似たような意味で解釈されるのでそのまま</li>
<li>Goの <code>import</code>, <code>var</code> はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする</li>
<li>省略可能なセミコロンをちゃんと書く</li>
</ul>


<p>GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、
<code>import</code> だけGoでもPerlでも解釈されてしまうというという制限があります。
<code>import</code> するパッケージが一個だけなら問題ないんですが、
複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。
(Perlでは文字列結合として解釈される。Goでは<code>var</code>のあとに<code>import</code>かけないっぽいので、ここに押し込むしかない。)</p>

<p><code>plain
package main;
import (
  "fmt"
  . "math"
);
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu", Pi) }
</code></p>

<p>もっと簡潔にかけないかな。</p>

<h2>追記</h2>

<p>シンタックスハイライトしてみたらわかりやすいかなと思ってやってみた。</p>

<p>Perlのシンタックスハイライト。</p>

<p><code>perl
package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></p>

<p>Goのシンタックスハイライト。</p>

<p><code>go
package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></p>

<h2>参考</h2>

<ul>
<li><a href="https://golang.org/ref/spec">The Go Programming Language Specification</a></li>
<li><a href="http://d.hatena.ne.jp/sugyan/20110306/1299418878">polyglot 基礎の基礎</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MeCabのGolangバインディングを書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/02/11/golang-mecab-binding/"/>
    <updated>2016-02-11T19:32:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/02/11/golang-mecab-binding</id>
    <content type="html"><![CDATA[<p>Golangから<a href="http://taku910.github.io/mecab/">MeCab</a>を呼び出すライブラリ探せばあるにはあるのですが、
なんだかどれもメモリ管理がちょっと怪しいんですよね・・・。</p>

<ul>
<li><a href="http://yukihir0.hatenablog.jp/entry/2015/01/18/164446">GolangでMeCabを使う。</a>

<ul>
<li><a href="https://github.com/yukihir0/mecab-go">yukihir0/mecab-go</a></li>
</ul>
</li>
<li><a href="http://qiita.com/rerofumi/items/2bb1e49b20f2175ecaac">Go言語から mecab を使う - Qiita</a>

<ul>
<li><a href="https://bitbucket.org/rerofumi/mecab">rerofumi/mecab</a></li>
</ul>
</li>
<li><a href="http://d.hatena.ne.jp/gtaka555/20091116/p2">Go で Mecab を使ってみた</a></li>
</ul>


<p>メモリ管理は<a href="https://github.com/bluele/mecab-golang">bluele/mecab-golang</a>が一番しっかりしているっぽいですが、
libmecabの一番高機能だけど面倒な使い方しか対応していなくて、ちょっとカジュアルに遊ぶにはつらい。</p>

<p>というわけで、カジュアルな用途から高度な使い方まで対応したWrapperを書いてみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-mecab">shogo82148/go-mecab</a></li>
</ul>


<!-- More -->


<h2>使い方</h2>

<p>READMEと<a href="https://godoc.org/github.com/shogo82148/go-mecab#pkg-examples">godocのexamples</a>からのコピペになってしまいますが、
簡単に使い方の紹介です。</p>

<h3>インストール</h3>

<p><code>go get</code>で取ってくることはできますが、事前にlibmecabとリンクするための設定が必要です。</p>

<p><code>bash
$ export CGO_LDFLAGS="-L/path/to/lib -lmecab -lstdc++"
$ export CGO_CFLAGS="-I/path/to/include"
$ go get github.com/shogo82148/go-mecab
</code></p>

<p><code>mecab</code>コマンドと一緒に<code>mecab-config</code>がインストールされているはずなので、
それを使うのが楽でしょう。</p>

<p><code>bash
$ export CGO_LDFLAGS="`mecab-config --libs`"
$ export CGO_FLAGS="`mecab-config --inc-dir`"
$ go get github.com/shogo82148/go-mecab
</code></p>

<p>MeCabはデフォルトで<code>/usr/local/</code>以下に入るので、他の実装では決め打ちしている例が多いですが、
100%とは言い切れないので面倒ですが都度指定にしてあります。
cgoはpkg-configに対応しているで、MeCab側が対応してくれると環境変数の設定が不要になってもっと楽なんですけどね。</p>

<h3>カジュアルに使う</h3>

<p><code>Parse</code>を使うと<code>mecab</code>コマンドと同等の結果を文字列として受け取れます。</p>

<p>``` go
tagger, err := mecab.New(map[string]string{})
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
defer tagger.Destroy()</p>

<p>result, err := tagger.Parse("こんにちは世界")
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
fmt.Println(result)
```</p>

<p>オプションの渡し方ですが、いろいろ考えた結果<code>map</code>で渡すようにしてみました。
(Perlの<a href="https://metacpan.org/release/Text-MeCab">Text::MeCab</a>からのインスパイア)
例えば、<code>mecab.New(map[string]string{"output-format-type": "wakati"})</code>のようにすると、分かち書きで出力されます。</p>

<h3>ノードの詳細情報にアクセスする</h3>

<p><code>ParseToNode</code>を使うと表層表現と品詞が最初から分かれた形で取得できます。
生起コストのようなより詳細な情報も取れます。</p>

<p>``` go
tagger, err := mecab.New(map[string]string{})
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
defer tagger.Destroy()</p>

<p>// XXX: avoid GC problem with MeCab 0.996 (see https://github.com/taku910/mecab/pull/24)
tagger.Parse("")</p>

<p>node, err := tagger.ParseToNode("こんにちは世界")
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}</p>

<p>for ; node != (mecab.Node{}); node = node.Next() {</p>

<pre><code>fmt.Printf("%s\t%s\n", node.Surface(), node.Feature())
</code></pre>

<p>}
```</p>

<p>以前紹介した<a href="http://shogo82148.github.io/blog/2015/12/20/mecab-in-python3-final/">MeCabをPython3から使う(続報)</a>の件、
実はPythonに限ったことではなく、公式で提供されている全ての言語バインディングで発生します。
(例えばRubyでも発生するっぽい: <a href="http://qiita.com/Salinger/items/3448d481b5b1e6cd2efb">Ruby + MeCab で Segmentation fault が発生した場合の対処</a>)
Pythonが参照カウント方式のGCを採用しているので、たまたま発見されるのが早かったというだけですね(Rubyだとメモリを圧迫するまで落ちないらしい)。</p>

<p>そして、公式で提供されているバインディングを参考に書いたので、今回のGo版でも発生します。
<a href="https://github.com/taku910/mecab/pull/24">MeCab側で対応してもらった</a>のでわざわざバインディング側で対応することもないだろうとの考えから、go-mecabでは特に対策をとっていません。
MeCab 0.996以下を使っている方は注意してください。(残念ながら0.996がまだ最新リリースだけど・・・)</p>

<h3>Modelを共有する</h3>

<p><a href="http://taku910.github.io/mecab/libmecab.html">MeCab ライブラリ</a>で紹介されている、マルチスレッド環境の場合での使い方にも対応しています。</p>

<p>``` go
model, err := mecab.NewModel(map[string]string{})
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
defer model.Destroy()</p>

<p>tagger, err := model.NewMeCab()
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
defer tagger.Destroy()</p>

<p>lattice, err := mecab.NewLattice()
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
defer lattice.Destroy()</p>

<p>lattice.SetSentence("こんにちは世界")
err = tagger.ParseLattice(lattice)
if err != nil {</p>

<pre><code>panic(err)
</code></pre>

<p>}
fmt.Println(lattice.String())
```</p>

<p>複数のゴルーチンから<code>model</code>や<code>tagger</code>を共有できると思います。<code>lattice</code>だけはゴルーチン毎に生成してください。
(へいれつへーこーしょりとかよくわかってないですが、スレッドセーフならゴルーチンセーフという認識であってますよね？)
メモリ効率もいいのでは(未検証なので誰か確かめて・・・)。</p>

<h2>GoからCへ文字列を渡す方法について</h2>

<h3>一般的な方法</h3>

<p>GoからCへ文字列を渡すには、Goの文字列を<code>C.CString</code>を使ってCの文字列に変換する必要があります。</p>

<p>``` go
cstring := C.CString(gostring)
defer C.free(unsafe.Pointer(cstring))</p>

<p>C.some_useful_function(cstring)
```</p>

<p>ここで注意が必要なのは<code>C.CString</code>の戻り値はGoのガーベージコレクションの対象から外れるということです。
C側での使用状況をGoのランタイムが把握しきれないからですね。
<code>C.free</code>を使って明示的に開放してあげないとメモリーリークになります。
巷にあふれているMeCabバインディングはここがちょっと甘いものがほとんどでした。</p>

<h3>黒魔術を使う</h3>

<p>別に<code>C.CString</code>でも十分だとは思ったのですが、
<a href="http://qiita.com/mattn/items/176459728ff4f854b165">golang で string を []byte にキャストしてもメモリコピーが走らない方法を考えてみる</a>を見て、つい魔が差してしまいました。
Goの<code>string</code>をメモリーコピーを避けて<code>[]byte</code>にできるのなら、Cの文字列型(<code>*C.char</code>)でも同じことができるはず・・・！</p>

<p><code>go
cstring := *(**C.char)(unsafe.Pointer(&amp;gostring))
C.some_useful_function2(cstring, len(gostring))
</code></p>

<p>通常C言語の文字列は末尾に<code>'\0'</code>が番兵としてついており、<code>C.CString</code>はそこら辺の事情を考慮してくれます。
しかし、この方法は番兵がいないため、文字列の長さを別途渡してあげる必要があります。
幸いMeCabは文字列長さを明示するインターフェースを備えているので、そちらを使えばOKでした。</p>

<p>Goの<code>string</code>はもちろんGCの対象なので、GCには要注意です。
関数内で閉じた状態にするのが無難ですね。
また、空文字が渡されるとヌルポで死んでしまうようなので、そこにも注意しましょう。</p>

<h2>まとめ</h2>

<ul>
<li>カジュアルな用途から高度な使い方まで対応したMeCabのWrapperを書いてみました

<ul>
<li><a href="https://github.com/shogo82148/go-mecab">shogo82148/go-mecab</a></li>
</ul>
</li>
<li>MeCab 0.996 と一緒に使う場合はGCに注意しましょう</li>
<li>GoからCへの文字列の渡し方を紹介しました

<ul>
<li><code>C.CString</code>を使った方法</li>
<li><code>unsafe.Ponter</code>を使った方法</li>
</ul>
</li>
</ul>


<p>ピンポーン <strong>unsafe をご使用になる時は、用法・用量を守り正しくお使い下さい。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go言語でGraceful Restartをするときに取りこぼしを少なくする]]></title>
    <link href="https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd/"/>
    <updated>2015-11-23T20:51:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd</id>
    <content type="html"><![CDATA[<p>少し前に<a href="https://github.com/kazuho/Starlet">Starlet</a>にGraceful Restartが時たま上手く動かない問題を修正する<a href="https://github.com/kazuho/Starlet/pull/21">pullreq</a>を投げました。
原因は割り込みハンドラ内でexitを呼んでいたからでした。
「割り込みハンドラ内ではフラグを建てるだけ」
「メインのプログラム内でそのフラグを見て分岐する」という原則があるのですが、それを守るのは難しいということですね。
(しかし新たな問題を産んでしまい<a href="https://github.com/kazuho/Starlet/pull/23">revertされてしまいましたが・・・</a>
まあ修正後のコードも考え方は一緒です。割り込みホント難しい・・・)</p>

<p>このpullreqを取り込んでもらうときに再現実験をやってみたのですが、
Goでもちゃんと動くのかな？と気になったので
<a href="http://shogo82148.github.io/blog/2015/05/03/golang-graceful-restart/">Go言語でGraceful Restartをする</a>で紹介した
プログラムに同じテストをやってみました。</p>

<!-- More -->


<h2>mannersでテストしてみる</h2>

<p>前回の記事では<a href="https://github.com/braintree/manners">manners</a>と<a href="https://github.com/lestrrat/go-server-starter">go-server-starter</a>の
組み合わせが良さそうとの結論になったので、この組み合わせでテストしてみます。
以下テストに使用したコードです。
(今回の内容とは直接関係は無いですが、go-server-starterに変更が入ってFallbackのやり方が前回から少し変わってます)</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>    "fmt"
    "log"
    "net"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/braintree/manners"
    "github.com/lestrrat/go-server-starter/listener"
</code></pre>

<p>)</p>

<p>var now = time.Now()</p>

<p>func main() {</p>

<pre><code>    log.Printf("start pid %d\n", os.Getpid())

    signal_chan := make(chan os.Signal)
    signal.Notify(signal_chan, syscall.SIGTERM)
    go func() {
            for {
                    s := &lt;-signal_chan
                    if s == syscall.SIGTERM {
                            log.Printf("SIGTERM!!!!\n")
                            manners.Close()
                    }
            }
    }()

    listeners, err := listener.ListenAll()
    if err != nil &amp;&amp; err != listener.ErrNoListeningTarget {
            panic(err)
    }
    var l net.Listener
    if err == listener.ErrNoListeningTarget {
            // Fallback if not running under Server::Starter
            l, err = net.Listen("tcp", ":8080")
            if err != nil {
                    panic("Failed to listen to port 8080")
            }
    } else {
            l = listeners[0]
    }

    manners.Serve(l, newHandler())
</code></pre>

<p>}</p>

<p>func newHandler() http.Handler {</p>

<pre><code>    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintf(
                    w,
                    "from pid %d.\n",
                    os.Getpid(),
            )
    })
    return mux
</code></pre>

<p>}
```</p>

<p>1秒毎にgraceful restartを行いながら負荷をかけます。
以下のコマンドを別々のターミナルから実行します。
<code>go run main.go</code>だと自分で書いたプログラムがシグナルを受け取れなくなってしまうので、
<code>go build main.go</code>とコンパイルしてから実行するところがポイントです。</p>

<p><code>bash
$ start_server --port 8080 --pid app.pid -- ./main
$ while true; do kill -HUP `cat app.pid`; sleep 1; done
$ ab -r -n 1000000 -c 10 http://localhost:8080/
</code></p>

<p><a href="https://gist.github.com/shogo82148/a1524f31292202ec34f3#file-manners">mannersを使った場合の実験結果</a>へのリンクを貼っておきます。
「Failed requests:        122」となっており、残念ながら取りこぼしが発生してしまいました。
負荷をかけた時間は72.437秒なので、70回ほどリスタートをかけたことになります。
github-flowを採用しているようなところだと毎日数回デプロイをするということも珍しくないので、
1〜2ヶ月も運用していれば一度くらいはこの現象に遭遇することになります(秒間1万リクエストさばく必要のあるようなサービスの場合ですが)。
ちょっと気になりますね。</p>

<h2>自分で書いてみた</h2>

<p>mannersの改造、難しそうだったので、自分で書いてみました。</p>

<ul>
<li>https://github.com/shogo82148/go-gracedown</li>
</ul>


<p>mannersと全く同じインタフェースなので、s/manners/gracedown/するだけです。
これを使って実験してみた結果がこちら https://gist.github.com/shogo82148/a1524f31292202ec34f3#file-gracedown
「Failed requests:        0」やったね！</p>

<h2>その他メモ</h2>

<p>これ書くのに色々しらべたのでメモとして残しておきます。</p>

<h3>acceptの直後にcloseされた場合の挙動について</h3>

<p>Starletで起こっていた不具合の原因は、
acceptから処理が帰ってきてからcanExitフラグを落とすまでにわずかな期間があるのが問題でした。
この期間にシグナルを受け取ると間違えてサーバを終了させてしまいます。
GoでもacceptしてからステートがStateNewになるまでの間に若干の時間差があるので、
ここが問題にならないか少し気になっていました。</p>

<p>net/httpの処理を追ってみると、acceptとStateNewは<code>Serve(net.Listener)</code>を実行したのと同じgoroutineで実行されているようです。
したがって、サーバシャットダウンの判定も<code>Serve(net.Listener)</code>と同じgoroutineで行えば、
誤ってacceptしてからステートがStateNewになるまでの間にサーバをシャットダウンしてしまうことは防げるということがわかりました。</p>

<h3>Acceptがブロックしているのを解除する方法について</h3>

<p><a href="http://qiita.com/hiratara/items/0f0b6103a0dc9280cea9">UnixListener.Closeでソケットファイルが消えて困っている</a> という記事に</p>

<blockquote><p>POSIX では Close() を呼んだからといって Accept() が制御を戻してくれる保証はないといことでしょうか。</p></blockquote>

<p>という一文が書いてありました。</p>

<p>これについて実際はどうなんだろうと調べてみたところ<a href="net.Listener">https://golang.org/pkg/net/#Listener</a>のコメントに</p>

<blockquote><p>Close closes the listener.
Any blocked Accept operations will be unblocked and return errors.</p></blockquote>

<p>とありました。
このコメントを読む限りGo言語では「<code>Close()</code> を呼んだら<code>Accept()</code>が制御を戻す」と考えて良さそうです。
POSIXでどう規定されているかまでは調査しきれていませんが、
たとえどう規定されていようとも互換性を保つために裏で色々やってくれていると信じています。</p>

<p>この記事の主題である「UnixListener.Closeでソケットファイルが消えて困っている」件についても調べてはみたのですが、
結論は出ませんでした・・・。
たしかにソケットファイルは使い終わったらunlinkすることが推奨されているということがわかったくらいです。
nameが「@」で始まっていると「abstract socket address」と見なされて削除されなくなるから、「@」をテキトウにつけるとか・・・？</p>

<h3>keep-aliveの挙動について</h3>

<p>mannersはKeep-Aliveなコネクションがあった場合でも、それがIdle状態であればシャットダウンしてしまいます。
それに対してgo-gracedownは全部のコネクションがClosedになるまでまちます。
終了処理に入った段階でKeep-Aliveは無効にしているので、
go-gracedown側で特に操作しなくてもnet/httpがそのうちクローズしてくれるだろうとの考えからです。</p>

<p>Keep-Aliveはクライアントからリクエストがないと切断できない(レスポンスに「Connection: Close」ヘッダを含める必要があるため)ので
リクエストがないと永遠にシャットダウンできません。
それでは困るので一応タイムアウトも入れてあります。</p>

<p>この挙動のおかげで<a href="https://github.com/rakyll/boom">boom</a>(http benchで検索したら一番上にきた)でのベンチでも
<a href="https://gist.github.com/shogo82148/a1524f31292202ec34f3#file-gracedown-boom">エラー無しで処理できています</a>。
ちなみにApache Benchでも-kオプションでKeep-Aliveを有効にできるのですが、
HTTP/1.0だと「Connection: Close」を送る方法が使えないので、<a href="https://gist.github.com/shogo82148/a1524f31292202ec34f3#file-gracedown-keep-alive">残念ながらエラーが出てしまいました</a>。</p>

<h2>まとめ</h2>

<ul>
<li>実験の結果<a href="https://github.com/braintree/manners">manners</a>はときどきGraceful Shutdownに失敗する場合があることがわかった</li>
<li><a href="https://github.com/shogo82148/go-gracedown">go-gracedown</a>というのを書いてみた

<ul>
<li>今回行った再現実験ではすべてのリクエストを正常に処理できました</li>
</ul>
</li>
<li>Graceful Restartむずかしい</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goオールスターズで登壇してきました]]></title>
    <link href="https://shogo82148.github.io/blog/2015/10/14/go-all-stars/"/>
    <updated>2015-10-14T08:11:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/10/14/go-all-stars</id>
    <content type="html"><![CDATA[<p>先週の日曜日に登壇してきました。</p>

<p><iframe src="https://www.slideshare.net/slideshow/embed_code/key/gC0o0V8Vx7tI9z" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/shogo82148/go-go-53787565" title="過去に自作したGoプロダクトの紹介 - Goオールスターズ" target="_blank">過去に自作したGoプロダクトの紹介 - Goオールスターズ</a> </strong> from <strong><a target="_blank" href="http://www.slideshare.net/shogo82148">Shogo Ichinose</a></strong> </div>

</p>

<ul>
<li><a href="http://www.slideshare.net/shogo82148/go-go-53787565">過去に自作したGoプロダクトの紹介 - Goオールスタース</a></li>
</ul>


<!-- More -->


<p>発表の10日くらい前にsongmuさんがKAYACのIRCに現われオールスターを募集に来てくださったものの、
弊社スターの都合がつかないため僕が代わりに発表してきました。</p>

<p>KAYACではGoプロダクトたくさん動いていますが説明は作者にお任せしたほうがいいかなと思い、
自作のGoプロダクトをメインに発表してきました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-rgba4444">go-rgba4444</a></li>
<li><a href="https://github.com/shogo82148/androidbinary">androidbinary</a> - <a href="http://shogo82148.github.io/blog/2014/05/07/androidbinary/">Androidのバイナリファイルを解析するgoのライブラリ</a></li>
<li><a href="https://github.com/shogo82148/go-sql-proxy">go-sql-proxy</a> - <a href="http://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy/">Go言語でSQLのトレースをする</a></li>
<li><a href="https://github.com/shogo82148/go-dithering">go-dithering</a> - <a href="http://shogo82148.github.io/blog/2015/04/25/quantize-image-in-golang/">Go言語で画像の減色を行う</a></li>
<li><a href="https://github.com/shogo82148/go-prove">go-prove</a>/<a href="https://github.com/shogo82148/go-tap">go-tap</a> - <a href="http://shogo82148.github.io/blog/2015/09/19/faster-perl-test-with-go-lang/">Go言語でPerlのテストを早くする</a></li>
<li><a href="https://github.com/shogo82148/go-webtail">go-webtail</a>/<a href="https://github.com/shogo82148/go-tail">go-webtail</a> - <a href="http://shogo82148.github.io/blog/2015/06/21/go-webtail/">Go-webtailってのを書いた</a></li>
</ul>


<p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr">go-prove、CPANに上げればいいんじゃない？w <a href="https://twitter.com/hashtag/eventdots?src=hash">#eventdots</a></p>&mdash; songmu (@songmu) <a href="https://twitter.com/songmu/status/653100524296736768">October 11, 2015</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>Perl Archive Network とはいったい・・・</p>

<p>KAYACではいろんなGoプロダクトが動いているのでこちらもどうぞ。</p>

<ul>
<li><a href="https://github.com/kayac/go-katsubushi">go-katsubushi</a> snowﬂake-likeなIDジェネレータ</li>
<li><a href="https://github.com/fujiwara/stretcher">stretcher</a> Consul/Surfと連携したデプロイツール</li>
<li><a href="https://github.com/fujiwara/Rin">rin</a> AWS-S3に出力されたログをRedshiftへインポートするツール</li>
<li><a href="https://github.com/acidlemon/mirage">mirage</a> Dockerを使ったテスト用環境構築</li>
<li><a href="https://github.com/kayac/alphawing">alphawing</a> Android/iOSアプリの社内配信ツール</li>
</ul>


<p>スライドにちょこちょこ修正いれててGopherくん人形もらうの忘れてたけどもらっておけばよかった。</p>

<p>他の人の発表はこちら。</p>

<ul>
<li><a href="http://eventdots.jp/event/571126">Goオールスターズ</a></li>
<li><a href="http://togetter.com/li/885585">GoオールスターズToggetterまとめ</a></li>
<li><a href="http://www.songmu.jp/riji/entry/2015-10-12-go-all-stars.html">Goオールスターズで登壇してきました - おそらくはそれさえも平凡な日々</a></li>
<li><a href="http://ymotongpoo.hatenablog.com/entry/2015/10/13/104247">Goオールスターズでpackage managementについて話してきました - YAMAGUCHI::weblog</a></li>
<li><a href="http://www.slideshare.net/takuyaueda967/go-53785408">Goだけでモバイルアプリを作ろう</a></li>
<li><a href="http://bokko.hatenablog.com/entry/2015/10/12/151641">Goオールスターズ - 考える人、コードを書く人</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go言語でSQLのトレースをする]]></title>
    <link href="https://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy/"/>
    <updated>2015-05-13T01:22:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy</id>
    <content type="html"><![CDATA[<p>ぴっぴ先輩が「Go言語で発行したクエリを確認したい」って言ってて、
「MySQL使っているならGeneral Logを吐けばよいのでは？」と返したんだけども、
もっと汎用的な方法はないものかと考えてみました。</p>

<!-- More -->


<p>Golangの <code>database/sql</code> はどんなDBでも対応できるよう、ドライバを自由に入れ替えることができます。
ドライバは単に<code>database/sql/driver</code>にあるインターフェースを満たしている何かなので、
ユーザが自由に作ることができるし、<code>interface</code>を経由して直接呼び出すことも可能です。
この仕組を使って、別のドライバにそのまま渡すプロキシを作れば、ログを吐けるのでは？ということでやってみました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-sql-proxy">go-sql-proxy</a></li>
</ul>


<h2>使い方</h2>

<p>まず最初にgo-sql-proxyをドライバとして登録します。</p>

<p>``` go
hooks := &amp;proxy.Hooks{</p>

<pre><code>// Hook functions here(Open, Exec, Query, etc.)
</code></pre>

<p>}
sql.Register("new-proxy-name", proxy.NewProxy(&amp;another.Driver{}, hooks))
```</p>

<p>あとは登録したドライバと使って新しいDBハンドラを開くだけです。</p>

<p><code>go
db, err := sql.Open("new-proxy-name", dataSourceName)
</code></p>

<p>このハンドラを使ってクエリ実行を行うと、Hooksで登録した関数が呼び出されます。
元のドライバを直接使った場合と同じように振る舞うので、既存のコードを一切変えること無くHookを差し込めて便利！</p>

<h2>トレーサの例</h2>

<p>簡単なトレーサを書いてみるとこんな感じ。
発行したSQLのクエリをログに吐き出します。</p>

<p>``` go
package proxy</p>

<p>import (</p>

<pre><code>"database/sql"
"database/sql/driver"
"log"

"github.com/mattn/go-sqlite3"
"github.com/shogo82148/txmanager"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>sql.Register("sqlite3-proxy", NewProxy(&amp;sqlite3.SQLiteDriver{}, &amp;Hooks{
    Open: func(conn *Conn) error {
        log.Println("Open")
        return nil
    },
    Exec: func(stmt *Stmt, args []driver.Value, result driver.Result) error {
        log.Printf("Exec: %s; args = %v\n", stmt.QueryString, args)
        return nil
    },
    Query: func(stmt *Stmt, args []driver.Value, rows driver.Rows) error {
        log.Printf("Query: %s; args = %v\n", stmt.QueryString, args)
        return nil
    },
    Begin: func(conn *Conn) error {
        log.Println("Begin")
        return nil
    },
    Commit: func(tx *Tx) error {
        log.Println("Commit")
        return nil
    },
    Rollback: func(tx *Tx) error {
        log.Println("Rollback")
        return nil
    },
}))

db, err := sql.Open("sqlite3-proxy", ":memory:")
if err != nil {
    log.Fatalf("Open filed: %v", err)
}
defer db.Close()

_, err = db.Exec(
    "CREATE TABLE t1 (id INTEGER PRIMARY KEY)",
)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>}
```</p>

<h2>おまけ機能</h2>

<p><code>proxy.NewTraceProxy</code> を使うと上記のコードと同様のプロキシを簡単につくれます。
<code>db.Exec</code>, <code>db.Query</code> 等の呼び出しもとを報告するという便利機能付き。
ただ、<code>logger.Output(6, "Begin")</code> みたいな感じで「6個スタックトレースをさかのぼってログに表示」という実装をしているので、
<code>database/sql</code>のアップデートと共にすぐに壊れそう。(<code>database/sql</code>で何回関数呼び出しがあったかに強く依存している)
一応、Go1.1から1.4までで同じ結果を返すことは確認はしてるんだけど、将来のことまではちょっと分からない・・・。
あんまり信用はしないほうがいいかも。</p>

<p>こういう情報を知りたい場合どうするのがいいんだろうね。
この前作った<a href="http://shogo82148.github.io/blog/2015/05/09/go-txmanager/">txmanger</a>のレベルでプロキシを作ったほうがいいのかなあ。</p>
]]></content>
  </entry>
  
</feed>
