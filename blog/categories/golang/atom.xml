<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-02-23T18:37:45+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go言語でコンパイル時フィボナッチ数列計算]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/19/golang-compile-time-fib/"/>
    <updated>2017-02-19T09:06:05+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/19/golang-compile-time-fib</id>
    <content type="html"><![CDATA[<p><a href="http://postd.cc/fibonacci/">整数の公式でフィボナッチ数列を求める</a>という記事を読んで、
「これコンパイル時ならGoでも簡単に計算できるのでは？」と思いやってみたメモ。</p>

<!-- More -->


<h2>背景</h2>

<p>みんな大好きフィボナッチ数列(要出典)。
漸化式で定義されているため、再帰やループを使って書くことが多いと思いますが、
閉じた式で書くことが知られています。
ただし、この一般式には無理数の演算が入るので、コンピュータで厳密に扱うことはできません。
ところが、さきほど紹介した記事で紹介された方法を使うと、整数の演算のみで実現できるそうです。</p>

<p>原理などはネタ元の記事を参照してもらうとして、
Python3では以下のように書けるらしいです。</p>

<pre><code class="python">def fib(n):
    return (4 &lt;&lt; n*(3+n)) // ((4 &lt;&lt; 2*n) - (2 &lt;&lt; n) - 1) &amp; ((2 &lt;&lt; n) - 1)
</code></pre>

<p>ある程度大きなフィボナッチ数を求める場合、
計算途中の値が非常に大きくなるため、多倍長整数が必要となります。
Python3は多倍長整数に組み込みで対応していますが、
Goでは<a href="https://golang.org/pkg/math/big/">math/bigパッケージ</a>を利用する必要があります。</p>

<p>なんか面倒だなGolangと思っていたのですが、
<a href="http://qiita.com/sonatard/items/464a9d45c689386edfe1">Better C - Go言語と整数 #golang</a>を読んで、
「Goの定数には型がない(場合がある)」「任意の精度で計算してくれる」ということを知り、
「つまりコンパイル時に定数として計算すれば楽にいけるのでは！！」と考えたわけです。</p>

<h2>結果</h2>

<p>ちょっと複雑な式ですが、個々の演算自体はPython3もGoも変わらないので、
翻訳は簡単ですね。</p>

<pre><code class="go">package main

import "fmt"

const Fib0 = 1 // 0だけはうまくいかない

const (
    _    = (4 &lt;&lt; (iota * (3 + iota))) / ((4 &lt;&lt; (2 * iota)) - (2 &lt;&lt; iota) - 1) &amp; ((2 &lt;&lt; iota) - 1)
    Fib1
    Fib2
    Fib3
    Fib4
    Fib5
    Fib6
    Fib7
    Fib8
    Fib9
    Fib10
    Fib11
    Fib12
    Fib13
    Fib14
    Fib15
    Fib16
    Fib17
    Fib18
    Fib19
    Fib20
    Fib21
)

func main() {
    fibs := []int{
        Fib0,
        Fib1,
        Fib2,
        Fib3,
        Fib4,
        Fib5,
        Fib6,
        Fib7,
        Fib8,
        Fib9,
        Fib10,
        Fib11,
        Fib12,
        Fib13,
        Fib14,
        Fib15,
        Fib16,
        Fib17,
        Fib18,
        Fib19,
        Fib20,
        Fib21,
    }
    for i, fib := range fibs {
        fmt.Println(i, fib)
    }
}
</code></pre>

<p>実行結果です。</p>

<pre><code class="plain">$ go run fibconst.go
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
21 17711
</code></pre>

<p><code>Fibxxx</code>をたくさん書くのはつらかったので、ソースコードはPerlで自動生成しました。</p>

<pre><code class="perl">print &lt;&lt;EOF;
package main

import "fmt"

const Fib0 = 1

const (
    _    = (4 &lt;&lt; (iota * (3 + iota))) / ((4 &lt;&lt; (2 * iota)) - (2 &lt;&lt; iota) - 1) &amp; ((2 &lt;&lt; iota) - 1)
EOF

print "    Fib$_\n" for 1..21;

print &lt;&lt;EOF;
)

func main() {
    fibs := []int{
        Fib0,
EOF

print "        Fib$_,\n" for 1..21;

print &lt;&lt;EOF
    }
    for i, fib := range fibs {
        fmt.Println(i, fib)
    }
}
EOF
</code></pre>

<p>21までしかないのは、
22以降を求めようとしたらコンパイルが通らなかったためです。</p>

<pre><code class="plain">$ go run fibconst.go
# command-line-arguments
./fibconst.go:29: shift count too large: 550
</code></pre>

<p>どうやら512bitまでしか扱えないらしい。
任意精度扱えるって書いてあったのに！！！</p>

<ul>
<li><a href="https://github.com/golang/go/blob/go1.8/src/cmd/compile/internal/gc/mpint.go#L211">mpint.go</a></li>
<li><a href="https://github.com/golang/go/blob/go1.8/src/cmd/compile/internal/gc/mpfloat.go#L18">mpfloat.go</a></li>
</ul>


<p>おとなしく多倍長整数が組込の言語でやれっている話ではありますが、
なんとなくやってみたかったんです。</p>

<h2>参考</h2>

<ul>
<li><a href="http://postd.cc/fibonacci/">整数の公式でフィボナッチ数列を求める</a>

<ul>
<li>Source: <a href="http://paulhankin.github.io/Fibonacci/">An integer formula for Fibonacci numbers</a></li>
</ul>
</li>
<li><a href="http://qiita.com/sonatard/items/464a9d45c689386edfe1">Better C - Go言語と整数 #golang</a></li>
</ul>


<p>ネタ元にある「母関数」という概念は、数学ガールを読んで知りました。</p>

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=shogo82148-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4797341378&linkId=be2c6011ca1a5f15d96c370e494b0f95"></iframe>


<p>フィボナッチ数列に触れている部分はWebでも公開されているので、そちらもどうぞ(<a href="http://www.hyuki.com/story/genfunc.html">ミルカさんとフィボナッチ数列</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[go-sql-proxyがcontextに対応しました]]></title>
    <link href="https://shogo82148.github.io/blog/2017/02/16/go-sql-proxy-in-go18/"/>
    <updated>2017-02-16T07:16:44+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/02/16/go-sql-proxy-in-go18</id>
    <content type="html"><![CDATA[<p>Go1.8ではdatabase/sqlのcontextサポートが入ります。
(きっと今日の<a href="https://eventdots.jp/event/611405">Go 1.8 Release Party</a>で詳しく説明があるはず、たぶん)
それにともない<a href="https://shogo82148.github.io/blog/2015/05/13/golang-sql-proxy/">Go言語でSQLのトレースをする</a>で紹介した
<a href="https://github.com/shogo82148/go-sql-proxy">shogo82148/go-sql-proxy</a>でもcontextを扱えるようにしました。</p>

<!-- More -->


<h2>Go1.8新機能のサポート</h2>

<p><a href="http://mattn.kaoriya.net/software/lang/go/20161106232834.htm">Golang 1.8 でやってくる database/sql の変更点</a>で
mattnさんが紹介しているように、Go1.8ではdatabase/sqlにいくつか新機能が追加されます。
(mattnさんの対応が早すぎて、メソッド名とか微妙に変更が入っているので注意)</p>

<p>特に大きなのがcontextのサポートでしょう。以下のようなコードでクエリのキャンセルが可能になります。</p>

<pre><code class="go">ctx, cancel := context.WithCancel(context.Background())
go func() {
    // 1秒待ってからキャンセル
    time.Sleep(1 * time.Second)
    cancel()
}()

rows, err := db.QueryContext(ctx, "SELECT name FROM test where id = ?", id)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>go-sql-proxyでもcontext対応を行ったので、
proxyを経由した場合でも、キャンセルが可能になります。
(もちろん、originとなるドライバの対応も必要です)</p>

<p>Go1.8ではcontextサポート以外にもいくつか新機能が追加される予定です。
これらについても、originとなるドライバが対応していれば、go-sql-proxy経由でも全く同じように扱えます。</p>

<h2>contextとHookの関連付け</h2>

<p>contextにHookを関連付けて、一部のクエリにだけHookを付けることができるようになりました。
例えば以下のようなコードでctxに関連したクエリだけログを出力できます。</p>

<pre><code class="go">package main

import (
    "context"
    "database/sql"

    "github.com/shogo82148/go-sql-proxy"
)

var tracer = proxy.NewTraceHooks(proxy.TracerOptions{})

func main() {
    // 何もしないproxyをインストール
    proxy.RegisterProxy()

    // 末尾に":proxy"がついた名前でアクセス
    db, _ := sql.Open("origin:proxy", "data source")

    // このコンテキストに関連したクエリだけでログが有効になります
    ctx := proxy.WithHooks(context.Background(), tracer)
    db.ExecContext(ctx, "CREATE TABLE t1 (id INTEGER PRIMARY KEY)")
}
</code></pre>

<p>グローバルなproxyに既にHookが設定してあった場合は上書きされます。
上書きされたHookは実行されないので注意してください。</p>

<p>「トレースの負荷が気になるから、全体の1%だけ出力したい！」とか
「このAPIだけ重たいから、この部分だけトレースしたい！」とか
そういう場合に便利ではないでしょうか。</p>

<h2>トレースオプションの追加</h2>

<p>Tracerに色々オプションをつけたいなと思ったので、<code>proxy.TracerOptions</code>を追加しました。
例えばSlowQueryに時間を設定すると、この時間以上経ったクエリだけ表示されます。</p>

<pre><code class="go">var tracer = proxy.NewTraceHooks(proxy.TracerOptions{
    SlowQuery: 10 * time.Second,
})
</code></pre>

<p>ちなみに初期のトレーサーは<code>logger.Output(6, "Begin")</code>みたいな感じで書いてたので、
案の定Go1.8の変更でぶっ壊れました。
頑張ってスタックトレースを辿って、関数名をパースしてパッケージ名を取得(ダイレクトにパッケージ名だけ取る機能は見つからなかった)して、
フィルタリングするようにしたので、もう大丈夫なはず。
その代わりにパフォーマンスが犠牲になったので、
あまり高負荷のところに突っ込まないでくださいね。</p>

<h2>フック関数の変更</h2>

<p>context対応に伴い、Hookの差し込み方も変わっています。
<code>proxy.Hooks</code>は非推奨の扱いで、<code>proxy.HooksContext</code>を使って下さい。
以下の例のようにcontext.Contextが第一引数に追加されています。
デバッグ情報の受け渡しに使えるかも？</p>

<pre><code class="go">package main

import (
    "database/sql"
    "database/sql/driver"
    "log"
    "time"

    "github.com/mattn/go-sqlite3"
    "github.com/shogo82148/go-sql-proxy"
)

func main() {
    sql.Register("sqlite3-proxy", proxy.NewProxyContext(&amp;sqlite3.SQLiteDriver{}, &amp;proxy.HooksContext{
        PreExec: func(_ context.Context, _ *proxy.Stmt, _ []driver.NamedValue) (interface{}, error) {
            // The first return value(time.Now()) is passed to both `Hooks.Exec` and `Hook.ExecPost` callbacks.
            return time.Now(), nil
        },
        PostExec: func(_ context.Context, ctx interface{}, stmt *proxy.Stmt, args []driver.NamedValue, _ driver.Result, _ error) error {
            // The `ctx` parameter is the return value supplied from the `Hooks.PreExec` method, and may be nil.
            log.Printf("Query: %s; args = %v (%s)\n", stmt.QueryString, args, time.Since(ctx.(time.Time)))
            return nil
        },
    }))

    db, err := sql.Open("sqlite3-proxy", ":memory:")
    if err != nil {
        log.Fatalf("Open filed: %v", err)
    }
    defer db.Close()

    _, err = db.Exec(
        "CREATE TABLE t1 (id INTEGER PRIMARY KEY)",
    )
    if err != nil {
        log.Fatal(err)
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go1.8のGraceful Shutdownとgo-gracedownの対応]]></title>
    <link href="https://shogo82148.github.io/blog/2017/01/21/golang-1-dot-8-graceful-shutdown/"/>
    <updated>2017-01-21T12:44:32+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/01/21/golang-1-dot-8-graceful-shutdown</id>
    <content type="html"><![CDATA[<p>Go1.8beta1が出た時に、Go1.8で追加される予定のGraceful Shutdownについて書く！
とTwitterに書き込んで早1ヶ月。
この前の金曜日に<a href="https://twitter.com/golang/status/822201571928731648">Go1.8rc2がリリースされ</a>、正式リリースも間近になってきて、
さすがに書かねばという気持ちになって来たので、がんばって検証してみます。</p>

<!-- More -->


<h2>公式サポートで増える予定の機能</h2>

<p>以前<a href="https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd/">Go言語でGraceful Restartをするときに取りこぼしを少なくする</a>で
紹介したように<a href="https://github.com/shogo82148/go-gracedown">shogo82148/go-gracedown</a>というものを書きました。
あれから時は経ち、ついにGo1.8からは<a href="https://github.com/golang/go/issues/4674">Graceful Shudownがbuild-inの機能として提供</a>される予定です。
公式サポートが入ることによって、以下のような機能を使えるようになります。</p>

<h3>HTTP/2のGraceful Shutdownができる</h3>

<p>HTTP/2ではGOAWAYフレームという接続を切ることを通知する機能があります。
Go1.8からはシャットダウン時にこのGOAWAYフレームを送ってくれるようになります。
GOAWAYフレームはサーバ側から任意のタイミングで送ることができ、
どこまで正常に処理できたかをクライアントに伝えられるという利点があります。</p>

<p>余談ですが、この機能は<a href="https://github.com/golang/go/issues/18471">x/net/http2を利用している場合は動かない</a>らしいです。
<a href="https://github.com/golang/net/blob/8fd7f25955530b92e73e9e1932a41b522b22ccd9/http2/server.go#L2716-L2736">importしたときには動かないけどbundleしたときにだけ動く黒魔術</a>が使われているためです。
覚えておいても今後絶対使うことはなさそう。というか使いたくない・・・。</p>

<h3>contextが使える</h3>

<p>go-gracedownを作った頃は、contextはまだ標準パッケージに取り込まれていなかったので対応していませんでした。
(1.7のリリース時に対応を怠っていただけとも言える)
net/httpのシャットダウンはもちろんcontextに対応しています。
これにより、Graceful Shutdownを中断して強制終了する、
ということが簡単にできるようになります。</p>

<h2>公式サポートで変更になる予定の挙動</h2>

<p>Keep-Aliveでのリクエストの挙動が少し変わります。
1.7以前のgo-gracedownでは、クライアントにKeep-Aliveが無効になったのを伝え、
クライアント側から接続を切るのを待つように実装してしました。
多少接続時間が延びたとしてもクライアント側でよくわからないエラーになるよりはマシだろ、との考えからです。</p>

<p>1.8からはシャットダウン時にIdle状態(TCP接続は有効だけど、リクエストは処理していない状態)な接続は切断されます。
内部で使っている<a href="https://golang.org/pkg/net/http/#Server.SetKeepAlivesEnabled">Server.SetKeepAlivesEnabled</a>の
挙動が<a href="https://github.com/golang/go/issues/9478">変更になった</a>ためです。</p>

<p>Goの中の人的には「この挙動が原因で万が一トラブルになっても、クライアントがリトライしてくれるから大丈夫でしょ」とのことのようです。
サーバシャットダウン以外にもネットワークトラブル等でも接続は切れるので、
クライアント側で頑張ってというのは正論ですが、
どの程度エラーが増えるのかは気になるところです。</p>

<h3>go-gracedownの対応</h3>

<p>go-gracedownはGo1.8でコンパイルされたときはbuild-inの機能を直接使うようになります。
中身はほとんどがインターフェースの互換性を保つためのコードなので、
機能的なメリットは完全になくなってしまいました・・・。
HTTP/2サポートも問題なく動くはずです。
逆にパッケージの依存が増えること以外はデメリットはないともいえます。</p>

<p>Go1.7以下では今までの方法にフォールバックしてくれます。
というわけで、以下のような人には有用です。</p>

<ul>
<li>深淵な理由でGo1.7以下しか使えない人</li>
<li>Go1.8とGo1.7以下のサポートがどうしても必要な人</li>
<li>Go1.8にアップグレードしたけど、graceful shutdownの処理を書き換えるのがめんどくさい人</li>
</ul>


<p>ところで、環境が悪いときに性能を落としたり機能を制限することをフォールバック(fall back)というわけですが、
逆に環境が良いときに性能を上げたり機能を拡張することはなんていうんですかね？
モデムでは通信環境が良いときに高速な通信方式に切り変えることを「フォールフォワード(fall forward)」というらしいです。
「Go1.8ではbild-inのGraceful Shutdownにフォールフォワードする」で使い方あってます？</p>

<h2>使い方</h2>

<h3>Server.Shutdownを使う</h3>

<p><a href="http://qiita.com/advent-calendar/2016/go3">Go(その3) Advent Calendar</a>の
<a href="http://qiita.com/najeira/items/806cacb9bba96ff06ec4">最終日の記事</a>でも扱ってますが改めて。</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "log"
    "net"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/lestrrat/go-server-starter/listener"
)

func main() {
    log.Printf("start pid %d\n", os.Getpid())

    listeners, err := listener.ListenAll()
    if err != nil &amp;&amp; err != listener.ErrNoListeningTarget {
        panic(err)
    }
    var l net.Listener
    if err == listener.ErrNoListeningTarget {
        // Fallback if not running under Server::Starter
        l, err = net.Listen("tcp", ":8080")
        if err != nil {
            panic("Failed to listen to port 8080")
        }
    } else {
        l = listeners[0]
    }

    // 別goroutineでServeしていることに注意！
    srv := &amp;http.Server{Handler: newHandler()}
    go func() {
        srv.Serve(l)
    }()

    // mainの中でシグナルの待受をしていることに注意！
    signal_chan := make(chan os.Signal)
    signal.Notify(signal_chan, syscall.SIGTERM)
    for {
        s := &lt;-signal_chan
        if s == syscall.SIGTERM {
            log.Printf("SIGTERM!!!!\n")
            srv.Shutdown(context.Background())
            return
        }
    }
}

func newHandler() http.Handler {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "from pid %d.\n", os.Getpid())
    })
    return mux
}
</code></pre>

<p>go-gracedownからの移行するさいの注意点は以下の通りです。</p>

<ul>
<li><code>Server.Shutdown</code>を使う(<code>Serer.Close</code>もあるけど、そっちはGracefulではない)</li>
<li><code>Server.Serve</code>は<strong>シャットダウンが始まる</strong>とすぐに制御を返す(<strong>シャットダウンが終わる</strong>とではない)</li>
<li><code>Server.Shutdown</code>は<strong>シャットダウンが終わる</strong>と制御を返す(<strong>シャットダウンが始まる</strong>とではない)</li>
</ul>


<h3>go-gracedownを使う</h3>

<p>go-gracedownの使い方も再掲しておきます。
Go1.6から利用方法は一切変更はないですが、
Go1.8でコンパイルすると<code>Server.Shutdown</code>を利用してくれます。</p>

<pre><code class="go">package main

import (
    "fmt"
    "log"
    "net"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/lestrrat/go-server-starter/listener"
    "github.com/shogo82148/go-gracedown"
)

func main() {
    log.Printf("start pid %d\n", os.Getpid())

    signal_chan := make(chan os.Signal)
    signal.Notify(signal_chan, syscall.SIGTERM)
    go func() {
        for {
            s := &lt;-signal_chan
            if s == syscall.SIGTERM {
                log.Printf("SIGTERM!!!!\n")
                gracedown.Close()
            }
        }
    }()

    listeners, err := listener.ListenAll()
    if err != nil &amp;&amp; err != listener.ErrNoListeningTarget {
        panic(err)
    }
    var l net.Listener
    if err == listener.ErrNoListeningTarget {
        // Fallback if not running under Server::Starter
        l, err = net.Listen("tcp", ":8080")
        if err != nil {
            panic("Failed to listen to port 8080")
        }
    } else {
        l = listeners[0]
    }

    gracedown.Serve(l, newHandler())
}

func newHandler() http.Handler {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "from pid %d.\n", os.Getpid())
    })
    return mux
}
</code></pre>

<h3>HTTP/2を使う</h3>

<p>せっかくHTTP/2にも対応したことなので、
Server::Starterを使ってHTTP/2サーバのGraceful Restartをする例も書いてみました。</p>

<pre><code class="go">package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "log"
    "net"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/lestrrat/go-server-starter/listener"
)

// net/http/internal/testcert.go から拝借
var localhostCert = []byte(`-----BEGIN CERTIFICATE-----
MIICEzCCAXygAwIBAgIQMIMChMLGrR+QvmQvpwAU6zANBgkqhkiG9w0BAQsFADAS
MRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw
MDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB
iQKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9SjY1bIw4
iA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZBl2+XsDul
rKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQABo2gwZjAO
BgNVHQ8BAf8EBAMCAqQwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDwYDVR0TAQH/BAUw
AwEB/zAuBgNVHREEJzAlggtleGFtcGxlLmNvbYcEfwAAAYcQAAAAAAAAAAAAAAAA
AAAAATANBgkqhkiG9w0BAQsFAAOBgQCEcetwO59EWk7WiJsG4x8SY+UIAA+flUI9
tyC4lNhbcF2Idq9greZwbYCqTTTr2XiRNSMLCOjKyI7ukPoPjo16ocHj+P3vZGfs
h1fIw3cSS2OolhloGw/XM6RWPWtPAlGykKLciQrBru5NAPvCMsb/I1DAceTiotQM
fblo6RBxUQ==
-----END CERTIFICATE-----`)

var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9
SjY1bIw4iA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZB
l2+XsDulrKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQAB
AoGAGRzwwir7XvBOAy5tM/uV6e+Zf6anZzus1s1Y1ClbjbE6HXbnWWF/wbZGOpet
3Zm4vD6MXc7jpTLryzTQIvVdfQbRc6+MUVeLKwZatTXtdZrhu+Jk7hx0nTPy8Jcb
uJqFk541aEw+mMogY/xEcfbWd6IOkp+4xqjlFLBEDytgbIECQQDvH/E6nk+hgN4H
qzzVtxxr397vWrjrIgPbJpQvBsafG7b0dA4AFjwVbFLmQcj2PprIMmPcQrooz8vp
jy4SHEg1AkEA/v13/5M47K9vCxmb8QeD/asydfsgS5TeuNi8DoUBEmiSJwma7FXY
fFUtxuvL7XvjwjN5B30pNEbc6Iuyt7y4MQJBAIt21su4b3sjXNueLKH85Q+phy2U
fQtuUE9txblTu14q3N7gHRZB4ZMhFYyDy8CKrN2cPg/Fvyt0Xlp/DoCzjA0CQQDU
y2ptGsuSmgUtWj3NM9xuwYPm+Z/F84K6+ARYiZ6PYj013sovGKUFfYAqVXVlxtIX
qyUBnu3X9ps8ZfjLZO7BAkEAlT4R5Yl6cGhaJQYZHOde3JEMhNRcVFMO8dJDaFeo
f9Oeos0UUothgiDktdQHxdNEwLjQf7lJJBzV+5OtwswCWA==
-----END RSA PRIVATE KEY-----`)

func main() {
    log.Printf("start pid %d\n", os.Getpid())

    listeners, err := listener.ListenAll()
    if err != nil &amp;&amp; err != listener.ErrNoListeningTarget {
        panic(err)
    }
    var l net.Listener
    if err == listener.ErrNoListeningTarget {
        // Fallback if not running under Server::Starter
        l, err = net.Listen("tcp", ":8080")
        if err != nil {
            panic("Failed to listen to port 8080")
        }
    } else {
        l = listeners[0]
    }
    cert, err := tls.X509KeyPair(localhostCert, localhostKey)
    if err != nil {
        panic(err)
    }
    tlsConfig := &amp;tls.Config{
        NextProtos:   []string{"h2"},
        Certificates: []tls.Certificate{cert},
    }

    srv := &amp;http.Server{
        Handler:   newHandler(),
        TLSConfig: tlsConfig,
    }
    l = tls.NewListener(l, tlsConfig)
    go func() {
        srv.Serve(l)
    }()

    signal_chan := make(chan os.Signal)
    signal.Notify(signal_chan, syscall.SIGTERM)
    for {
        s := &lt;-signal_chan
        if s == syscall.SIGTERM {
            log.Printf("SIGTERM!!!!\n")
            srv.Shutdown(context.Background())
            return
        }
    }
}

func newHandler() http.Handler {
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "from pid %d.\n", os.Getpid())
    })
    return mux
}
</code></pre>

<p><code>NextProtos</code>へ明示的に<code>h2</code>を指定する必要があるのがポイントです。
net/httpはデフォルトでHTTP/2を有効にしてくれますが、
<code>TLSConfig</code>が指定されているときは自前でやる必要があります。</p>

<h2>実験</h2>

<p>HTTP/2に対応していて証明書の検証もスキップできて・・・という条件で
ベンチマークソフトを探すのが面倒だったので、Goで自作です。
あまり詳しい統計情報は要らないので、負荷をかけるのにリソースを割きたかったというのもあります。</p>

<pre><code class="go">package main

import (
    "crypto/tls"
    "flag"
    "io"
    "io/ioutil"
    "log"
    "net"
    "net/http"
    "time"

    "github.com/kayac/parallel-benchmark/benchmark"
    "golang.org/x/net/http2"
)

type myWorker struct {
    URL    string
    client *http.Client
    buf    []byte
}

func (w *myWorker) Setup() {
    tr := &amp;http.Transport{
        Proxy: http.ProxyFromEnvironment,
        DialContext: (&amp;net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
        }).DialContext,
        MaxIdleConns:        1,
        IdleConnTimeout:     90 * time.Second,
        TLSHandshakeTimeout: 10 * time.Second,
        TLSClientConfig: &amp;tls.Config{
            // テストなので証明書の検証はスキップ
            // プロダクションでは必ず有効にしてください！
            InsecureSkipVerify: true,
        },
        ExpectContinueTimeout: 1 * time.Second,
    }
    if err := http2.ConfigureTransport(tr); err != nil {
        panic(err)
    }
    w.client = &amp;http.Client{
        Transport: tr,
    }
    w.buf = make([]byte, 1024)
}

func (w *myWorker) Teardown() {
}

func (w *myWorker) Process() (subscore int) {
    resp, err := w.client.Get(w.URL)
    if err != nil {
        log.Printf("ERROR: %v", err)
        return 0
    }
    _, err = io.CopyBuffer(ioutil.Discard, resp.Body, w.buf)
    resp.Body.Close()
    if err != nil &amp;&amp; err != io.EOF {
        log.Printf("ERROR: %v", err)
        return 0
    }
    if resp.StatusCode != http.StatusOK {
        log.Printf("Invalid Status: %d", resp.StatusCode)
        return 0
    }
    return 1
}

func main() {
    var (
        conn     int
        duration time.Duration
    )
    flag.IntVar(&amp;conn, "c", 1, "connections to keep open")
    flag.DurationVar(&amp;duration, "d", time.Second, "duration of benchmark")
    flag.Parse()
    url := flag.Args()[0]
    workers := make([]benchmark.Worker, conn)
    for i, _ := range workers {
        workers[i] = &amp;myWorker{URL: url}
    }
    benchmark.Run(workers, duration)
}
</code></pre>

<p>前回記事同様、Server::Starterを使って1秒毎に再起動を繰り返しながらベンチを回します。
AWSのc4.largeインスタンス上で実行しました。</p>

<pre><code class="bash">$ start_server --port 8080 --pid-file app.pid -- ./main
$ while true; do kill -HUP `cat app.pid`; sleep 1; done
$ ./bin/bench -c 10 -d=1m http://localhost:8080/
</code></pre>

<h2>結果</h2>

<h3>Server.Shutdownを使った場合</h3>

<p>Server.Shutdownを使った場合の結果です。</p>

<pre><code class="plain">$ ./bin/bench -c 10 -d=1m http://localhost:8080/
2017/01/22 12:20:51 starting benchmark: concurrency: 10, time: 1m0s, GOMAXPROCS: 2
2017/01/22 12:21:51 done benchmark: score 1174412, elapsed 1m0.002557914s = 19572.698912 / sec
</code></pre>

<p>先程紹介したKeepAliveの挙動変更の影響で多少はエラーがでるのでは？と予想していたものの、
まったく影響はありませんでした。</p>

<h3>go-gracedownを使った場合</h3>

<p>go-gracedownを使った場合の結果です。</p>

<pre><code class="plain">$ ./bin/bench -c 10 -d=1m http://localhost:8080/
2017/01/22 12:22:26 starting benchmark: concurrency: 10, time: 1m0s, GOMAXPROCS: 2
2017/01/22 12:23:26 done benchmark: score 1160878, elapsed 1m0.009764419s = 19344.818485 / sec
</code></pre>

<p>中身は<code>Server.Shutdown</code>なので、当然ながら同じ結果です。</p>

<h3>HTTP/2でアクセスした場合</h3>

<p>HTTP/2でアクセスした場合の結果です。
GoのHTTP/2サポートはHTTPSで通信したときにしか有効にならないので、他のベンチとURLが違うことに注意。</p>

<pre><code class="plain">$ ./bin/bench -c 10 -d=1m https://localhost:8080/
2017/01/22 12:30:04 starting benchmark: concurrency: 10, time: 1m0s, GOMAXPROCS: 2
2017/01/22 12:31:04 done benchmark: score 666801, elapsed 1m0.001842465s = 11113.008745 / sec
</code></pre>

<p>特にエラーもなく、全く問題ありませんでした。</p>

<h2>まとめ</h2>

<ul>
<li>Go1.8からサポートされる予定のHTTPサーバのGraceful Shutdownについて検証しました

<ul>
<li>HTTP/1.1とHTTP/2で検証しましたが、特に問題は見つかりませんでした</li>
</ul>
</li>
<li>go-gracedownはGo1.8でコンパイルされたときはbuild-inの機能を使うようになります

<ul>
<li>機能的にはbuild-inの機能を直接使う場合とまったく変わりありません</li>
</ul>
</li>
</ul>


<p>Go1.8の正式リリース楽しみですね！</p>

<h2>参考</h2>

<ul>
<li><a href="https://shogo82148.github.io/blog/2015/05/03/golang-graceful-restart/">Go言語でGraceful Restartをする</a></li>
<li><a href="https://shogo82148.github.io/blog/2015/11/23/golang-graceful-restart-2nd/">Go言語でGraceful Restartをするときに取りこぼしを少なくする</a></li>
<li><a href="https://github.com/golang/go/issues/4674">net/http: add built-in graceful shutdown support to Server #4674</a></li>
<li><a href="https://github.com/golang/go/issues/9478">net/http: make Server.SetKeepAlivesEnabled(false) drop currently-open connections #9478</a></li>
<li><a href="http://qiita.com/najeira/items/806cacb9bba96ff06ec4">Go 1.8 の HTTP Server Graceful Shutdown を試す</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Re:golang の http.Client を速くする]]></title>
    <link href="https://shogo82148.github.io/blog/2017/01/14/re-golang-dns-cache/"/>
    <updated>2017-01-14T17:02:12+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/01/14/re-golang-dns-cache</id>
    <content type="html"><![CDATA[<p>先日<a href="https://twitter.com/mattn_jp">mattn</a>さんの記事を読みました。</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20170112181052.htm">golang の http.Client を速くする</a></li>
</ul>


<p><a href="https://github.com/abursavich/nett">nett</a>というパッケージを使って
名前解決の結果をキャッシュすることで、<code>http.Client</code>を早くするというものです。
この記事に関して、ちょっと疑問に思ったことがあったので、検証してみました。</p>

<!-- More -->


<h2>疑問</h2>

<p>疑問に思ったのは以下の点です。</p>

<h3>名前解決遅すぎでは？</h3>

<p>ベンチマークの結果を見ると5億ns(=500ms)ほど速度が改善しています。
3つのURLに対してリクエストを投げているので、初回を除く2回DNSのキャッシュがヒットし、
名前解決2回分の速度改善になるはずです。
と、いうことは、名前解決1回あたり250msかかっている計算になります。
googleのsearchは302でリダイレクトがかかるので、<code>Client.Get</code>の呼び出し1回あたり2回リクエストが飛ぶ、
ということを計算に入れても100msほどかかる計算です。</p>

<p>Google先生の謎テクノロジーによってかなりの最適化がされているはずですし、
ネットワークプロバイダのDNSキャッシュにヒットする可能性も高いでしょう。
<strong>名前解決程度にこんなに時間がかかっていたらスプラトゥーンが出来ない！</strong>
(mattnさんがスプラトゥーンをプレイしているかは知らない)</p>

<p><strong>2017/01/16追記:</strong>
mattnさんはスプラトゥーンをプレイしていないそうです。残念。</p>

<p><a href="https://twitter.com/mattn_jp/status/820236711149981696">https://twitter.com/mattn_jp/status/820236711149981696</a>">https://twitter.com/mattn_jp/status/820236711149981696">https://twitter.com/mattn_jp/status/820236711149981696</a></a></p>

<p>もちろん、ネットワークが混雑していたり、
モバイルネットワークを利用していたり、という可能性もありますが、
ちょっと不自然な印象を受けました。</p>

<h3>Keep-Aliveされてるのでは？</h3>

<p>スキーマがhttpsになっているので、Google先生相手ならHTTP2で通信していてもおかしくありません。
HTTP2は基本的にドメイン毎にコネクションを1つだけ張って、それを使いまわします。
もし仮にHTTP1.1で通信していたとしても、<code>http.Client</code>はデフォルトでKeep-Aliveが有効になっているので、
普通に使うとコネクションを再利用してくれます。</p>

<p>そういうわけで、名前解決以前にそもそもTCPのコネクション確立もスキップされている可能性が高いのでは？
と思ったわけです。
この予想が正しければ、名前解決は初回リクエストでしか行われないので、ベンチマークに差はでないはずです。</p>

<h2>HTTPリクエストの様子をトレースしてみる</h2>

<p>これらの疑問を解消するために、HTTPリクエストの様子をさらに詳細に解析してみることにしました。</p>

<h3>DNSキャッシュなし版をトレースする</h3>

<p>Go1.7から<a href="https://golang.org/pkg/net/http/httptrace/">net/http/httptrace</a>というパッケージが追加され、
名前解決やコネクション確立etcのタイミングにフックを仕込めるようになりました。
これを利用すれば各段階でどの程度時間がかかっているかが具体的に分かるはずです。</p>

<p>頑張って自前でフックを差し込んでもよいのですが、
<a href="https://twitter.com/deeeet">deeeet</a>さんの<a href="https://github.com/tcnksm/go-httpstat">go-httpstat</a>という便利パッケージがあるので、
これをありがたく利用させていただきます。
go-httpstatを使うと時間計測を行うコードを簡単に差し込むことができます。</p>

<pre><code class="go">package main

import (
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "time"

    "github.com/tcnksm/go-httpstat"
)

var (
    urls = []string{
        "https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/",
        "https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/",
        "https://shogo82148.github.io/blog/2016/11/23/qr-code/",
    }
)

func main() {
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            Proxy:             http.ProxyFromEnvironment,
            // DisableKeepAlives: true,
        },
    }

    for _, url := range urls {
        log.Printf("GET %s", url)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil {
            panic(err)
        }
        result := new(httpstat.Result)
        ctx := httpstat.WithHTTPStat(req.Context(), result)
        req = req.WithContext(ctx)

        resp, err := client.Do(req)
        if err != nil {
            panic(err)
        }
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()

        result.End(time.Now())
        log.Printf("%+v\n", result)
    }
}
</code></pre>

<p>元記事はGoogleを叩いていましたが、あのURLだとリダイレクトが発生して考えることが増えそうなので、
このブログのURLに変更してあります。
あと静的ページなら相手に余計な負荷をかけることも無いですしね。</p>

<p>さっそく実行してみましょう。
<strong>Keep-Aliveを有効</strong>にした場合の結果です。</p>

<pre><code class="plain">2017/01/14 16:14:10 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:14:10 DNS lookup:          30 ms
TCP connection:      16 ms
TLS handshake:      130 ms
Server processing:   17 ms
Content transfer:     1 ms
Name Lookup:      30 ms
Connect:          47 ms
Pre Transfer:    177 ms
Start Transfer:  195 ms
Total:           197 ms
2017/01/14 16:14:10 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:14:10 DNS lookup:           0 ms
TCP connection:       0 ms
TLS handshake:        0 ms
Server processing:   17 ms
Content transfer:     2 ms
Name Lookup:       0 ms
Connect:           0 ms
Pre Transfer:      0 ms
Start Transfer:   17 ms
Total:            19 ms
2017/01/14 16:14:10 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
2017/01/14 16:14:10 DNS lookup:           0 ms
TCP connection:       0 ms
TLS handshake:        0 ms
Server processing:   17 ms
Content transfer:     4 ms
Name Lookup:       0 ms
Connect:           0 ms
Pre Transfer:      0 ms
Start Transfer:   17 ms
Total:            22 ms
</code></pre>

<p>二回目以降のDNS lookupやTCP connectionが0msになっています。
予想通りコネクションが再利用され、名前解決やコネクション確立がスキップされているようです。</p>

<p>次に<strong>Keep-Aliveを無効</strong>にした状態で実行してみます。
コード中の<code>DisableKeepAlives</code>のコメントを外すと都度接続になります。</p>

<pre><code class="plain">2017/01/14 16:14:33 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:14:33 DNS lookup:          21 ms
TCP connection:      18 ms
TLS handshake:      131 ms
Server processing:   15 ms
Content transfer:     1 ms
Name Lookup:      21 ms
Connect:          40 ms
Pre Transfer:    171 ms
Start Transfer:  187 ms
Total:           188 ms
2017/01/14 16:14:33 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:14:33 DNS lookup:           1 ms
TCP connection:      15 ms
TLS handshake:       33 ms
Server processing:   14 ms
Content transfer:     1 ms
Name Lookup:       1 ms
Connect:          16 ms
Pre Transfer:     49 ms
Start Transfer:   64 ms
Total:            65 ms
2017/01/14 16:14:33 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
2017/01/14 16:14:33 DNS lookup:           0 ms
TCP connection:      17 ms
TLS handshake:       35 ms
Server processing:   19 ms
Content transfer:     3 ms
Name Lookup:       0 ms
Connect:          18 ms
Pre Transfer:     54 ms
Start Transfer:   73 ms
Total:            76 ms
</code></pre>

<p>リクエスト毎に名前解決が行われるようになりました。
ですが、初回に比べて異様に速いですね。
OS側でキャッシュされてるんでしょうか。</p>

<p><code>GODEBUG=netdns=go</code>と環境変数を設定すると、Pure Golangで名前解決が行われるらしいので、
その場合の結果も貼っておきます。</p>

<pre><code class="plain">2017/01/14 16:15:03 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:15:03 DNS lookup:          33 ms
TCP connection:      15 ms
TLS handshake:      133 ms
Server processing:   16 ms
Content transfer:     0 ms
Name Lookup:      33 ms
Connect:          48 ms
Pre Transfer:    181 ms
Start Transfer:  197 ms
Total:           198 ms
2017/01/14 16:15:03 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:15:03 DNS lookup:          17 ms
TCP connection:      14 ms
TLS handshake:       32 ms
Server processing:   19 ms
Content transfer:     0 ms
Name Lookup:      17 ms
Connect:          31 ms
Pre Transfer:     63 ms
Start Transfer:   82 ms
Total:            83 ms
2017/01/14 16:15:03 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
2017/01/14 16:15:03 DNS lookup:          18 ms
TCP connection:      15 ms
TLS handshake:       36 ms
Server processing:   18 ms
Content transfer:     2 ms
Name Lookup:      18 ms
Connect:          34 ms
Pre Transfer:     70 ms
Start Transfer:   89 ms
Total:            91 ms
</code></pre>

<h3>DNSキャッシュあり版をトレースする</h3>

<p>DNSキャッシュありも同様にトレースしようと思ったのですが、
残念ながら<a href="https://github.com/abursavich/nett">nett</a>は<code>context.Context</code>を引数に持つインターフェースをサポートしていません。
httptraceを利用するにはcontextが必要なので、同じ方法は使えません。</p>

<p>仕方がないので、頑張ってResolverを自作して、
時間計測するコードを埋め込んでいきます。</p>

<pre><code class="go">package main

import (
    "io"
    "io/ioutil"
    "log"
    "net"
    "net/http"
    "time"

    "github.com/abursavich/nett"
)

var (
    urls = []string{
        "https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/",
        "https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/",
        "https://shogo82148.github.io/blog/2016/11/23/qr-code/",
    }
)

type MyResolver struct {
    Resolver nett.Resolver
}

func (r *MyResolver) Resolve(host string) ([]net.IP, error) {
    start := time.Now()
    ips, err := r.Resolver.Resolve(host)
    log.Printf("Name Lookup: %s", time.Now().Sub(start))
    return ips, err
}

func main() {
    dialer := &amp;nett.Dialer{
        Resolver: &amp;MyResolver{
            &amp;nett.CacheResolver{TTL: 5 * time.Minute},
        },
        IPFilter: nett.DualStack,
        Timeout:  10 * time.Second,
    }
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            Dial: func(network, address string) (net.Conn, error) {
                start := time.Now()
                conn, err := dialer.Dial(network, address)
                log.Printf("Connect: %s", time.Now().Sub(start))
                return conn, err
            },
            Proxy:             http.ProxyFromEnvironment,
            // DisableKeepAlives: true,
        },
    }
    for _, url := range urls {
        log.Printf("GET %s", url)
        resp, err := client.Get(url)
        if err != nil {
            panic(err)
        }
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
    }
}
</code></pre>

<p>こちらのコードも実行してみます。
<strong>Keep-Aliveを有効</strong>にした場合の結果です。</p>

<pre><code class="plain">2017/01/14 16:29:19 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:29:19 Name Lookup: 22.239218ms
2017/01/14 16:29:19 Connect: 39.364428ms
2017/01/14 16:29:19 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:29:19 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
</code></pre>

<p>こちらも予想通り名前解決とコネクション確立が初回しか行われないので、
最初の一回だけ時間計測のログが出力されています。</p>

<p>次に、<strong>Keep-Aliveを無効</strong>にした場合の結果です。
DNSキャッシュなし版と同様に<code>DisableKeepAlives</code>のコメントを外すと無効にできます。</p>

<pre><code class="plain">2017/01/14 16:29:41 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:29:41 Name Lookup: 27.337342ms
2017/01/14 16:29:41 Connect: 44.552754ms
2017/01/14 16:29:41 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:29:41 Name Lookup: 1.991µs
2017/01/14 16:29:41 Connect: 14.964222ms
2017/01/14 16:29:41 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
2017/01/14 16:29:41 Name Lookup: 2.024µs
2017/01/14 16:29:41 Connect: 22.782755ms
</code></pre>

<p>二回目以降の名前解決が一瞬で終わっており、キャッシュされている様子が確認できますね。</p>

<p>最後に名前解決にPure Golangを使った結果です。</p>

<pre><code class="plain">2017/01/14 16:30:04 GET https://shogo82148.github.io/blog/2016/12/20/redis-fast-0-dot-19-released/
2017/01/14 16:30:04 Name Lookup: 18.279786ms
2017/01/14 16:30:04 Connect: 35.113831ms
2017/01/14 16:30:04 GET https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/
2017/01/14 16:30:04 Name Lookup: 1.628µs
2017/01/14 16:30:04 Connect: 16.364037ms
2017/01/14 16:30:04 GET https://shogo82148.github.io/blog/2016/11/23/qr-code/
2017/01/14 16:30:04 Name Lookup: 1.77µs
2017/01/14 16:30:04 Connect: 16.048895ms
</code></pre>

<h2>異様な高速化の理由</h2>

<p>さて、ここまでの結果で、たしかにDNSキャッシュの効果があることは確認できました。
しかし、デフォルトの状態ではKeep-Aliveが有効になっているため、
事前の予想の通り<strong>名前解決が行われるのは初回のみ</strong>ということがわかりました。
mattnさんのベンチマークにはKeep-Alive無効化処理は入っていないので、
DNSキャッシュの有無で差はでないはずです。</p>

<p>思うに、<code>for i := 0; i &lt; b.N; i++ {}</code>がないのが原因なのではないかと・・・。</p>

<pre><code class="go">package main

import (
    "testing"
    "time"
)

func BenchmarkHoge1(b *testing.B) {
    time.Sleep(1100 * time.Millisecond)
}

func BenchmarkHoge2(b *testing.B) {
    time.Sleep(997 * time.Millisecond)
}

func BenchmarkFuga1(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        time.Sleep(1100 * time.Millisecond)
    }
}

func BenchmarkFuga2(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        time.Sleep(997 * time.Millisecond)
    }
}
</code></pre>

<p>僕の手元では以下のような結果になりました。
(タイミングの問題なので、再現させるには数値の微調整が必要かも)</p>

<pre><code class="plain">BenchmarkHoge1-4           1    1104960703 ns/op
BenchmarkHoge2-4           2     500677841 ns/op
BenchmarkFuga1-4           1    1103413336 ns/op
BenchmarkFuga2-4           1    1001147782 ns/op
PASS
</code></pre>

<h2>nettの問題点</h2>

<p><a href="https://github.com/abursavich/nett">nett</a>の効果も確認できたし、
ベンチマークが異様に良い理由もわかったので、
ここで検証終了・・・といきたいところですが、
nettはあまりおすすめできないというのが僕の意見です。</p>

<h3>古い</h3>

<p>最終コミットが2年前と古いです。
まだGo1.7が出てないころなので、当然<code>context.Context</code>にも対応していないわけです。
そのため名前解決のタイムアウトやキャンセルを制御できません。
また、この検証でもhttptraceが使えなくて悲しい思いをしたので、
contextをサポートして欲しい・・・。</p>

<h3>DNSレコードのTTLを無視している</h3>

<p><code>nett.CacheResolver</code>のTTLには固定の時間しか設定できないようです。
DNSレコード自体にTTLが設定されているはずなので、本来であればそれを尊重するべきです。
短い時間のキャッシュであれば問題ないかもしれないですが、
アクセスした相手をDNS浸透問題(浸透いうな！)で悩ませてしまう可能性があるので、
できれば相手の意向を尊重したいところです。</p>

<h3>キャッシュクリアが無い</h3>

<p><code>nett.CacheResolver</code>のTTLの実装は
「前回の名前解決からの経過時間を見て再取得」という単純なものです。
ようするにガーベージコレクションがない状態です。
TTLが過ぎてもキャッシュから本当に消えるわけではないので、
多くのドメインを相手にする場合、メモリを食い尽くす可能性があります。</p>

<h3>2017/01/16追記: 同一ホストの名前解決の排他制御が甘い</h3>

<p>fujiwaraさんからの返信を受けて、ちょっと考えたことがあったので追記。</p>

<p><a href="https://twitter.com/fujiwara/status/820232828231163904">https://twitter.com/fujiwara/status/820232828231163904</a>">https://twitter.com/fujiwara/status/820232828231163904">https://twitter.com/fujiwara/status/820232828231163904</a></a></p>

<p><a href="https://twitter.com/fujiwara/status/820255789944143876">https://twitter.com/fujiwara/status/820255789944143876</a>">https://twitter.com/fujiwara/status/820255789944143876">https://twitter.com/fujiwara/status/820255789944143876</a></a></p>

<p>名前解決をキャッシュしたい理由は「用途はベンチマーク」「キャッシュは数秒で充分」とのことです。</p>

<p>ちょっとここからは推測になりますが・・・
リソースを徐々に消費してしばらくして突然死というパターンもあるので、
ベンチマークは短くとも1分以上続けるのが普通だと思います(Mackerel等の監視間隔も最小1分ですしね)。
にも関わらず、名前解決の負荷が数秒で落ち着くということは、Keep-Aliveは有効になっていたと推測できます。
それでも名前解決の負荷が問題になるということは、それなりに高い並列度だったのではないかと。</p>

<p>ここで問題になってくるのが、<strong>nettは同一ホストの問い合わせを排他制御していない</strong>という点です。
複数クライアントが同時にキャッシュの有無を確認→ほぼ同時にDNSに問い合わせ→キャッシュ更新(ここだけは排他制御される)
というケースが考えられます。
通常用途ならさほど問題にならないかなーと思ったのですが、
ベンチマークのように極端に並列度が高い場合、TTLが切れた瞬間だけDNSの負荷があがることになります。</p>

<p>ここは、<a href="https://twitter.com/methane">methane</a>さんがGo Conference 2016 Springで発表されていた
<a href="https://docs.google.com/presentation/d/1pSywpKera0huKCHDVGPVA2jQMvy-Pk8IR9s7AAVojDM/edit#slide=id.p">zero time cache pattern</a>
を使うのが賢い気がします。
(同じくmethaneさんの<a href="http://dsas.blog.klab.org/archives/cat_50043510.html">ISUCON6の予選参戦記事</a>も参照)</p>

<p>・・・と書きましたが、あくまでも推測です。
本来はnettを導入する前後でベンチマークを取って検証するべきなのですが、
さすがにこれをpublicなネットワークでやるとDOS攻撃になってしまいます。
DNSよくわからない・・・検証環境構築つらい・・・ので、とりあえずメモとして残しておきます。
だれか詳しい人の検証求む。</p>

<p>(以上、追記終わり)</p>

<h2>解決策は？</h2>

<p>mattnさんの記事には「Go 1.8 からは Resolver提供されるので、自前で簡単に名前引きのキャッシュを実装出来る」とありますが、
<strong>1.8にはユーザがResolverの動作をカスタマイズする機能はありません</strong>。
<a href="https://github.com/golang/go/blob/ecc4474341504f5893c8333dbb68c520dbe93ca5/src/net/lookup.go#L100">TODO: optional interface impl override hook</a>
な状態です。
マイルストーンをみる限り<a href="https://github.com/golang/go/issues/12503">1.9で入るらしい</a>(？)ので、それを待ちましょう・・・。</p>

<p>また、現時点では、netパッケージにDNSレコードのTTLを取得する機能はありません。
つまり先に挙げたnettの欠点をすべて補うには、<strong>「Pure GolangなDNSクライアントの独自実装」</strong>が必要となります。
<a href="https://github.com/golang/go/issues/16218">golang.org/x/net/dnsが入る予定</a>はあるようですが、
実装は未だ存在せず、入るバージョンも決まっていないようです。</p>

<p>つらい。どう考えても「楽な方法」ではない・・・。</p>

<p>Consulにも使われているという<a href="https://github.com/miekg/dns">miekg/dns</a>は見つけたので、誰か強い人よろしくお願いします。
(ちなみにgolang.org/x/net/dnsの候補として一度は挙がったものの、別実装で行くらしい)</p>

<h2>まとめ</h2>

<ul>
<li><a href="https://github.com/abursavich/nett">nett</a>は名前解決キャッシュに効果あり

<ul>
<li>しかしコードが古いので、Go1.7が出ている現状ではおすすめできない</li>
</ul>
</li>
<li>ResolverのカスタマイズはGo1.9かららしい(Go1.8ではまだ入らない)</li>
<li>暫定的な解決策は

<ul>
<li><a href="https://github.com/abursavich/nett">nett</a>を突っついてGo1.7対応をしてもらう(ただし、DNS浸透問題(浸透いうな！)解決にはDNSクライアントの実装が必要)</li>
<li><a href="https://github.com/miekg/dns">miekg/dns</a>を使ってDNSクライアントを頑張って独自実装(つらい)</li>
</ul>
</li>
<li>ベンチの際には<code>for i := 0; i &lt; b.N; i++ {}</code>をわすれずに</li>
</ul>


<p>http.Clientで名前解決結果cacheする楽な方法、現在も絶賛募集中です。</p>

<h2>おまけ</h2>

<p>この記事書くのにnetパッケージの中を探っていたら、
ソースコードの中に<a href="https://github.com/golang/go/blob/ecc4474341504f5893c8333dbb68c520dbe93ca5/src/net/lookup.go#L39">Gopher君を見つけた</a>。</p>

<p>ʕ◔ϖ◔ʔʕ◔ϖ◔ʔʕ◔ϖ◔ʔ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PerlとGolangで実行できるPolyglot書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang/"/>
    <updated>2016-04-05T12:27:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/04/05/polyglot-of-perl-and-golang</id>
    <content type="html"><![CDATA[<p>Rubyの会社をPerlの会社に変えてしまおう計画。
Golangのフリをして忍び込ませれば行けるのではという話になったので、
GoでもPerlでも実行できるコードを書いてみた。</p>

<!-- More -->


<p>出来上がったのがこちら。</p>

<pre><code class="plain">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>一番のポイントは<code>var (s=0/*==);</code>の行ですね。
Perlで解釈すると正規表現置換<code>s///</code>として解釈され、<code>/*</code>が無視されます。
Goで解釈すると変数<code>s</code>への代入として解釈され、<code>/*</code>がコメントとして扱われます。</p>

<p>あとはGoのキーワードをPerlが解釈できないので、ちょっと書き方を工夫します。</p>

<ul>
<li><code>package main</code> はGoでもPerlでも似たような意味で解釈されるのでそのまま</li>
<li>Goの <code>import</code>, <code>var</code> はPerlで解釈できないので、()を省略せずに書いてPerlの関数呼び出しっぽくする</li>
<li>省略可能なセミコロンをちゃんと書く</li>
</ul>


<p>GoとPerlのコードは分かれているのでどんな処理でも自由に書くことができますが、
<code>import</code> だけGoでもPerlでも解釈されてしまうというという制限があります。
<code>import</code> するパッケージが一個だけなら問題ないんですが、
複数書く場合は以下のように２個め以降をすべてドットインポートする必要があって男気あふれる感じです。
(Perlでは文字列結合として解釈される。Goでは<code>var</code>のあとに<code>import</code>かけないっぽいので、ここに押し込むしかない。)</p>

<pre><code class="plain">package main;
import (
  "fmt"
  . "math"
);
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu", Pi) }
</code></pre>

<p>もっと簡潔にかけないかな。</p>

<h2>追記</h2>

<p>シンタックスハイライトしてみたらわかりやすいかなと思ってやってみた。</p>

<p>Perlのシンタックスハイライト。</p>

<pre><code class="perl">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<p>Goのシンタックスハイライト。</p>

<pre><code class="go">package main;
import ("fmt");
var (s=0/*==);
sub import {}
sub var { print "Hello macotasu"; }
__END__
*/)
func main() { fmt.Println("Hello macotasu") }
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="https://golang.org/ref/spec">The Go Programming Language Specification</a></li>
<li><a href="http://d.hatena.ne.jp/sugyan/20110306/1299418878">polyglot 基礎の基礎</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
