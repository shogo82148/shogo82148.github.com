<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-10-28T21:15:36+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go言語の浮動小数点数のお話]]></title>
    <link href="https://shogo82148.github.io/blog/2017/10/28/golang-floating-point-number/"/>
    <updated>2017-10-28T20:12:48+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/10/28/golang-floating-point-number</id>
    <content type="html"><![CDATA[<p>元ネタ:</p>

<p><a href="https://twitter.com/RIORAO/status/922871767147749376">https://twitter.com/RIORAO/status/922871767147749376</a>">https://twitter.com/RIORAO/status/922871767147749376">https://twitter.com/RIORAO/status/922871767147749376</a></a></p>

<p><a href="https://twitter.com/RIORAO/status/923599110262874112">https://twitter.com/RIORAO/status/923599110262874112</a>">https://twitter.com/RIORAO/status/923599110262874112">https://twitter.com/RIORAO/status/923599110262874112</a></a></p>

<p>コンピューターで浮動小数点数を扱ったことのある人なら一度は経験する、
数学上の計算とコンピューター上の計算が合わない計算の一例ですね。</p>

<p>この件に関して、Go言語では正しく(=数学的な結果と同じように)計算できるとの情報が。</p>

<p><a href="https://twitter.com/inukirom/status/923721661408411650">https://twitter.com/inukirom/status/923721661408411650</a>">https://twitter.com/inukirom/status/923721661408411650">https://twitter.com/inukirom/status/923721661408411650</a></a></p>

<p>しかしながら、inukiromさんのこの推察、半分はあってますが、半分は間違っていると思います。
なぜGo言語でこのような結果になったのか、検証してみました。</p>

<!-- More -->


<h2>Goの数値定数の型について</h2>

<p>以前<a href="https://shogo82148.github.io/blog/2017/02/19/golang-compile-time-fib/">Go言語でコンパイル時フィボナッチ数列計算</a>で紹介した
<a href="https://qiita.com/sonatard/items/464a9d45c689386edfe1">Better C - Go言語と整数 #golang</a>にもあるように、
Goの定数には「型がない(場合がある)」「任意の精度で計算してくれる」という特徴があります。</p>

<p>このため、普通はどう考えてもオーバーフローしそうなこんな演算も・・・</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    var i uint64 = 31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 % 1000000007
    fmt.Println(i)
}
</code></pre>

<ul>
<li><a href="https://play.golang.org/p/FkMVpY2Fa3">play.golang.org/p/FkMVpY2Fa3</a></li>
</ul>


<p>型がない定数同士の演算は 162132938 と正しい答えを出してくれます。</p>

<p>しかし、明示的に型を指定すると、今度はオーバーフローしてしまいます。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    var i uint64 = uint64(31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679) % 1000000007
    fmt.Println(i)
}
</code></pre>

<pre><code>tmp/sandbox436519650/main.go:8:23: constant 31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 overflows uint64
</code></pre>

<h2>問題の計算</h2>

<p>さて、最初の問題に戻りましょう。
以下のコードで、0.1, 0.2, 0.3 は「型のない定数」なので、「任意の精度で計算して」くれます。
その計算結果を <code>float64</code> に変換すると全く同じ数値になるので、 <code>c</code> は <code>true</code> になります。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    a := 0.3 - 0.2
    b := 0.2 - 0.1
    c := a == b
    fmt.Println(c)
}
</code></pre>

<ul>
<li><a href="https://play.golang.org/p/X36rciE8by">play.golang.org/p/X36rciE8by</a></li>
</ul>


<p>一方、以下のように明示的に型を与えると、 <code>float64</code> の精度でしか計算してくれません。
この場合は他のほとんどの言語同様、 <code>c</code> は <code>false</code> となります。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    a := float64(0.3) - float64(0.2)
    b := float64(0.2) - float64(0.1)
    c := a == b
    fmt.Println(c)
}
</code></pre>

<ul>
<li><a href="https://play.golang.org/p/9_jKFfc5Hy">play.golang.org/p/9_jKFfc5Hy</a></li>
</ul>


<blockquote><p>おそらくGoはコンパイラがa=0.1とb=0.1に変換していると思われます。</p></blockquote>

<p>というわけで、先程のinukiromさんのこの推察ツイートのこの部分は正解です。</p>

<h2>計算されるのは実行時？コンパイル時？</h2>

<p>次にこんな二つのコードを用意して <code>GOSSAFUNC=main go run main.go</code> を実行し、
<a href="https://shinpei.github.io/blog/2016/08/13/what-ssa-brings-to-go-17">SSA</a>による最適化の様子を見てみます。
違いは <code>x</code>, <code>y</code>, <code>z</code> が <code>const</code> で宣言されているか、<code>var</code> で宣言されているか、だけです。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    var (
        x = 0.3
        y = 0.2
        z = 0.1
    )
    a := x - y
    b := y - z
    c := a == b
    fmt.Println(c)
}
</code></pre>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    const (
        x = 0.3
        y = 0.2
        z = 0.1
    )
    a := x - y
    b := y - z
    c := a == b
    fmt.Println(c)
}
</code></pre>

<p>結果は以下のツイートの通り。</p>

<p><a href="https://twitter.com/shogo82148/status/924156133522120705">https://twitter.com/shogo82148/status/924156133522120705</a>">https://twitter.com/shogo82148/status/924156133522120705">https://twitter.com/shogo82148/status/924156133522120705</a></a></p>

<p>最適化の結果コンパイル時に計算が行われ、(計算結果に多少の誤差はありますが)
<code>var</code> の場合でも <code>const</code> の場合でも <code>x</code>, <code>y</code>, <code>z</code> は消えてしまいました。</p>

<blockquote><p>constはコンパイル時に計算されますが、varは実行時に計算されるためです。</p></blockquote>

<p>そういうわけで、この部分は間違いです。
Goのコンパイラは賢いので、 <code>var</code> であってもコンパイル時に計算可能ならば計算してくれます。
(比較演算子は範囲外？みたいだけど・・・)</p>

<h2>任意の精度で計算の限界に迫る</h2>

<p>ここまでは <code>a</code> や <code>b</code> は <code>float64</code> という型を持っていました。
次に以下のように書き換えて <code>a</code> も <code>b</code> も「型の無い定数」にしてみましょう。
すると少し面白い結果が得られます。</p>

<pre><code class="go">package main

import (
    "fmt"
)

func main() {
    const a = 0.3 - 0.2
    const b = 0.2 - 0.1
    var c = a == b
    fmt.Println(c)
    fmt.Printf("%e\n", float64(a-b))
}
</code></pre>

<ul>
<li><a href="https://play.golang.org/p/T26lQ0Ajvw">play.golang.org/p/T26lQ0Ajvw</a></li>
</ul>


<pre><code>false
9.322926e-156
</code></pre>

<p><code>c</code> が <code>false</code> になってしまいました。
「任意の精度で計算」と言ってもコンピューター上の計算である以上、有効桁数には限界があります。
<code>a</code> と <code>b</code> の差が <code>9.322926e-156</code> になったことから、おそらく有効桁数150桁程度で計算していると考えられます。</p>

<p>ここでちょっとソースコードを覗いてみると・・・</p>

<ul>
<li><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/mpfloat.go#L18">mpfloat.go</a></li>
</ul>


<p>512bitの精度で計算しているようです。
<script type="math/tex">512 \times \log 2 = 154.1273577&hellip;</script> なので、有効桁数150桁程度という予想通りです。</p>

<h2>まとめ</h2>

<p>何事にも限界ってものがある。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go1.9から使える Monotonic Clocks を試してみた]]></title>
    <link href="https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock/"/>
    <updated>2017-06-26T09:21:42+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock</id>
    <content type="html"><![CDATA[<p>先日Go1.9beta1がリリースされました。</p>

<p><a href="https://twitter.com/golang/status/875117556595515392">https://twitter.com/golang/status/875117556595515392</a>">https://twitter.com/golang/status/875117556595515392">https://twitter.com/golang/status/875117556595515392</a></a></p>

<ul>
<li><a href="https://tip.golang.org/doc/go1.9">Go 1.9 Release Notes</a></li>
</ul>


<p>型エイリアスのサポート、<a href="https://tip.golang.org/pkg/math/bits/">math/bits</a>パッケージ、
<a href="https://tip.golang.org/pkg/sync/#Map">sync.Map</a>型など、
今回のアップデートでも便利そうな機能が追加されます。
詳しくは<a href="https://twitter.com/tenntenn">tenntenn</a>さんの<a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">Gopher Fest 2017参加レポート</a>をどうぞ。</p>

<p>今回のリリースノートを見て、個人的に注目しているのは<strong>Monotonic Clocksのサポート</strong>です。
他の機能追加はTwitterとかで見かけるけど、
Monotonic Clocksはなぜかあまり見ない・・・。
beta1がでて手軽に試せるようになったので、試してみました。</p>

<h2>Monotonic Clocks</h2>

<p>Go1.8以前で取得していた時刻は「wall clock」といい、<strong>現在の正しい時刻</strong>を知るために使います。
一方「monotonic clock」は、<strong>時間を計る</strong>ために使うものです。
Go1.9からは<code>time.Now</code>で取得できる時刻に「wall clock」と「monotonic clock」が含まれるようになります。</p>

<p><a href="https://tip.golang.org/pkg/time/#hdr-Monotonic_Clocks">timeパッケージのドキュメント</a>から
コード片を引用します。</p>

<pre><code class="plain">t := time.Now()
... operation that takes 20 milliseconds ...
u := time.Now()
elapsed := t.Sub(u)
</code></pre>

<p>上のコードで <code>elapsed</code> は 20ms となるはずですが、
実際はそうはならないケースがあります。
具体的には以下のようなケースです。</p>

<ul>
<li>ntpdなどによってOSの時刻が変更された場合</li>
<li>うるう秒が挿入・削除された場合</li>
</ul>


<p>Go1.9からはこのようなケースでも正しく時間を計ることができます。</p>

<h2>うるう秒を入れてみた</h2>

<p>うるう秒が入ったときの挙動が気になったので実際にやってみました。
セットアップが簡単になるよう<a href="http://jjy.nict.go.jp/tsp/link/leap.html">NICTのPerl版SNTP</a>のGolangポートを作ったので、
それを使って偽物のうるう秒を挿入してみます。</p>

<ul>
<li><a href="https://github.com/shogo82148/fakentpd">shogo82148/fakentpd</a></li>
</ul>


<p>インストールはいつものように<code>go get</code>です。
<code>-p</code>オプションで正のうるう秒挿入、<code>-n</code>オプションで負のうるう秒削除です(ほんとうは月末だけだけど、雑な実装のため毎日その日の終わりに挿入・削除されます)。
引数にRFC3339形式で日時を指定すると、その日時を起動時の日時として扱います。</p>

<p>たとえば今月末に正のうるう秒を挿入するには以下のように指定します。</p>

<pre><code class="bash"># 上位ntpd側
$ go get github.com/shogo82148/fakentpd
$ sudo fakentpd -p 2017-06-30T23:00:00Z # well known portを使うのでroot権限が必要
</code></pre>

<p>このSNTPサーバーを上位ntpdとして参照したクライアントを用意し、<code>date</code>コマンドで様子を確認してみましょう。
(ntpdの設定などの詳細は<a href="http://tkuchiki.hatenablog.com/entry/2015/06/19/083025">tkuchikiさんのうるう秒検証記事</a> を参照)</p>

<pre><code class="bash"># 下位ntpd側
$ while :; do date +'%Y-%m-%d %H:%M:%S.%3N'; usleep 100000; done
</code></pre>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.040
2017-06-30 23:59:59.141
2017-06-30 23:59:59.243
2017-06-30 23:59:59.344
2017-06-30 23:59:59.445
2017-06-30 23:59:59.547
2017-06-30 23:59:59.648
2017-06-30 23:59:59.749
2017-06-30 23:59:59.851
2017-06-30 23:59:59.952 #
2017-06-30 23:59:59.053 # うるう秒挿入！
2017-06-30 23:59:59.155
2017-06-30 23:59:59.256
2017-06-30 23:59:59.357
2017-06-30 23:59:59.458
2017-06-30 23:59:59.559
2017-06-30 23:59:59.661
2017-06-30 23:59:59.762
2017-06-30 23:59:59.863
2017-06-30 23:59:59.964
2017-07-01 00:00:00.066
</code></pre>

<p>うるう秒が挿入されたため、59.952から59.053へ時間が巻き戻っていることが確認できます。</p>

<p>これと同等のプログラムをGoで書いて挙動を確認します。
monotonic clockの確認をするために、一緒に起動時からの経過時間も表示するようにしました。</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func main() {
    start := time.Now()
    for {
        now := time.Now()
        fmt.Println(now, now.Sub(start))
        time.Sleep(100 * time.Millisecond)
    }
}
</code></pre>

<p><code>date</code>コマンドで検証したときと同様の条件で、
このプログラムを<strong>Go1.8で実行</strong>すると以下のような結果になりました。</p>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.038281905 +0000 UTC 32m42.970735711s
2017-06-30 23:59:59.138469005 +0000 UTC 32m43.070922811s
2017-06-30 23:59:59.238662875 +0000 UTC 32m43.171116681s
2017-06-30 23:59:59.338835875 +0000 UTC 32m43.271289681s
2017-06-30 23:59:59.439025825 +0000 UTC 32m43.371479631s
2017-06-30 23:59:59.539213666 +0000 UTC 32m43.471667472s
2017-06-30 23:59:59.63940551 +0000 UTC 32m43.571859316s
2017-06-30 23:59:59.739603502 +0000 UTC 32m43.672057308s
2017-06-30 23:59:59.839783301 +0000 UTC 32m43.772237107s
2017-06-30 23:59:59.939980591 +0000 UTC 32m43.872434397s #
2017-06-30 23:59:59.043820722 +0000 UTC 32m42.976274528s # うるう秒挿入！
2017-06-30 23:59:59.143987505 +0000 UTC 32m43.076441311s
2017-06-30 23:59:59.244160716 +0000 UTC 32m43.176614522s
2017-06-30 23:59:59.344336707 +0000 UTC 32m43.276790513s
2017-06-30 23:59:59.444546067 +0000 UTC 32m43.376999873s
2017-06-30 23:59:59.544717014 +0000 UTC 32m43.47717082s
2017-06-30 23:59:59.644876123 +0000 UTC 32m43.577329929s
2017-06-30 23:59:59.745050732 +0000 UTC 32m43.677504538s
2017-06-30 23:59:59.845230425 +0000 UTC 32m43.777684231s
2017-06-30 23:59:59.945421532 +0000 UTC 32m43.877875338s
2017-07-01 00:00:00.045595155 +0000 UTC 32m43.978048961s
</code></pre>

<p>うるう秒が挿入されたため、59.9から59.0に時刻が巻き戻っていることが確認できます。
それと同時に経過時刻も32m43.87sから32m42.97sと巻き戻ってしまいました。</p>

<p>おなじプログラムをGo1.9で実行してみます。</p>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.038322917 +0000 UTC m=+1962.019889237 32m42.01969158s
2017-06-30 23:59:59.138507805 +0000 UTC m=+1962.120074107 32m42.11987645s
2017-06-30 23:59:59.238704422 +0000 UTC m=+1962.220270727 32m42.22007307s
2017-06-30 23:59:59.338875317 +0000 UTC m=+1962.320441617 32m42.32024396s
2017-06-30 23:59:59.439066666 +0000 UTC m=+1962.420632996 32m42.420435339s
2017-06-30 23:59:59.539255964 +0000 UTC m=+1962.520822264 32m42.520624607s
2017-06-30 23:59:59.639446597 +0000 UTC m=+1962.621012897 32m42.62081524s
2017-06-30 23:59:59.739644525 +0000 UTC m=+1962.721210832 32m42.721013175s
2017-06-30 23:59:59.839827168 +0000 UTC m=+1962.821393501 32m42.821195844s
2017-06-30 23:59:59.94003045 +0000 UTC m=+1962.921596780 32m42.921399123s #
2017-06-30 23:59:59.043859649 +0000 UTC m=+1963.025425981 32m43.025228324s # うるう秒挿入！
2017-06-30 23:59:59.144008957 +0000 UTC m=+1963.125575282 32m43.125377625s
2017-06-30 23:59:59.244196844 +0000 UTC m=+1963.225763148 32m43.225565491s
2017-06-30 23:59:59.344388476 +0000 UTC m=+1963.325954758 32m43.325757101s
2017-06-30 23:59:59.444598162 +0000 UTC m=+1963.426164679 32m43.425967022s
2017-06-30 23:59:59.54473741 +0000 UTC m=+1963.526303708 32m43.526106051s
2017-06-30 23:59:59.644895019 +0000 UTC m=+1963.626461309 32m43.626263652s
2017-06-30 23:59:59.745084175 +0000 UTC m=+1963.726650464 32m43.726452807s
2017-06-30 23:59:59.845264185 +0000 UTC m=+1963.826830509 32m43.826632852s
2017-06-30 23:59:59.94546352 +0000 UTC m=+1963.927029829 32m43.926832172s
2017-07-01 00:00:00.04563023 +0000 UTC m=+1964.027196518 32m44.026998861s
</code></pre>

<p>うるう秒が挿入されるとwall clockは59.9から59.0に時刻が巻き戻っています。
しかし経過時刻は32m42.9から32m43.0と巻き戻りは発生していません。</p>

<p>Go1.9から<code>t.String()</code>がmonotonic clockの情報を返すようになるので、今回の検証ログにも表示されています。
monotonic clockも m=+1962.921596780 から m=+1963.025425981 と巻き戻りは発生していません。
(mの意味はよくわかってないけどプロセスの起動時間？)</p>

<h2>時刻を変えてみた</h2>

<p>検証用のfakentpdを止めて本物の上位ntpdを復活させると、
時刻の差が大きいため元の時刻に一気に修正されます。
この場合についても試してみました。</p>

<p>Go1.8で実行した場合。
時刻が戻ると同時に経過時間が-144hとおかしな値になってしまいました。</p>

<pre><code class="plain">(前略)
2017-07-01 00:30:20.802110381 +0000 UTC 4m52.493894502s
2017-07-01 00:30:20.9022538 +0000 UTC 4m52.594037921s
2017-07-01 00:30:21.002404752 +0000 UTC 4m52.694188873s #
2017-06-24 23:41:17.694698679 +0000 UTC -144h44m10.6135172s # 正しい時刻に戻った
2017-06-24 23:41:17.794881161 +0000 UTC -144h44m10.513334718s
2017-06-24 23:41:17.895024223 +0000 UTC -144h44m10.413191656s
</code></pre>

<p>Go1.9で実行した場合です。
wall clockは正しい時刻に戻りましたが、monotonic clockはその影響を受けず、
経過時間も正しく計算できています。</p>

<pre><code class="plain">2017-07-01 00:30:20.802071152 +0000 UTC m=+289.102414299 4m49.102265199s
2017-07-01 00:30:20.902234666 +0000 UTC m=+289.202577610 4m49.20242851s
2017-07-01 00:30:21.00238566 +0000 UTC m=+289.302728596 4m49.302579496s #
2017-06-24 23:41:17.694655753 +0000 UTC m=+289.402903206 4m49.402754106s # 正しい時刻に戻った
2017-06-24 23:41:17.794841932 +0000 UTC m=+289.503089435 4m49.502940335s
2017-06-24 23:41:17.895004891 +0000 UTC m=+289.603252211 4m49.603103111s
</code></pre>

<h2>ドリフトしてみた</h2>

<p>monotonic time は ntpd の干渉を全く受けないわけではなく、
ドリフトの補正は受けます。
せっかくなのでこれも確認してみました。</p>

<p>以下のコマンドで500PPM(Parts-per-Million)早く時刻が進むntpdとして動作します。
1PPMは100万分の1の誤差なので、500PPMでは2000秒(約33分)で1秒ズレます。</p>

<pre><code class="bash">$ sudo fakentpd -d 500
</code></pre>

<p>(ほんとうは2倍速！とかやってみたかったけど、さすがに偽ntpdだとバレて同期対象から外された)</p>

<p>起動からの経過時間を返すサーバーと、
サーバーとの時刻を比較するクライアントを用意します。</p>

<pre><code class="go">package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

func main() {
    start := time.Now()
    http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
        // 起動からの経過時間を返す
        fmt.Fprintf(w, "%.6f", time.Since(start).Seconds())
        log.Printf("%.6f", time.Since(start).Seconds())
    })
    http.ListenAndServe(":8080", nil)
}
</code></pre>

<pre><code class="go">package main

import (
    "io/ioutil"
    "log"
    "net/http"
    "os"
    "strconv"
    "time"
)

// サーバー側の経過時間を取得する
func get(u string) float64 {
    resp, _ := http.Get(u)
    defer resp.Body.Close()
    data, _ := ioutil.ReadAll(resp.Body)
    t, _ := strconv.ParseFloat(string(data), 64)
    return t
}

func main() {
    start := time.Now()
    startRemote := get(os.Args[1])
    for {
        time.Sleep(time.Second)
        end := time.Now()
        endRemote := get(os.Args[1])
        log.Printf("local:  %.6f", end.Sub(start).Seconds())
        log.Printf("remote: %.6f", endRemote-startRemote)
    }
}
</code></pre>

<p>ドリフト補正が反映されるよう数時間同期状態を保ったあと、
検証用プログラムを走らせると以下のような結果になりました。</p>

<pre><code class="plain">(前略)
2017/06/25 08:34:27 local:  1997.178992
2017/06/25 08:34:27 remote: 1998.176471
2017/06/25 08:34:28 local:  1998.179892
2017/06/25 08:34:28 remote: 1999.177970
2017/06/25 08:34:29 local:  1999.180993
2017/06/25 08:34:29 remote: 2000.179569
2017/06/25 08:34:30 local:  2000.182062
2017/06/25 08:34:30 remote: 2001.181200
</code></pre>

<p>起動から2000秒で1秒のズレ＝500PPMのドリフトがかかっていることが確認できました。</p>

<h2>まとめ</h2>

<p>Go1.9からサポートされるmonotonic clockについて検証を行いました。
うるう秒や時刻変更の影響を受けず、正しく経過時間を測定できることが確認できました。
また、ドリフトの調整は受けることも確認できました。</p>

<p>monotonic clockになると、methaneさんが紹介している<a href="http://dsas.blog.klab.org/archives/2016-09-20/isucon5q.html">zero time cache</a>の
実用性があがって利用しやすくなりますね。
さらに<a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">Cloudflare DNSがうるう秒にやられる</a>
こともなくなるので安心です。</p>

<p>注意点としては<code>t.String()</code>がmonotonic clockの情報を返すので、
時刻の出力を雑に<code>fmt.Println(t)</code>とかしていると出力が変わってしまうことくらいでしょうか。
(皆さんちゃんとFormatしてますよね？)</p>

<p>もうすぐ来年1月1日のうるう秒の有無が発表される時期です。
それまでにはGo1.9の正式版がリリースされているはずなので、
変な罠に引っかからないよう皆さんアップデートしましょう！</p>

<h2>参考</h2>

<ul>
<li><a href="http://tech.mercari.com/entry/gopherfest2017_report">Gopher Fest 2017参加レポート</a></li>
<li><a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">Gopher Fest 2017参加レポート(スライド)</a></li>
</ul>


<p><a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">https://www.slideshare.net/takuyaueda967/gopher-fest-2017</a>">https://www.slideshare.net/takuyaueda967/gopher-fest-2017">https://www.slideshare.net/takuyaueda967/gopher-fest-2017</a></a></p>

<ul>
<li><a href="http://jjy.nict.go.jp/tsp/link/leap.html">うるう秒とコンピュータクロック | NICT</a></li>
<li><a href="http://d.hatena.ne.jp/incarose86/20110505/1312522379">NTP設定</a></li>
<li><a href="http://tkuchiki.hatenablog.com/entry/2015/06/19/083025">2015年うるう秒の検証方法と検証結果 (Amazon Linux, CentOS)</a></li>
<li><a href="https://access.redhat.com/ja/node/1362753">Leap Second Insertion フラグを受信後にそのフラグを削除する</a></li>
<li><a href="http://www.geocities.co.jp/SiliconValley/6876/rfc2030j.htm">RFC2030 参考訳 IPv4・IPv6・OSI用簡易ネットワーク時刻プロトコル（SNTP）Version 4</a></li>
<li><a href="https://tools.ietf.org/html/rfc2030">RFC2030  Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI</a></li>
<li><a href="http://dsas.blog.klab.org/archives/2016-09-20/isucon5q.html">ISUCON6予選をトップ通過しました</a>

<ul>
<li>zero time cache について紹介されています</li>
</ul>
</li>
<li><a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">How and why the leap second affected Cloudflare DNS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ぼくのかんがえたさいきょうのcontext対応版go-mysql-driverをマージしてもらった]]></title>
    <link href="https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context/"/>
    <updated>2017-06-16T07:11:15+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/06/16/mysql-driver-and-context</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/go-sql-driver/mysql">go-sql-driver</a>に<code>context.Context</code>対応するプルリクエスト
<a href="https://github.com/go-sql-driver/mysql/pull/608">go-sql-driver/mysql#608</a>
を送って取り込んでもらいました！！
現時点ではまだ正式リリースされていませんが、次のリリース(version 1.4)から使えるようにはずです。
masterブランチではすでに使えるようになっているので、引き続き人柱募集中です。</p>

<p>コネクションプーリングを実装していて、自分も「<code>context.Context</code>サポートしたい！」というかたのために、
実装の概要をメモとして残しておきます。</p>

<!-- More -->


<h2>おおまかな仕組み</h2>

<ul>
<li>「<strong>contextの監視のみを行うgoroutine</strong>(以下、watcher goroutine)」をあらかじめ起動しておく</li>
<li>「<strong>やりたい処理を実際に実行するgoroutine</strong>(以下、executor goritune)」とchannelを経由して<code>context.Context</code>をやり取りする</li>
</ul>


<p>watcher goroutineがこの実装で一番重要な部分です。</p>

<h3>watcher goroutine の実装</h3>

<p>一番重要な watcher goroutine の実装例から見てみましょう
(実際には細かい最適化などが入るため、マージされたコードとは異なります)。</p>

<pre><code class="go">func (mc *mysqlConn) startWatcher() {
    // executor goritune と `context.Context` のやり取りをするための channel
    watcher := make(chan context.Context, 1)
    mc.watcher = watcher

    // executor goritune で処理が完了したことを知るための channel
    finished := make(chan struct{})
    mc.finished = finished

    // コネクションがCloseされたことを知らせるための channel
    mc.closech = make(chan struct{})

    // ここから watcher goroutine 本体
    go func() {
        for {
            // executor goritune から `context.Context` を待ち受ける
            var ctx context.Context
            select {
            case ctx = &lt;-watcher:
            case &lt;-mc.closech:
                // コネクションが Close されたので watcher gorutine を終了する
                return
            }

            // `context.Context` を監視する
            select {
            case &lt;-ctx.Done():
                // executor goritune を強制終了する
                mc.cancel(ctx.Err())
            case &lt;-finished:
                // 正常に処理が終了したので何もしない
            case &lt;-mc.closech:
                // コネクションが Close されたので watcher gorutine を終了する
                return
            }
        }
    }()
}
</code></pre>

<p><code>watcher</code>, <code>finished</code>, <code>closech</code> の3つの channel を経由して
executor goroutine と通信を行います。</p>

<h3>executor goroutine の実装</h3>

<p>executor goritune の実装例は以下のようになります。</p>

<pre><code class="go">// 何かやる
func (mc *mysqlConn) DoSomething(ctx context.Context) error {
    // watcher gorutineにctxを渡して監視してもらう
    if err := mc.watchCancel(ctx); err != nil {
        return err
    }

    // doSomthing()が実際に行いたい処理
    if err := mc.doSomthing(); err != nil {
        // キャンセルされたのか、ネットワークエラーで切断されたのか、を確認する
        if cerr := mc.canceled(); cerr != nil {
            return cerr
        }
        return err
    }

    // watcher gorutineに処理が終了したことを通知する
    mc.finish()

    return nil
}
</code></pre>

<p><code>mc.doSomthing()</code> が実際に行いたい処理なのですが、これに <code>ctx</code> を渡していないのがポイントです。
watcher goroutine に <code>ctx</code> の監視を任せているので、executor goroutine 側では監視しなくてもいいのです。</p>

<h3>executor goritune と watcher goroutine 間の通信</h3>

<p>executor goritune と watcher goroutine 間の通信は主に
<code>watcher</code> channel と <code>finished</code> channel が担当します。</p>

<pre><code class="go">func (mc *mysqlConn) watchCancel(ctx context.Context) error {
    // 実際の処理が始まるまえに、 `ctx` が終了していないか確認
    select {
    default:
    case &lt;-ctx.Done():
        return ctx.Err()
    }

    // watcher goroutineに渡す
    mc.watcher &lt;- ctx

    return nil
}

func (mc *mysqlConn) finish() {
    select {
    case mc.finished &lt;- struct{}{}:
    case &lt;-mc.closech:
    }
}
</code></pre>

<h3>キャンセルの実装</h3>

<p><code>context.Context</code>がキャンセルされたときに、executor goroutineを強制終了する処理は、
コネクションを強制的に <code>Close</code> することで行っています。
ちょっと強引な気はしますが、キャンセルされるような状況に陥った時点で正常な通信なんて出来ていないので、
まあいいかと、このような実装になっています。
もっと賢いキャンセルの方法があるかもしれませんが、キャンセルされない場合のほうが圧倒的に多いので、
余計なオーバーヘッドは避けたいというのもあります。</p>

<pre><code class="go">// キャンセルを実行する
func (mc *mysqlConn) cancel(err error) {
    // **コネクションを実際にCloseする前** にエラー内容を記録する
    mc.mu.Lock()
    mc.canceledErr = err
    mc.mu.Unlock()

    // 強制切断
    mc.cleanup()
}

// キャンセルされたか確認用
func (mc *mysqlConn) canceled() error {
    mc.mu.Lock()
    defer mc.mu.Unlock()
    return mc.canceledErr
}

func (mc *mysqlConn) cleanup() {
    // closeが2回以上実行されないようガード
    if atomic.SwapInt32(&amp;mc.closed, 1) != 0 {
        return
    }

    // (executor|watcher) goroutineに終了を通知
    close(mc.closech)

    // コネクションを切断
    mc.netConn.Close()
}
</code></pre>

<p>これらの関数は (executor|watcher) 両方の goroutine から呼ばれる可能性があるため、
以下の二点が非常に重要です。</p>

<ul>
<li>cancelでは <strong>コネクションを実際にCloseする前</strong> にエラー内容を記録する

<ul>
<li>これが逆だと executor がキャンセルを見逃してしまう場合がある</li>
</ul>
</li>
<li>sync package や sync/atomic package を使って <strong>goroutine-safe に書く</strong></li>
</ul>


<h2>FAQ(よくあるであろう質問)</h2>

<p>こっちの実装の方がいいんじゃないの？と実装中に自問自答した内容を
FAQと称して残しておきます。</p>

<h3>close(watcher)していないのはなぜ？</h3>

<p>最初は watcher goroutine の実装は以下のようになっていて、
<code>close(watcher)</code> で watcher goroutine を終了させようかと考えてました。</p>

<pre><code class="go">for ctx := range watcher {
    // context.Context監視処理
}
</code></pre>

<p>しかしこの実装では <code>mc.watcher &lt;- ctx</code> のところで <code>close</code> されていないかを毎回確認する必要があり、
channelを使うメリットが薄れてしまうので廃案となりました。</p>

<h3>close(finished)していないのはなぜ？</h3>

<p>監視の終了に <code>close(finished)</code> を使うという案も考えました。
しかしこの実装が廃案になったのには大きく二つの理由があります。</p>

<p>一つ目は「監視の終了は同期していなければならない」からです。
<code>close(finished)</code> を使った方法では executor goroutine が監視の終了を通知しても、
watcher goroutine が実際に監視を終了するタイミングは goroutine スケジューラの気分次第で遅れてしまう可能性があります。
すると watcher goroutine がクエリキャンセルしたときには、 executor goroutine では既に次のクエリが実行さており、
間違ったクエリをキャンセルしてしまうという事故が起こりえます。</p>

<p><code>finished &lt;- struct{}{}</code> を使った方法ならこれは起こりません。
executor goroutine が監視の終了を通知するのと、
watcher goroutine が実際に監視を終了するのとが同期しているので、
確実にキャンセルしたいクエリだけをキャンセルできます。</p>

<p>実際、PostgreSQLのGo driver実装は、最初 <code>close(finished)</code> で実装されていたものが、
<code>finished &lt;- struct{}{}</code> に置き換えられています(実装時には知らなくて、この記事を書いているときに知った)。</p>

<ul>
<li><a href="https://github.com/lib/pq/pull/535">Add context methods lib/pq#535</a></li>
<li><a href="https://github.com/lib/pq/pull/578">Fix race condition in query cancellation lib/pq#578</a></li>
</ul>


<p>二つ目は「channelの再利用ができない」という理由です。
一度 <code>close</code> した channel は <code>open</code> することはできないので、新規に channel を作る必要があります。
これにはメモリ確保が必要になるので、パフォーマンス面で不利になります。</p>

<h3>QueryContextの中でfinishを直接呼んでいないのはなぜ？</h3>

<p>QueryContext の実装をよく見てみると <code>rows.finish = mc.finish</code> しているだけで、
QueryContext の中では <code>finish</code> を呼んでいません。</p>

<ul>
<li><a href="https://github.com/go-sql-driver/mysql/blob/a825be04c652d01442384e9dcdf2cdc3f1eda67f/connection_go18.go#L87">QueryContext</a></li>
</ul>


<p>これはなぜかというと <code>QueryContext</code> の実行が終了した後、
rows の読み取り中に、<code>context.Context</code> がキャンセルされる場合があるからです。
たとえば以下のコードで、<code>rows.Err()</code> は <code>context.Canceled</code> になっているべきです。</p>

<pre><code class="go">ctx, cancel := context.WithCancel(context.Background())
rows, _ := dbt.db.QueryContext(ctx, "SELECT v FROM test")
rows.Next()
if err := rows.Scan(&amp;v); err != nil {
    panic(err)
}

cancel()
time.Sleep(100 * time.Millisecond)

rows.Next()
// rows.Err() は context.Canceled になっているべき
if err := rows.Err(); err != context.Canceled {
    panic(err)
}
</code></pre>

<p>この挙動は net/http を参考にしています。</p>

<pre><code class="go">package main

import (
    "context"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "net/http/httptest"
    "time"
)

func main() {
    log.SetFlags(log.LstdFlags | log.Lshortfile)

    // 1秒わざとレスポンスを返さないサーバー
    ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Context-Type", "text/plain")
        w.WriteHeader(200)
        fmt.Fprint(w, "Hello, ")
        w.(http.Flusher).Flush()
        time.Sleep(time.Second)
        fmt.Fprint(w, "client\n")
    }))
    defer ts.Close()

    req, err := http.NewRequest("GET", ts.URL, nil)
    if err != nil {
        log.Fatal(err)
    }

    // 0.5秒後にキャンセル
    ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
    go func() {
        time.Sleep(500 * time.Millisecond)
        cancel()
    }()
    defer cancel()

    req = req.WithContext(ctx)
    res, err := http.DefaultClient.Do(req)
    if err != nil {
        log.Fatal(err)
    }

    // ioutil.ReadAll は "context canceled" か "context deadline exceeded" で失敗する
    greeting, err := ioutil.ReadAll(res.Body)
    res.Body.Close()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%s", greeting)
}
</code></pre>

<h3>BeginTxの中ではfinishを直接呼んでいるのはなぜ？</h3>

<p><code>BeginTx</code> では <code>finish()</code> を呼んでいます。
<code>BeginTx</code>終了後にトランザクションがキャンセルされる場合を考えると、
<code>QueryContext</code> と同様に <code>tx.finish = mc.finish</code> となりそうですが、そうはなっていません。</p>

<p>これは database/sql が代わりに監視してくれていて、
<code>context.Context</code> がキャンセルされると自動的にRollbackしてくれるからです。</p>

<ul>
<li><a href="https://github.com/golang/go/blob/go1.8.3/src/database/sql/sql.go#L1435-L1447">Tx.awaitDone() (database/sql)</a></li>
</ul>


<p>実は rows にも同様の監視処理が入っているので勝手に <code>Close</code> してくれます。
しかし、packetの読み書きを <code>context.Context</code> 対応にする必要があり、
実装コスト・実行コストが大きそうだったので手を付けていません。</p>

<h2>まとめ</h2>

<p>executor goroutine と watcher goroutine を使った <code>context.Context</code> 対応の実装例を紹介しました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Re: GoとPythonとGrumpyの速度ベンチマーク]]></title>
    <link href="https://shogo82148.github.io/blog/2017/05/30/grumpy/"/>
    <updated>2017-05-30T17:53:32+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/05/30/grumpy</id>
    <content type="html"><![CDATA[<p><a href="http://qiita.com/kotauchisunsun/items/db28d14f7f13fb29e5f9">GoとPythonとGrumpyの速度ベンチマーク ～Googleのトランスパイラはどれくらい速い？～</a>という記事を拝読したのですが、
もう一歩踏み込んで検証して欲しい・・・。</p>

<blockquote><p>並列処理性能が優れているほか、PythonコードからGoのパッケージをPythonモジュールのように呼び出して利用することもできるという特徴がある。</p></blockquote>

<p>と<a href="http://news.mynavi.jp/news/2017/01/06/110/">Google、すごくスケールするPython実行環境をGoで開発</a>から引用しているのに、
この件に全く触れていないんですよね。
Twitterに呟いたってどうせ誰もやってくれない気がするので、自分で試してみました。</p>

<!-- More -->


<h2>環境</h2>

<p>この記事を書いている2017年5月30日現在の最新バージョンで検証しました。</p>

<ul>
<li>go version go1.8.3 darwin/amd64</li>
<li>CPython 2.7.13</li>
<li>Grumpy <a href="https://github.com/google/grumpy/tree/d8d01899f5eedf99602887567aaeb39a9154bf68">d8d01899f5</a></li>
</ul>


<p>Grumpyのインストール方法はREADMEにある通り。</p>

<pre><code class="bash">make
export GOPATH=$PWD/build
export PYTHONPATH=$PWD/build/lib/python2.7/site-packages
</code></pre>

<p>ただ個人的な環境問題としてPythonのバージョン管理に利用しているpyenvとの相性が悪いらしく、
pyenvが管理しているPythonへのパスを直接通す必要がありました。
(これがないとPythonスクリプトがなぜかbashに処理される。なんかこの問題最近Twitterで見たような・・・)</p>

<pre><code class="bash">export PATH=$HOME/.pyenv/versions/2.7.13/bin:$PATH
</code></pre>

<h2>モンテカルロ法を並列実行してみる</h2>

<p>まず、並列処理性能について検証してみましょう。
モンテカルロ法の各試行は独立しているので、並列実行にするのは容易です。
Python2のthreadingモジュールを使って並列実行してみましょう。</p>

<h3>コード</h3>

<pre><code class="python">#coding:utf-8
# モンテカルロ法 Pure Python 並列版
import threading
import random
import sys

class MyThread(threading.Thread):
    def __init__(self):
        super(MyThread, self).__init__()
        self.c = 0

    def run(self):
        r = random.Random()
        c = 0
        for _ in xrange(num):
            x = r.random()
            y = r.random()

            if x * x + y * y &lt;= 1.0:
                c += 1
        self.c = c


if __name__ == "__main__":
    num = int(sys.argv[1])
    para = int(sys.argv[2])

    threads = []
    for i in xrange(para):
        t = MyThread()
        t.start()
        threads.append(t)

    c = 0
    for t in threads:
        t.join()
        c += t.c

    print 4.0*c/(num*para)
</code></pre>

<p>並列度に比例した計算負荷がかかるようになってます。
理想的な並列処理が行えていれば、並列度に関わらず同じ実時間で実行されるはずです。</p>

<h3>CPythonでの結果</h3>

<p>CPythonでtimeを使って雑に測定した結果です。
並列度を4倍にしたら実行時間も4倍になっています。
また、実時間と実行時間が大体おなじで、まったく並列実行できていません。</p>

<pre><code class="plain"># 並列度1で実行した場合(CPython)
$ time python con_monte.py 300000 1
3.14529333333
real    0m0.358s
user    0m0.279s
sys 0m0.032s

# 並列度4で実行した場合(CPython)
$ time python con_monte.py 300000 4
3.14382666667
real    0m1.261s
user    0m1.124s
sys 0m0.441s
</code></pre>

<p>CPythonを利用しているひとにはおなじみの<a href="https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF%E3%83%AD%E3%83%83%E3%82%AF">グローバルインタプリタロック(GIL: Global Interpreter Lock)</a>の影響ですね。
CPythonのスレッドはI/Oの並列化には向いていますが、計算の並列化には向いていません。</p>

<h3>Grumpyでの結果</h3>

<p>次にGrumpyで測定した結果です。
並列度を4倍にしたところ、実行時間は2倍程度になりました。</p>

<pre><code class="plain"># 並列度1で実行した場合(Grumpy)
$ time ./con_monte_darwin_amd64 300000 1
3.1441733333333333
real    0m16.129s
user    0m16.787s
sys 0m0.125s

# 並列度4で実行した場合(Grumpy)
$ time ./con_monte_darwin_amd64 300000 4
3.1401766666666666
real    0m33.935s
user    1m45.979s
sys 0m0.654s
</code></pre>

<p>実時間4倍までは行かなかったので、理想的な並列計算には及ばないものの、
CPythonよりは並列化の効果が出ていそうです。
実のところ、Goも計算の並列化よりI/Oの並列化・並行処理のほうが得意なんですよね(GILよりはまし)。</p>

<p>手元の4コアのMBAで試した結果なので、コア数が多いとまた結果が変わってくるかもしれません。</p>

<h2>PythonからGoのライブラリを直接呼び出す</h2>

<p>次にGoのパッケージを呼び出す機能を試してみます。
Pythonのrandomパッケージではなく、Goのmath/randパッケージを使ってモンテカルロ法を実行してみます。</p>

<h3>コード</h3>

<pre><code class="python">#coding:utf-8
# モンテカルロ法 Python+Go 並列版
import threading
import random
import sys
from __go__.time import Now
from __go__.math.rand import New, NewSource


class MyThread(threading.Thread):
    def __init__(self):
        super(MyThread, self).__init__()
        self.c = 0

    def run(self):
        r = New(NewSource(Now().UnixNano()))
        c = 0
        for _ in xrange(num):
            x = r.Float64()
            y = r.Float64()

            if x * x + y * y &lt;= 1.0:
                c += 1
        self.c = c


if __name__ == "__main__":
    num = int(sys.argv[1])
    para = int(sys.argv[2])

    threads = []
    for i in xrange(para):
        t = MyThread()
        t.start()
        threads.append(t)

    c = 0
    for t in threads:
        t.join()
        c += t.c

    print 4.0*c/(num*para)
</code></pre>

<h3>Grumpyでの結果</h3>

<p>Grumpyでの実行結果です。
CPythonには遠く及ばないものの、もとのコードの8倍速くらいにはなりました。</p>

<pre><code class="plain"># 並列度1で実行した場合(Grumpy)
$ time ./con_monte_go_darwin_amd64 300000 1
3.1388133333333332
real    0m1.921s
user    0m2.006s
sys 0m0.029s

# 並列度4で実行した場合(Grumpy)
$ time ./con_monte_go_darwin_amd64 300000 4
3.143743333333333
real    0m4.115s
user    0m12.855s
sys 0m0.096s
</code></pre>

<h2>竹内関数を並列実行してみる</h2>

<p>竹内関数を並列実行した場合も試してみました。</p>

<h3>コード</h3>

<pre><code class="python">#coding:utf-8
# 竹内関数 Pure Python 並列版
import sys
import threading

def tak(x, y, z):
    if x &lt;= y:
        return y
    else:
        return tak(tak((x-1), y , z), tak((y-1), z , x), tak((z-1) , x, y))

class MyThread(threading.Thread):
    def __init__(self, a, b, c):
        super(MyThread, self).__init__()
        self.a = a
        self.b = b
        self.c = c
        self.result = 0

    def run(self):
        self.result = tak(self.a, self.b, self.c)

def main():
    a = int(sys.argv[1])
    b = int(sys.argv[2])
    c = int(sys.argv[3])
    para = int(sys.argv[4])

    threads = []
    for i in xrange(para):
        t = MyThread(a, b, c)
        t.start()
        threads.append(t)

    for t in threads:
        t.join()
        print t.result

if __name__=="__main__":
    main()
</code></pre>

<p>モンテカルロ法と同様に、理想的な並列処理が行えていれば、並列度に関わらず同じ実時間で実行されるはずです。</p>

<h3>CPythonでの結果</h3>

<p>CPythonでの結果です。
モンテカルロ法の場合と同様に、
並列度を4倍にしたら実行時間も4倍になっています。</p>

<pre><code class="plain"># 並列度1で実行した場合(CPython)
$ time python con_take.py 11 10 0 1
11
real    0m1.529s
user    0m1.498s
sys 0m0.028s

# 並列度4で実行した場合(CPython)
$ time python con_take.py 11 10 0 4
11
11
11
11
real    0m7.333s
user    0m6.620s
sys 0m2.565s
</code></pre>

<h3>Grumpyでの結果</h3>

<p>Grumpyでの結果です。</p>

<pre><code class="plain"># 並列度1で実行した場合(Grumpy)
$ time ./con_take_darwin_amd64 11 10 0 1
11
real    0m0.988s
user    0m0.988s
sys 0m0.018s

# 並列度4で実行した場合(Grumpy)
$ time ./con_take_darwin_amd64 11 10 0 4
11
11
11
11
real    0m2.031s
user    0m7.135s
sys 0m0.031s
</code></pre>

<p><strong>(なんかCPythonより早くなったぞ？？？？)</strong></p>

<p>最初に紹介した記事でも、
モンテカルロ法のベンチマークではCPythonがGrumpyの数十倍の速度で圧倒的勝利でしたが、
竹内関数のベンチマークではその差は縮まっています。
この程度であれば並列度を上げて物理で殴れば容易にGrumpyが逆転するでしょう。</p>

<p>(この検証で並列度1のときもGrumpy勝ったの謎だけど・・・)</p>

<h2>考察</h2>

<p>モンテカルロ法はCPythonのほうが圧倒的に速かったのに、
竹内関数ではGrumpyのほうが速かった(あるいは差が縮まった)という結果から、
「<strong>GrumpyからGoの関数を呼び出すオーバーヘッドが大きい</strong>」のではと推測しています。
モンテカルロ法のPure Python版でも圧倒的差が付いたのは、
<a href="https://github.com/google/grumpy/blob/d8d01899f5eedf99602887567aaeb39a9154bf68/lib/_random.py">Grumpyのrandomパッケージの実装が内部でGoのmath/randを呼んでいる</a>からです。</p>

<p>純粋なPure Pythonなコードであれば、Grumpyのシングルスレッド性能はCPythonより数倍遅い程度です。
最近のCPUコアたくさんなマシンであれば、GILのなくマルチスレッドを活かせるGrumpyが有利になると思います。
このことはグーグルのブログ記事「<a href="https://opensource.googleblog.com/2017/01/grumpy-go-running-python.html">Grumpy: Go running Python!</a>」でも触れられていますね。</p>

<h2>まとめ</h2>

<ul>
<li>Grumpyが非常に遅い<strong>のではなく</strong>、「GrumpyからGoの関数を呼び出すオーバーヘッドが大きい」(推測)</li>
<li>Grumpyのシングルスレッド性能はCPythonより数倍遅い程度</li>
<li>並列処理性能ではGrumpyが有利</li>
<li>そもそもGrumpyの目的は計算速度を上げることではないので、計算速度向上を求めている人は他の手法を模索しましょう</li>
</ul>


<p>今回の検証に使用したソースコード、Grumpyによるトランスパイルの結果、各種プラットフォームのバイナリをGithubにあげておきました。</p>

<ul>
<li><a href="https://github.com/shogo82148/grumpy-test">shogo82148/grumpy-test</a></li>
</ul>


<p>さらに検証を進めたい方は参考にどうぞ。</p>

<h2>参考</h2>

<ul>
<li><a href="https://opensource.googleblog.com/2017/01/grumpy-go-running-python.html">Grumpy: Go running Python!</a></li>
<li><a href="http://news.mynavi.jp/news/2017/01/06/110/">Google、すごくスケールするPython実行環境をGoで開発</a></li>
<li><a href="http://qiita.com/kmry2045/items/998250b3d430d82594c2">Grumpy(Go running Python)を試してみた。</a></li>
<li><a href="http://qiita.com/kotauchisunsun/items/db28d14f7f13fb29e5f9">GoとPythonとGrumpyの速度ベンチマーク ～Googleのトランスパイラはどれくらい速い？～</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String::RandomのGo移植を書いてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2017/05/04/go-rerand/"/>
    <updated>2017-05-04T10:57:37+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/05/04/go-rerand</id>
    <content type="html"><![CDATA[<p>golangkyotoで<a href="http://blog.yux3.net/entry/2017/05/01/014200">String::RandomのGo移植についての発表</a>があったと聞き、
これに対抗して以前途中まで書いていたString::RandomのGo移植をちょっといじって公開しました。</p>

<ul>
<li><a href="https://github.com/shogo82148/go-rerand">shogo82148/go-rerand</a></li>
</ul>


<!-- More -->


<h2>背景</h2>

<h3>ナイーブな実装の問題点</h3>

<p>実はgolangkyoto以前にもGoの正規表現エンジンを使ってランダムな文字列を生成する試みはあって、
たしかにこれは面白そうだと記事を読んでいました。</p>

<ul>
<li>「<a href="http://ymotongpoo.hatenablog.com/entry/2014/12/21/192304">Goの正規表現エンジンを使ってファジング用ツールを書いてみる</a>」</li>
</ul>


<p>しかし、gocha同様、この実装では文字列の長さが幾何分布に従うため、短い文字が多めにでてしまいます。</p>

<pre><code class="plain">% gocha -n 100000 'a*' | sort | uniq -c
50054
24894 a
12633 aa
6278 aaa
2994 aaaa
1517 aaaaa
 809 aaaaaa
 400 aaaaaaa
 206 aaaaaaaa
 109 aaaaaaaaa
  54 aaaaaaaaaa
  22 aaaaaaaaaaa
  15 aaaaaaaaaaaa
   7 aaaaaaaaaaaaa
   4 aaaaaaaaaaaaaa
   3 aaaaaaaaaaaaaaa
   1 aaaaaaaaaaaaaaaa
</code></pre>

<h3>正規表現のパターンを数え上げとその問題点</h3>

<p>この問題を解決するために
「この先何パターンあるかを調べておけば、正規表現が表す文字列の集合からランダムに文字列を取り出せるのでは？」
と考え、golangkyoto以前からちょこちょこ実装を進め、不完全ながらも一応動作するところまでは書いていたのです。
有向グラフの経路数えあげ問題なので、メモ化再帰を使って頑張れば解けます。
少々面倒ですが、<a href="https://www.youtube.com/watch?v=Q4gTV4r0zRs">おねえさんの問題</a>と比べれば簡単です。</p>

<p>パターンを数え上げる都合上、組み合わせが無限にある <code>a*</code> ような正規表現は扱えません。
<code>a{1,10}</code> のように明示的に範囲を指定する必要があります。
たとえば <code>a{1,10}</code> は10パターン組み合わせがあるので、20万個ランダムに生成すると、それぞれのパターンがおおよそ2万個ずつ生成されます。
(<code>-d</code> オプションについては後述)</p>

<pre><code class="plain">$ rerand -d -n 200000 'a{1,10}' | sort | uniq -c
20153 a
19863 aa
19899 aaa
19908 aaaa
19975 aaaaa
20000 aaaaaa
20081 aaaaaaa
20021 aaaaaaaa
20072 aaaaaaaaa
20028 aaaaaaaaaa
</code></pre>

<p><code>[ab]{1,3}</code>のような正規表現でも、それぞれのパターンがおおよそ同じ数だけ生成されます。</p>

<pre><code class="plain">$ rerand -d -n 200000 '[ab]{1,3}' | sort | uniq -c
14299 a
14249 aa
14215 aaa
14257 aab
14192 ab
14340 aba
14317 abb
14209 b
14213 ba
14332 baa
14228 bab
14355 bb
14634 bba
14160 bbb
</code></pre>

<p>これはこれで意図した挙動なのですが、
1文字のパターン数に比べて、3文字のパターン数が非常に多いため、相対的に短い文字列が出現しにくくなってしまいます。
「これは本当にユーザーが望んだものなのだろうか・・・？」と疑問に思ってしまい、
うまい解決策が思いつかないままずっと放置していました。</p>

<h2>文字グループの同一視</h2>

<p>ここまで実装では正規表現の定義に厳密に従い「<code>[ab]</code>は<code>a</code>と<code>b</code>にマッチするので2パターン」と解釈していましたが、
「<code>[ab]</code>のような1文字にマッチするパターンは全部1パターン」と緩い解釈にするようにしました。
<code>-d</code>オプションはこの挙動を制御するためのオプションです。</p>

<p>デフォルトの挙動は「1文字にマッチするパターンは全部1パターン」です。
さきほどと同じ<code>[ab]{1,3}</code>で、<code>-d</code>オプションを外しデフォルトの設定で文字列生成すると以下のようになります。</p>

<pre><code class="plain">$ rerand -n 200000 '[ab]{1,3}' | sort | uniq -c
33463 a
16432 aa
8392 aaa
8206 aab
16806 ab
8334 aba
8403 abb
33242 b
16549 ba
8393 baa
8372 bab
16644 bb
8376 bba
8388 bbb
</code></pre>

<p><code>a</code>や<code>b</code>が多めに出ているような気がしますが、
文字列長別に集計するとおおよそ同じ回数だけ出現していることが確認できます。</p>

<pre><code class="plain">$ rerand -n 200000 '[ab]{1,3}' | perl -nE 'chomp; say length' | sort -n | uniq -c
66769 1
67036 2
66195 3
</code></pre>

<p>これで少しはユーザーフレンドリーになったはず(？)</p>

<h2>ベンチマーク</h2>

<p>ベンチマークの結果も貼っておきます。
coffeescriptは <a href="https://cho45.stfuawsc.com/String_random.js/demo.html#%5B%E3%82%AB%E3%82%B3%E3%83%B5%E3%81%8B%5D%5B%E3%83%83%E3%83%BC%5D%7B1%2C3%7D%3F%5B%E3%83%95%E3%83%92%E3%81%B5%E3%81%B2%5D%7B1%2C3%7D%5B%E3%82%A3%E3%82%A7%E3%83%BC%5D%7B1%2C3%7D%5B%E3%82%BA%E3%82%B9%5D%5B%E3%83%89%E3%82%AF%E3%82%B0%E3%83%A5%5D%5B%E3%83%AA%E3%82%A4%5D%5B%E3%83%97%E3%83%96%E3%81%B7%E3%81%B6%5D%7B1%2C3%7D%5B%E3%83%88%E3%83%89%E3%82%A9%5D%7B1%2C2%7D">コーフィースクリップトの発音を生成する</a>ベンチマーク、
telephoneは<code>\d{2,3}-\d{3,4}-\d{3,4}</code>で電話番号っぽい文字列を生成するベンチです。</p>

<pre><code class="plain">$ go test -run none -bench . -benchmem ./...
BenchmarkGenerator/coffeescript-4            1000000          1737 ns/op          81 B/op          2 allocs/op
BenchmarkGenerator/[あ-お]{10}-4               2000000           845 ns/op          80 B/op          2 allocs/op
BenchmarkGenerator/[[:alpha:]]-4             5000000           274 ns/op          36 B/op          2 allocs/op
BenchmarkGenerator/\S-4                      5000000           292 ns/op          40 B/op          2 allocs/op
BenchmarkGenerator/\S{10}-4                  1000000          1568 ns/op          80 B/op          2 allocs/op
BenchmarkGenerator/\pN-4                     5000000           304 ns/op          39 B/op          2 allocs/op
BenchmarkGenerator/\p{Greek}-4               5000000           299 ns/op          39 B/op          2 allocs/op
BenchmarkGenerator/telephone-4               2000000           886 ns/op          48 B/op          2 allocs/op
BenchmarkRuneGenerator/[a]-4                300000000            4.24 ns/op        0 B/op          0 allocs/op
BenchmarkRuneGenerator/[a-z]-4              30000000            42.7 ns/op         0 B/op          0 allocs/op
BenchmarkRuneGenerator/[a-zA-Z0-9]-4        10000000           118 ns/op           0 B/op          0 allocs/op
PASS
ok      github.com/shogo82148/go-rerand 20.013s
?       github.com/shogo82148/go-rerand/cmd/rerand  [no test files]
BenchmarkGocha/coffeescript-4             300000          3967 ns/op        1090 B/op         34 allocs/op
BenchmarkGocha/[あ-お]{10}-4               1000000          1951 ns/op         328 B/op         15 allocs/op
BenchmarkGocha/[[:alpha:]]-4             5000000           323 ns/op          64 B/op          4 allocs/op
BenchmarkGocha/\S-4                      5000000           394 ns/op         128 B/op          5 allocs/op
BenchmarkGocha/\S{10}-4                   500000          3353 ns/op        1288 B/op         35 allocs/op
BenchmarkGocha/\pN-4                     1000000          1988 ns/op        4096 B/op         10 allocs/op
BenchmarkGocha/\p{Greek}-4               1000000          1122 ns/op        2048 B/op          9 allocs/op
BenchmarkGocha/telephone-4               1000000          1998 ns/op         288 B/op         14 allocs/op
PASS
ok      github.com/shogo82148/go-rerand/gocha_test  14.405s
BenchmarkStrRand/coffeescript-4              1000000          1828 ns/op         262 B/op         11 allocs/op
BenchmarkStrRand/[あ-お]{10}-4                 1000000          1189 ns/op         208 B/op          9 allocs/op
BenchmarkStrRand/\S-4                       20000000            72.9 ns/op         0 B/op          0 allocs/op
BenchmarkStrRand/\S{10}-4                    1000000          1097 ns/op          64 B/op          9 allocs/op
BenchmarkStrRand/telephone-4                 1000000          1409 ns/op          58 B/op         10 allocs/op
PASS
ok      github.com/shogo82148/go-rerand/strrand_test    7.136s
</code></pre>

<p>テストケースにもよりますが、Songmuさんのstrrandと同等かちょっと速い程度の性能です(シンプルな正規表現ではstrrandが速いこともある)。
Twitterには「Gocha速い！」みたいなことが流れてましたが、僕の手元での検証ではstrrandの方が高速でした。
どうも<a href="https://github.com/t-mrt/gocha/pull/3">ベンチマークの使い方間違っていた</a>っぽいですね・・・。</p>

<p>ちなみにこのベンチマークには正規表現をパースする処理は入っていません。
(どう考えてもstrrandに負けるのは目に見えている)
たいていのケースで初期化一回なので気にしない気にしない。</p>

<h2>グローバルなmath/rand関数の扱い</h2>

<p>go-rerandを作る際、他の実装も参考にしたのですが、
Seedの初期化のタイミングがまちまちで、少し気になりました。</p>

<ul>
<li>fuzzingo: <code>rand.Intn</code>を使う直前(！)</li>
<li>strrand: init関数内</li>
<li>gocha: Newの中</li>
</ul>


<p>Seedの初期化は本来一回だけでいいので、「<code>rand.Intn</code>を使う直前」や「Newの中」で行うのは無駄です。
init関数内でやる方法がベターですが、<code>math/rand</code>を使うライブラリを複数importしている場合、
結局何度もSeedの初期化が行われてしまいます。
ライブラリ利用者の手間は増えますが、ライブラリの中ではなく<code>main.go</code>の中でやってほしい！というのが僕の意見です。</p>

<pre><code class="go">// main.goの中でやってほしい！
func init() {
    rand.Seed(time.Now().UnixNano())
}
</code></pre>

<p>ベストなのは <strong>ライブラリではグローバルなmath/rand関数を使わない！</strong> ことです。
rerandでは以下のように<code>rand.New</code>を使って、グローバルな関数は使っていません。</p>

<pre><code class="go">r = rand.New(rand.NewSource(time.Now().UnixNano()))
</code></pre>

<p>goroutine-unsafeになってしまうので、同期処理を自前で書く必要があるのが難点です。
その代わり、ロックの粒度が細かく調整できるので、並列処理の効率は上がるはずです(たぶん)。</p>

<p>また、テストの際にSeedを固定できるので便利です。</p>

<pre><code class="go">r = rand.New(rand.NewSource(1))
</code></pre>

<h2>gocha互換オプション</h2>

<p><code>-prob 0.5</code>でGochaと同じ挙動になるはずです。
<code>a*</code>のような無限長の正規表現も扱えます。
数値をいじることで文字列の長さの分布を調整可能です。</p>

<h2>まとめ</h2>

<ul>
<li>Go版String::Randomを作った</li>
<li><strong>ライブラリではグローバルなmath/rand関数をなるべく使わないでほしい！</strong></li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://ymotongpoo.hatenablog.com/entry/2014/12/21/192304">Goの正規表現エンジンを使ってファジング用ツールを書いてみる</a></li>
<li><a href="https://github.com/ymotongpoo/fuzzingo">ymotongpoo/fuzzingo</a></li>
<li><a href="http://www.songmu.jp/riji/entry/2015-03-28-strrand.html">String::Randomのgolang移植書いた</a></li>
<li><a href="https://github.com/Songmu/strrand">Songmu/strrand</a></li>
<li><a href="http://blog.yux3.net/entry/2017/05/01/014200">golangkyoto 「そうだ、 Go 京都」で「Go に String::Random を移植した話」というタイトルで発表した</a></li>
<li><a href="https://github.com/t-mrt/gocha">t-mrt/gocha</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
