<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-01-22T23:00:48+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[travis-ciでC++11のテストをする]]></title>
    <link href="https://shogo82148.github.io/blog/2014/05/22/use-cpp11-in-travis/"/>
    <updated>2014-05-22T23:34:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2014/05/22/use-cpp11-in-travis</id>
    <content type="html"><![CDATA[<p>今 C++ を書くなら C++11 だよね！と言うわけでC++11の新機能を使ってコードを書いたので、
<a href="https://travis-ci.org/">travis-cli</a>でテストしたらFAIL。</p>

<pre><code class="plain">$ g++ -std=gnu++0x hogehoge.cpp
sorry, unimplemented: non-static data member initializers
</code></pre>

<p>unimplemented・・・だと・・・。</p>

<p>頑張って動かしてみたのでメモ。</p>

<!-- More -->


<h2>autoconf の設定をする</h2>

<p>autotoolsを使っていたので、
C++11 に対応しているかのチェックを追加しておきます。</p>

<p><a href="https://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html">ax_cxx_compile_stdcxx_11.m4</a>をダウンロードし、
configure.ac でm4ファイルをダウンロードするようにしておきます。</p>

<pre><code class="plain configure.ac">m4_include([m4/ax_cxx_compile_stdcxx_11.m4])
AX_CXX_COMPILE_STDCXX_11
AC_LANG([C++])
</code></pre>

<h2>travis.yaml を設定する</h2>

<p>ぐぐったら<a href="http://stackoverflow.com/questions/22111549/travis-ci-with-clang-3-4-and-c11">stackoverflowでやり方を見つけました</a>。
標準でテストに使われるコンパイラは古いようなので、新しいバージョンのものをインストールするように設定します。</p>

<pre><code class="plain">language: cpp

compiler:
  - clang
  - gcc

before_install:
  # g++4.8.1
  - if [ "$CXX" == "g++" ]; then sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test; fi

  # clang 3.4
  - if [ "$CXX" == "clang++" ]; then sudo add-apt-repository -y ppa:h-rayflood/llvm; fi

  - sudo apt-get update -qq

install:
  # g++4.8.1
  - if [ "$CXX" = "g++" ]; then sudo apt-get install -qq g++-4.8; fi
  - if [ "$CXX" = "g++" ]; then export CXX="g++-4.8"; fi

  # clang 3.4
  - if [ "$CXX" == "clang++" ]; then sudo apt-get install --allow-unauthenticated -qq clang-3.4; fi
  - if [ "$CXX" == "clang++" ]; then export CXX="clang++-3.4"; fi
</code></pre>

<p>これで、clangとgccでテストが走るようになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Test を使ってC++のテストしてみた]]></title>
    <link href="https://shogo82148.github.io/blog/2014/05/18/test-with-google-test/"/>
    <updated>2014-05-18T21:24:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2014/05/18/test-with-google-test</id>
    <content type="html"><![CDATA[<p>C++ なライブラリを書こうと思い、C++のテストってどうやるんだろうと調べたメモ。
テストフレームワークとして <a href="https://code.google.com/p/googletest/">Google C++ Testing Framework</a> を使用、
コンパイルにはautotoolを使ってtravis-ciでテストするところまでやってみました。</p>

<p>やってみた結果→
<a href="https://github.com/shogo82148/cpp-test">cpp-test</a></p>

<!-- More -->


<h2>Testを書く</h2>

<p>Google Test の<a href="http://opencv.jp/googletestdocs/primer.html">入門ガイド</a>に書いてあったテストをコピペしてきました。</p>

<pre><code class="c++ test/factorial.cpp">#include "gtest/gtest.h"

int Factorial(int n);

TEST(FractionTest, hoge) {
    EXPECT_EQ(1, Factorial(1));
    EXPECT_EQ(2, Factorial(2));
    EXPECT_EQ(6, Factorial(3));
    EXPECT_EQ(40320, Factorial(8));
}
</code></pre>

<p>テストの対象となる関数はこちら。</p>

<pre><code class="c++ src/factorial.cpp">// calculate 1 * 2 * 3 * ... * n
int Factorial(int n) {
    if(n == 0) return 1;
    return n * Factorial(n - 1);
}
</code></pre>

<h2>テスト用実行ファイルのビルドをする</h2>

<p>せっかくならしっかりしたものをつくろうと、Autotoolsを使ってビルドしてみました。
<a href="http://www.spa.is.uec.ac.jp/~kinuko/slidemaker/autotools/">新しめの Autotools (Autoconf&amp;Automake) を使ってみよう</a> を参考に
Makefileのひな形を書いていきます。</p>

<p><a href="http://kikuchy.hatenablog.com/entry/2014/01/12/Google_Test_%E3%81%A8_Travice_CI_%E3%81%A7%E3%80%81C%E8%A8%80%E8%AA%9E%E3%81%A7%E6%9B%B8%E3%81%84%E3%81%9F%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E7%B6%99%E7%B6%9A%E7%9A%84%E3%82%A4">Google Test と Travice CI で、C言語で書いたライブラリの継続的インテグレーションをしてみた結果</a>
ではGoogle Testをシステムにインストールしていますが、
システムへのインストールは推奨されていないのと、手元で動かすのが面倒だったので
<a href="https://code.google.com/p/googletest/wiki/V1_6_AdvancedGuide#Fusing_Google_Test_Source_Files">Fused Source File</a>
を作ってGoogle Testを自分のプロジェクトに同梱しちゃいました。</p>

<p>Google Testのプロジェクトで<code>python fuse_gtest_files.py OUTPUT_DIR</code> を実行すると
<code>gtest/gtest.h</code> と <code>gtest/gtest-all.cc</code> が作られるので、
この２つのファイルを自分のプロジェクトにコピーしてきます。
あとは Makefile.am でこれらのファイルをコンパイル＆リンクするように設定します。
自分のプロジェクトでは使っていなくても、Google Test のコンパイルには pthread が必要なので忘れずに。
(clangでは無くても動くらしく、clangで試していたらgccで動かなくてちょっとはまった)</p>

<pre><code class="makefile test/Makefile.am">TESTS = factorial_test
check_PROGRAMS = factorial_test
factorial_test_SOURCES = factorial.cpp gtest_main.cc gtest-all.cc
factorial_test_LDADD = ../src/libfactorial.a
factorial_test_LDFLAGS = -pthread
</code></pre>

<p><code>make check</code> でテストが走るようになります。
Google Test のソースがプロジェクトに含まれているので、
新しくプログラムをインストールしたり、特別な設定をしたりといったことは必要ありません。</p>

<h2>travis-ci でテストする</h2>

<p>travisのC++のテストは、標準で<code>./configure &amp;&amp; make &amp;&amp; make test</code>を実行してくれますが、
autotoolsで作ったMakefileだと上手く動かないので以下のように.travis.ymlを設定します。</p>

<pre><code class="yaml .travis.yml">language: cpp
script: autoreconf -fi &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make check
</code></pre>

<p>gnuなプロジェクトのお作法にしたがって、以下のように書き換えてあります。</p>

<ul>
<li>configureスクリプトはautotoolsで自動生成されるファイルなのでレポジトリには入れず、テスト前に生成する</li>
<li>make check でテストが走るのが普通らしい</li>
</ul>


<p>configureスクリプトを自動生成するのでautoconfのバージョンに注意してください。
autoconfは2014/05/18現在2.69が最新版ですが、travis-ciは2.68がインストールされているようです。
最新版のautoconfでconfigure.acのひな形を作ると<code>AC_PREREQ([2.69])</code>のように必要バージョンが設定されてしまい、
テストのときにconfigureファイルを作れなくて死にます。
バージョン指定を削除するか、古いバージョンに書き換えましょう。</p>

<p>C++のお作法がよくわかっていないですが、ちょっとずつ頑張っていきます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CやC++でのincludeの優先順位]]></title>
    <link href="https://shogo82148.github.io/blog/2012/06/26/c-include/"/>
    <updated>2012-06-26T11:13:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2012/06/26/c-include</id>
    <content type="html"><![CDATA[<p>こんにちは、gccのオプションを十個も言えない、非人のshogoです。</p>

<p>工藤氏作の<a href="http://chasen.org/~taku/software/TinySVM/">TinySVM</a>で遊ぼうとしていたところ、
ヘッダファイルの読み込み順序ではまったのでメモ。</p>

<!-- more -->


<h2>2つのinclude文</h2>

<p>皆さんご存知の通り、Cプリプロセッサの#include文ではファイルの指定方法が2種類あります。</p>

<ol>
<li>&#035;include &lt;somefile&gt; // システムにインストールされたライブラリを使う場合</li>
<li>&#035;include &quot;somefile&quot; // 自作のヘッダファイルなどを読み込む場合</li>
</ol>


<p>大抵はコメントで書いたような使い分けをするんじゃないかと思います。
両者の違いはファイルの検索対象となるディレクトリの違いにあります。
前者はコンパイラが知っているディレクトリのみを検索するのに対して、
後者はカレントディレクトリを検索したのち、&lt;>と同じディレクトリを検索します。</p>

<p>コンパイラが知っているディレクトリは具体的に書くと次のようになっています。</p>

<ol>
<li>-I オプションで指定されたディレクトリ</li>
<li>環境変数 C&#095;INCLUDE&#095;PATH や CPLUS&#095;INCLUDE&#095;PATH で指定されたディレクトリ</li>
<li>システムによって予め決められたディレクトリ(/usr/local/includeとか)</li>
</ol>


<p>上にあるものほど優先順位高く、同名のファイルがあった場合、優先順位の高いディレクトリにあるものが読み込まれます。</p>

<h2>標準のヘッダを使いたい</h2>

<p>次のようなCのプログラムを考えてみます。</p>

<pre><code class="c">/* sample.c */
#include &lt;stdio.h&gt; // 標準ヘッダのstdio.hを取り込んでほしい！
#include "stdio.h" // ../userheaderディレクトリ内のstdio.hを取り込んでほしい！
</code></pre>

<p>最初のincludeではシステムに用意された標準ヘッダのstdio.hを、
2つ目のincludeでは自前で用意したstdio.hを読み込もうとしています。
しかし、自前で用意したstdio.hはuserheaderという別ディレクトリにあるので
このままでは参照できません。</p>

<p>別ディレクトリにあるヘッダファイルを参照する場合、一般的には-Iオプションを使って次のようにコンパイルすると思います。</p>

<pre><code class="bash">gcc -I../userheader sample.c
</code></pre>

<p>しかしこの例の場合はこの方法は上手く行きません。
&lt;>で囲った場合も"&ldquo;で囲った場合も、カレントディレクトリにはstdio.hは見つからないので、
先の優先順位に従って次のような順番で検索を行います。</p>

<ol>
<li>userheader</li>
<li>標準ヘッダstdio.hが入ったディレクトリ</li>
</ol>


<p>どちらの書き方でもuserheader内のstdio.hを先に発見してしまうので、
標準ヘッダのstdio.hにはどう頑張ってもアクセスすることができません。</p>

<h2>解決策</h2>

<p>iquoteオプションを使うと、&quot;&quot;で囲った場合のみuserheaderを見に行くようになります。</p>

<pre><code class="bash">gcc -iquote../userheader sample.c
</code></pre>

<h2>TinySVMの場合</h2>

<p>TinySVM0.09(現時点での最新版)は一部環境でgetoptの違うというエラーが発生するようです。
これは-Iオプションを使ってしまったため、標準ヘッダのgetopt.hと、自前で用意したgetopt.hの使い分けができていないのが原因です。</p>

<p>TinySVMに同梱されたgetopt関数の引数を書き換えることで対処している例がほとんど
(<a href="http://d.hatena.ne.jp/himorogi/20090621/1245536366">himorogiの日記</a>, <a href="http://rmecab.jp/wiki/index.php?%CF%C2%C9%DB%C9%F3%C2%BE%A5%A4%A5%F3%A5%B9%A5%C8%A1%BC%A5%EB">RとLinuxと&hellip;</a>,etc)
ですが、大抵の環境にgetoptはあると思うのでgetopt.hを削除してしまったほうがいいかもしれません。
(TinySVM最近更新されていないのでgetoptが古いし)</p>

<h2>参考</h2>

<ul>
<li><a href="http://ameblo.jp/mofu-mofu-alpaca/entry-10868656211.html">C言語のヘッダ読み込み順について</a></li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Directory-Options.html">Directory Options - Using the GNU Compiler Collection (GCC)</a></li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.1/cpp.pdf">The C Preprocessor</a> pp.66-67</li>
</ul>

]]></content>
  </entry>
  
</feed>
