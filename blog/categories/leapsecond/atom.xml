<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leapsecond | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/leapsecond/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2017-12-06T05:45:00+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go1.9から使える Monotonic Clocks を試してみた]]></title>
    <link href="https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock/"/>
    <updated>2017-06-26T09:21:42+09:00</updated>
    <id>https://shogo82148.github.io/blog/2017/06/26/go19-monotonic-clock</id>
    <content type="html"><![CDATA[<p>先日Go1.9beta1がリリースされました。</p>

<p>{% oembed <a href="https://twitter.com/golang/status/875117556595515392">https://twitter.com/golang/status/875117556595515392</a> %}</p>

<ul>
<li><a href="https://tip.golang.org/doc/go1.9">Go 1.9 Release Notes</a></li>
</ul>


<p>型エイリアスのサポート、<a href="https://tip.golang.org/pkg/math/bits/">math/bits</a>パッケージ、
<a href="https://tip.golang.org/pkg/sync/#Map">sync.Map</a>型など、
今回のアップデートでも便利そうな機能が追加されます。
詳しくは<a href="https://twitter.com/tenntenn">tenntenn</a>さんの<a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">Gopher Fest 2017参加レポート</a>をどうぞ。</p>

<p>今回のリリースノートを見て、個人的に注目しているのは<strong>Monotonic Clocksのサポート</strong>です。
他の機能追加はTwitterとかで見かけるけど、
Monotonic Clocksはなぜかあまり見ない・・・。
beta1がでて手軽に試せるようになったので、試してみました。</p>

<h2>Monotonic Clocks</h2>

<p>Go1.8以前で取得していた時刻は「wall clock」といい、<strong>現在の正しい時刻</strong>を知るために使います。
一方「monotonic clock」は、<strong>時間を計る</strong>ために使うものです。
Go1.9からは<code>time.Now</code>で取得できる時刻に「wall clock」と「monotonic clock」が含まれるようになります。</p>

<p><a href="https://tip.golang.org/pkg/time/#hdr-Monotonic_Clocks">timeパッケージのドキュメント</a>から
コード片を引用します。</p>

<pre><code class="plain">t := time.Now()
... operation that takes 20 milliseconds ...
u := time.Now()
elapsed := t.Sub(u)
</code></pre>

<p>上のコードで <code>elapsed</code> は 20ms となるはずですが、
実際はそうはならないケースがあります。
具体的には以下のようなケースです。</p>

<ul>
<li>ntpdなどによってOSの時刻が変更された場合</li>
<li>うるう秒が挿入・削除された場合</li>
</ul>


<p>Go1.9からはこのようなケースでも正しく時間を計ることができます。</p>

<h2>うるう秒を入れてみた</h2>

<p>うるう秒が入ったときの挙動が気になったので実際にやってみました。
セットアップが簡単になるよう<a href="http://jjy.nict.go.jp/tsp/link/leap.html">NICTのPerl版SNTP</a>のGolangポートを作ったので、
それを使って偽物のうるう秒を挿入してみます。</p>

<ul>
<li><a href="https://github.com/shogo82148/fakentpd">shogo82148/fakentpd</a></li>
</ul>


<p>インストールはいつものように<code>go get</code>です。
<code>-p</code>オプションで正のうるう秒挿入、<code>-n</code>オプションで負のうるう秒削除です(ほんとうは月末だけだけど、雑な実装のため毎日その日の終わりに挿入・削除されます)。
引数にRFC3339形式で日時を指定すると、その日時を起動時の日時として扱います。</p>

<p>たとえば今月末に正のうるう秒を挿入するには以下のように指定します。</p>

<pre><code class="bash"># 上位ntpd側
$ go get github.com/shogo82148/fakentpd
$ sudo fakentpd -p 2017-06-30T23:00:00Z # well known portを使うのでroot権限が必要
</code></pre>

<p>このSNTPサーバーを上位ntpdとして参照したクライアントを用意し、<code>date</code>コマンドで様子を確認してみましょう。
(ntpdの設定などの詳細は<a href="http://tkuchiki.hatenablog.com/entry/2015/06/19/083025">tkuchikiさんのうるう秒検証記事</a> を参照)</p>

<pre><code class="bash"># 下位ntpd側
$ while :; do date +'%Y-%m-%d %H:%M:%S.%3N'; usleep 100000; done
</code></pre>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.040
2017-06-30 23:59:59.141
2017-06-30 23:59:59.243
2017-06-30 23:59:59.344
2017-06-30 23:59:59.445
2017-06-30 23:59:59.547
2017-06-30 23:59:59.648
2017-06-30 23:59:59.749
2017-06-30 23:59:59.851
2017-06-30 23:59:59.952 #
2017-06-30 23:59:59.053 # うるう秒挿入！
2017-06-30 23:59:59.155
2017-06-30 23:59:59.256
2017-06-30 23:59:59.357
2017-06-30 23:59:59.458
2017-06-30 23:59:59.559
2017-06-30 23:59:59.661
2017-06-30 23:59:59.762
2017-06-30 23:59:59.863
2017-06-30 23:59:59.964
2017-07-01 00:00:00.066
</code></pre>

<p>うるう秒が挿入されたため、59.952から59.053へ時間が巻き戻っていることが確認できます。</p>

<p>これと同等のプログラムをGoで書いて挙動を確認します。
monotonic clockの確認をするために、一緒に起動時からの経過時間も表示するようにしました。</p>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

func main() {
    start := time.Now()
    for {
        now := time.Now()
        fmt.Println(now, now.Sub(start))
        time.Sleep(100 * time.Millisecond)
    }
}
</code></pre>

<p><code>date</code>コマンドで検証したときと同様の条件で、
このプログラムを<strong>Go1.8で実行</strong>すると以下のような結果になりました。</p>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.038281905 +0000 UTC 32m42.970735711s
2017-06-30 23:59:59.138469005 +0000 UTC 32m43.070922811s
2017-06-30 23:59:59.238662875 +0000 UTC 32m43.171116681s
2017-06-30 23:59:59.338835875 +0000 UTC 32m43.271289681s
2017-06-30 23:59:59.439025825 +0000 UTC 32m43.371479631s
2017-06-30 23:59:59.539213666 +0000 UTC 32m43.471667472s
2017-06-30 23:59:59.63940551 +0000 UTC 32m43.571859316s
2017-06-30 23:59:59.739603502 +0000 UTC 32m43.672057308s
2017-06-30 23:59:59.839783301 +0000 UTC 32m43.772237107s
2017-06-30 23:59:59.939980591 +0000 UTC 32m43.872434397s #
2017-06-30 23:59:59.043820722 +0000 UTC 32m42.976274528s # うるう秒挿入！
2017-06-30 23:59:59.143987505 +0000 UTC 32m43.076441311s
2017-06-30 23:59:59.244160716 +0000 UTC 32m43.176614522s
2017-06-30 23:59:59.344336707 +0000 UTC 32m43.276790513s
2017-06-30 23:59:59.444546067 +0000 UTC 32m43.376999873s
2017-06-30 23:59:59.544717014 +0000 UTC 32m43.47717082s
2017-06-30 23:59:59.644876123 +0000 UTC 32m43.577329929s
2017-06-30 23:59:59.745050732 +0000 UTC 32m43.677504538s
2017-06-30 23:59:59.845230425 +0000 UTC 32m43.777684231s
2017-06-30 23:59:59.945421532 +0000 UTC 32m43.877875338s
2017-07-01 00:00:00.045595155 +0000 UTC 32m43.978048961s
</code></pre>

<p>うるう秒が挿入されたため、59.9から59.0に時刻が巻き戻っていることが確認できます。
それと同時に経過時刻も32m43.87sから32m42.97sと巻き戻ってしまいました。</p>

<p>おなじプログラムをGo1.9で実行してみます。</p>

<pre><code class="plain">(前略)
2017-06-30 23:59:59.038322917 +0000 UTC m=+1962.019889237 32m42.01969158s
2017-06-30 23:59:59.138507805 +0000 UTC m=+1962.120074107 32m42.11987645s
2017-06-30 23:59:59.238704422 +0000 UTC m=+1962.220270727 32m42.22007307s
2017-06-30 23:59:59.338875317 +0000 UTC m=+1962.320441617 32m42.32024396s
2017-06-30 23:59:59.439066666 +0000 UTC m=+1962.420632996 32m42.420435339s
2017-06-30 23:59:59.539255964 +0000 UTC m=+1962.520822264 32m42.520624607s
2017-06-30 23:59:59.639446597 +0000 UTC m=+1962.621012897 32m42.62081524s
2017-06-30 23:59:59.739644525 +0000 UTC m=+1962.721210832 32m42.721013175s
2017-06-30 23:59:59.839827168 +0000 UTC m=+1962.821393501 32m42.821195844s
2017-06-30 23:59:59.94003045 +0000 UTC m=+1962.921596780 32m42.921399123s #
2017-06-30 23:59:59.043859649 +0000 UTC m=+1963.025425981 32m43.025228324s # うるう秒挿入！
2017-06-30 23:59:59.144008957 +0000 UTC m=+1963.125575282 32m43.125377625s
2017-06-30 23:59:59.244196844 +0000 UTC m=+1963.225763148 32m43.225565491s
2017-06-30 23:59:59.344388476 +0000 UTC m=+1963.325954758 32m43.325757101s
2017-06-30 23:59:59.444598162 +0000 UTC m=+1963.426164679 32m43.425967022s
2017-06-30 23:59:59.54473741 +0000 UTC m=+1963.526303708 32m43.526106051s
2017-06-30 23:59:59.644895019 +0000 UTC m=+1963.626461309 32m43.626263652s
2017-06-30 23:59:59.745084175 +0000 UTC m=+1963.726650464 32m43.726452807s
2017-06-30 23:59:59.845264185 +0000 UTC m=+1963.826830509 32m43.826632852s
2017-06-30 23:59:59.94546352 +0000 UTC m=+1963.927029829 32m43.926832172s
2017-07-01 00:00:00.04563023 +0000 UTC m=+1964.027196518 32m44.026998861s
</code></pre>

<p>うるう秒が挿入されるとwall clockは59.9から59.0に時刻が巻き戻っています。
しかし経過時刻は32m42.9から32m43.0と巻き戻りは発生していません。</p>

<p>Go1.9から<code>t.String()</code>がmonotonic clockの情報を返すようになるので、今回の検証ログにも表示されています。
monotonic clockも m=+1962.921596780 から m=+1963.025425981 と巻き戻りは発生していません。
(mの意味はよくわかってないけどプロセスの起動時間？)</p>

<h2>時刻を変えてみた</h2>

<p>検証用のfakentpdを止めて本物の上位ntpdを復活させると、
時刻の差が大きいため元の時刻に一気に修正されます。
この場合についても試してみました。</p>

<p>Go1.8で実行した場合。
時刻が戻ると同時に経過時間が-144hとおかしな値になってしまいました。</p>

<pre><code class="plain">(前略)
2017-07-01 00:30:20.802110381 +0000 UTC 4m52.493894502s
2017-07-01 00:30:20.9022538 +0000 UTC 4m52.594037921s
2017-07-01 00:30:21.002404752 +0000 UTC 4m52.694188873s #
2017-06-24 23:41:17.694698679 +0000 UTC -144h44m10.6135172s # 正しい時刻に戻った
2017-06-24 23:41:17.794881161 +0000 UTC -144h44m10.513334718s
2017-06-24 23:41:17.895024223 +0000 UTC -144h44m10.413191656s
</code></pre>

<p>Go1.9で実行した場合です。
wall clockは正しい時刻に戻りましたが、monotonic clockはその影響を受けず、
経過時間も正しく計算できています。</p>

<pre><code class="plain">2017-07-01 00:30:20.802071152 +0000 UTC m=+289.102414299 4m49.102265199s
2017-07-01 00:30:20.902234666 +0000 UTC m=+289.202577610 4m49.20242851s
2017-07-01 00:30:21.00238566 +0000 UTC m=+289.302728596 4m49.302579496s #
2017-06-24 23:41:17.694655753 +0000 UTC m=+289.402903206 4m49.402754106s # 正しい時刻に戻った
2017-06-24 23:41:17.794841932 +0000 UTC m=+289.503089435 4m49.502940335s
2017-06-24 23:41:17.895004891 +0000 UTC m=+289.603252211 4m49.603103111s
</code></pre>

<h2>ドリフトしてみた</h2>

<p>monotonic time は ntpd の干渉を全く受けないわけではなく、
ドリフトの補正は受けます。
せっかくなのでこれも確認してみました。</p>

<p>以下のコマンドで500PPM(Parts-per-Million)早く時刻が進むntpdとして動作します。
1PPMは100万分の1の誤差なので、500PPMでは2000秒(約33分)で1秒ズレます。</p>

<pre><code class="bash">$ sudo fakentpd -d 500
</code></pre>

<p>(ほんとうは2倍速！とかやってみたかったけど、さすがに偽ntpdだとバレて同期対象から外された)</p>

<p>起動からの経過時間を返すサーバーと、
サーバーとの時刻を比較するクライアントを用意します。</p>

<pre><code class="go">package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

func main() {
    start := time.Now()
    http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
        // 起動からの経過時間を返す
        fmt.Fprintf(w, "%.6f", time.Since(start).Seconds())
        log.Printf("%.6f", time.Since(start).Seconds())
    })
    http.ListenAndServe(":8080", nil)
}
</code></pre>

<pre><code class="go">package main

import (
    "io/ioutil"
    "log"
    "net/http"
    "os"
    "strconv"
    "time"
)

// サーバー側の経過時間を取得する
func get(u string) float64 {
    resp, _ := http.Get(u)
    defer resp.Body.Close()
    data, _ := ioutil.ReadAll(resp.Body)
    t, _ := strconv.ParseFloat(string(data), 64)
    return t
}

func main() {
    start := time.Now()
    startRemote := get(os.Args[1])
    for {
        time.Sleep(time.Second)
        end := time.Now()
        endRemote := get(os.Args[1])
        log.Printf("local:  %.6f", end.Sub(start).Seconds())
        log.Printf("remote: %.6f", endRemote-startRemote)
    }
}
</code></pre>

<p>ドリフト補正が反映されるよう数時間同期状態を保ったあと、
検証用プログラムを走らせると以下のような結果になりました。</p>

<pre><code class="plain">(前略)
2017/06/25 08:34:27 local:  1997.178992
2017/06/25 08:34:27 remote: 1998.176471
2017/06/25 08:34:28 local:  1998.179892
2017/06/25 08:34:28 remote: 1999.177970
2017/06/25 08:34:29 local:  1999.180993
2017/06/25 08:34:29 remote: 2000.179569
2017/06/25 08:34:30 local:  2000.182062
2017/06/25 08:34:30 remote: 2001.181200
</code></pre>

<p>起動から2000秒で1秒のズレ＝500PPMのドリフトがかかっていることが確認できました。</p>

<h2>まとめ</h2>

<p>Go1.9からサポートされるmonotonic clockについて検証を行いました。
うるう秒や時刻変更の影響を受けず、正しく経過時間を測定できることが確認できました。
また、ドリフトの調整は受けることも確認できました。</p>

<p>monotonic clockになると、methaneさんが紹介している<a href="http://dsas.blog.klab.org/archives/2016-09-20/isucon5q.html">zero time cache</a>の
実用性があがって利用しやすくなりますね。
さらに<a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">Cloudflare DNSがうるう秒にやられる</a>
こともなくなるので安心です。</p>

<p>注意点としては<code>t.String()</code>がmonotonic clockの情報を返すので、
時刻の出力を雑に<code>fmt.Println(t)</code>とかしていると出力が変わってしまうことくらいでしょうか。
(皆さんちゃんとFormatしてますよね？)</p>

<p>もうすぐ来年1月1日のうるう秒の有無が発表される時期です。
それまでにはGo1.9の正式版がリリースされているはずなので、
変な罠に引っかからないよう皆さんアップデートしましょう！</p>

<h2>参考</h2>

<ul>
<li><a href="http://tech.mercari.com/entry/gopherfest2017_report">Gopher Fest 2017参加レポート</a></li>
<li><a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">Gopher Fest 2017参加レポート(スライド)</a></li>
</ul>


<p>{% oembed <a href="https://www.slideshare.net/takuyaueda967/gopher-fest-2017">https://www.slideshare.net/takuyaueda967/gopher-fest-2017</a> %}</p>

<ul>
<li><a href="http://jjy.nict.go.jp/tsp/link/leap.html">うるう秒とコンピュータクロック | NICT</a></li>
<li><a href="http://d.hatena.ne.jp/incarose86/20110505/1312522379">NTP設定</a></li>
<li><a href="http://tkuchiki.hatenablog.com/entry/2015/06/19/083025">2015年うるう秒の検証方法と検証結果 (Amazon Linux, CentOS)</a></li>
<li><a href="https://access.redhat.com/ja/node/1362753">Leap Second Insertion フラグを受信後にそのフラグを削除する</a></li>
<li><a href="http://www.geocities.co.jp/SiliconValley/6876/rfc2030j.htm">RFC2030 参考訳 IPv4・IPv6・OSI用簡易ネットワーク時刻プロトコル（SNTP）Version 4</a></li>
<li><a href="https://tools.ietf.org/html/rfc2030">RFC2030  Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI</a></li>
<li><a href="http://dsas.blog.klab.org/archives/2016-09-20/isucon5q.html">ISUCON6予選をトップ通過しました</a>

<ul>
<li>zero time cache について紹介されています</li>
</ul>
</li>
<li><a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">How and why the leap second affected Cloudflare DNS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DateTime.pmにうるう秒の修正が入った話]]></title>
    <link href="https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm/"/>
    <updated>2016-12-15T22:17:47+09:00</updated>
    <id>https://shogo82148.github.io/blog/2016/12/15/leap-second-in-datetime-dot-pm</id>
    <content type="html"><![CDATA[<p>こんにちは、<a href="https://metacpan.org/pod/DateTime">DateTime.pm</a> Watcherのいっちーです。
本日面白いパッチがDateTime.pmに取り込まれたので、ご紹介したいと思います。</p>

<!-- More -->


<p>そのpullreqがこちらです。Closedになっていますが、該当コミットはmasterに取り込まれています。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/pull/48">The leap second in 2012 was on 2012-07-01 not 2012-06-01. #48</a></li>
</ul>


<blockquote><p>per <a href="https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction">https://confluence.qps.nl/display/KBE/UTC+to+GPS+Time+Correction</a> the leap second in 2012 was on 2012-07-01 not 2012-06-01. It&rsquo;s is well known that leap seconds only occur directly before Jan 1st or July 1st.</p></blockquote>

<p>適当な和訳「2012年に挿入されたうるう秒は2012年6月1日ではなく2012年7月1日です。よく知られているように、今までに挿入されたうるう秒は1月1日と7月1日の直前だけです。」</p>

<pre><code class="diff">diff --git a/lib/DateTime/LeapSecond.pm b/lib/DateTime/LeapSecond.pm
index 66e1b2b..4a38be2 100644
--- a/lib/DateTime/LeapSecond.pm
+++ b/lib/DateTime/LeapSecond.pm
@@ -108,7 +108,7 @@ sub _initialize {
             1999  Jan. 1  +1
             2006  Jan. 1  +1
             2009  Jan. 1  +1
-            2012  Jun. 1  +1
+            2012  Jul. 1  +1
             2015  Jul. 1  +1
             2017  Jan. 1  +1
             )
</code></pre>

<p>なぜ4年間誰も気が付かなかった。</p>

<h2>このバグの影響</h2>

<p>結論から言うと、<strong>この修正によるDateTime.pmの挙動への影響はありません</strong>。
これを書いている時点で最新版のver1.41には、上記の修正は取り込まれていませんが、
うるう秒は2012年7月1日に正しく挿入されます。</p>

<p>以前<a href="//shogo82148.github.io/blog/2015/12/09/perl-datetime/">Perl の DateTime 利用上の注意点</a>で
うるう秒の確認をしたときと同様に検証してみましょう。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 7, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);

$dt = DateTime-&gt;new( year =&gt; 2012, month =&gt; 6, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59

$ PERL_DATETIME_PP=1 perl datetime.pl
2012-07-01T08:59:60
2012-06-01T08:59:59
</code></pre>

<p>DateTime.pmにはXSの実装とPurePerlの実装が含まれていますが、
どちらの実装でも2012年7月1日に正しくうるう秒が挿入され、2012年6月1日にはうるう秒はありません。</p>

<p>{% oembed <a href="https://twitter.com/kazoo04/status/808195587518578688">https://twitter.com/kazoo04/status/808195587518578688</a> %}</p>

<p>まさに、「コード見たら絶対動かないはずなのになぜか思った通りにちゃんと動く」といった感じです。</p>

<h2>なぜ正しく動くのか</h2>

<p>なぜ正しく動くのか、その答えはうるう秒一覧の解析を行う部分にありました。</p>

<ul>
<li><a href="https://github.com/houseabsolute/DateTime.pm/blob/ff0e3780ea1c841eb17a0245f5f8061cf10c28d3/lib/DateTime/LeapSecond.pm#L40-L41">DateTime.pm/lib/DateTime/LeapSecond.pm</a></li>
</ul>


<pre><code class="perl">my $utc_epoch
    = DateTime-&gt;_ymd2rd( $year, ( $mon =~ /Jan/i ? 1 : 7 ), $mday );
</code></pre>

<p><strong>Jan.(1月)以外はすべて7月として扱っている！</strong></p>

<p>Janか否かが重要なので、JunだろうがJulだろうが7月として扱われるので、結果的に正しく動くわけです。
「バグを埋め込んでいたけど、実装が適当でたまたま動いていた」というよくあるパターンですね。
将来3月末や9月末に挿入されるようになったとき大丈夫なんでしょうか・・・。
まあ、必要になるのは数百年後とかなので、僕には関係ない・・・そう、関係ないのです・・・。</p>

<h2>まとめ</h2>

<ul>
<li>DateTime.pmのうるう秒一覧にbug fix</li>
<li>動作に影響は無いので、ユーザ側では特に気にする必要はない

<ul>
<li>うるう秒自体を気にしないといけないのは仕方がない・・・</li>
</ul>
</li>
<li>JanとかJunとかJulとか似てて紛らわしいんだよ！！数字書け！！</li>
</ul>


<h2>ちなみに</h2>

<p>最新版のver1.41は来年(2017年)の1月1日のうるう秒に対応済みです。</p>

<pre><code class="perl">use feature qw(say);
my $dt;

use DateTime;

$dt = DateTime-&gt;new( year =&gt; 2017, month =&gt; 1, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<pre><code class="plain">$ perl datetime.pl
2017-01-01T08:59:60
</code></pre>

<p>みなさん準備は出来ていますか 😇</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl の DateTime 利用上の注意点]]></title>
    <link href="https://shogo82148.github.io/blog/2015/12/09/perl-datetime/"/>
    <updated>2015-12-09T00:00:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/12/09/perl-datetime</id>
    <content type="html"><![CDATA[<p>この投稿は <a href="http://qiita.com/advent-calendar/2015/perl5">Perl 5 Advent Calendar 2015</a> の 9日目の記事です。</p>

<p><a href="http://developer.hatenastaff.com/entry/2015/12/02/050000">Perl の Time::Piece 利用上の注意点</a>
という記事の最後に<a href="https://metacpan.org/release/DateTime">DateTime</a>への言及があったのですが、
DateTimeはDateTimeでいろいろとハマりどころがあるんですよね・・・。
僕も今年いくつか罠にハマりました。ちょうどアドベントカレンダーの季節ですし、この機会にハマりどころをまとめてみることにします。</p>

<!-- More -->


<h2>遅い</h2>

<p>いろんなところで言われていることですが <strong>遅い</strong> です。
試しに代表的な日付を扱うモジュールでベンチをとってみました。
(比較のために時間をとるためのPerlの組み込み関数も入れてあります)</p>

<pre><code class="perl"># いろんな形式で今の時間を取得する
use Benchmark qw/ cmpthese /;
use Time::HiRes ();
use Time::Moment;
use Time::Piece ();
use DateTime;

cmpthese 0, {
    'time'         =&gt; sub { time },
    'Time::HiRes'  =&gt; sub { Time::HiRes::time },
    'localtime'    =&gt; sub { () = localtime },
    'Time::Moment' =&gt; sub { Time::Moment-&gt;now },
    'Time::Piece'  =&gt; sub { Time::Piece-&gt;localtime },
    'DateTime'     =&gt; sub { DateTime-&gt;now( time_zone=&gt;'Asia/Tokyo' ) },
};
</code></pre>

<pre><code>Rate DateTime Time::Piece Time::Moment localtime Time::HiRes  time
DateTime         5303/s       --        -95%         -98%      -99%       -100% -100%
Time::Piece    103765/s    1857%          --         -67%      -71%        -98%  -99%
Time::Moment   313599/s    5814%        202%           --      -11%        -93%  -98%
localtime      354215/s    6580%        241%          13%        --        -92%  -98%
Time::HiRes   4706723/s   88658%       4436%        1401%     1229%          --  -72%
time         16536995/s  311751%      15837%        5173%     4569%        251%    --
</code></pre>

<p>それにしてもTime::Moment速いですね。組み込みのlocaltimeと互角とは。</p>

<h2>演算は破壊的</h2>

<p>add, subtract等の演算を行うメソッドは破壊的です。
例えば、一時間後の日時を求めたい場合に以下のように書くと、
もとの日時が失われてしまいます。</p>

<pre><code class="perl"># 1時間後の日時を求める間違った例
use feature 'say';
use DateTime;

my $dt = DateTime-&gt;new(year =&gt; 2015, month =&gt; 12, day =&gt; 9);
my $after_an_hour = $dt-&gt;add(hours =&gt; 1);

say $dt; # 2015-12-09T01:00:00
say $after_an_hour; # 2015-12-09T01:00:00
</code></pre>

<p>以下のようにcloneしてから演算することで防ぐことができます。</p>

<pre><code class="perl"># 1時間後の日時を求める間違った例
use feature 'say';
use DateTime;

my $dt = DateTime-&gt;new(year =&gt; 2015, month =&gt; 12, day =&gt; 9);
my $after_an_hour = $dt-&gt;clone-&gt;add(hours =&gt; 1);

say $dt; # 2015-12-09T00:00:00
say $after_an_hour; # 2015-12-09T01:00:00
</code></pre>

<h2>うるう秒の存在</h2>

<p>さて問題です。
「日本時間2015年7月1日午前9時の1秒前は何時何分何秒でしょう？」</p>

<p>簡単そうな問題ですが、一応DateTimeに計算してもらって確かめてもらいましょう。</p>

<pre><code class="perl datetime.pl">use feature qw(say);
use DateTime;
my $dt = DateTime-&gt;new( year =&gt; 2015, month =&gt; 7, day =&gt; 1, hour =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
say $dt-&gt;subtract(seconds =&gt; 1);
</code></pre>

<p>これを現時点での最新バージョンであるDateTime-1.21を使って実行してみます。</p>

<pre><code class="bash">$ perl datetime.pl
2015-07-01T08:59:60
</code></pre>

<p>はい、正解は <strong>「8時59分60秒」</strong> です。
「60秒はおかしい。8時59分59秒では？？？」という声が聞こえてきそうですが、60秒が正解です。
今年の7月1日は<a href="http://gigazine.net/news/20150701-leap-second-insert/">3年ぶりにうるう秒が挿入された日</a>でした。
そのため <strong>通常は存在しない60秒がこの日だけ存在します。</strong>
うるう秒についてはWikipediaの<a href="https://ja.wikipedia.org/wiki/%E9%96%8F%E7%A7%92">閏秒</a>の項目どうぞ。
インフラを担当されているかたは対応に苦労したかたも多いのではないでしょうか。</p>

<p>うるう秒は存在だけでも厄介ですが、さらに厄介なことに <strong>うるう秒調整のタイミングは実施される半年前になるまでわかりません</strong> 。
次調整が入るとすれば2016年7月1日ですが、2015年の現時点では調整が入るのか入らないのか確かなことは言えません(今までの傾向からないとは思いますが)。
事前に分からないものに対してDateTimeがどう対処しているかというと、<strong>うるう秒の調整が行われることがわかった時点でバージョンアップして対応</strong> しています。
そのため、2015年7月1日のうるう秒の存在を知らないバージョン(具体的には1.17以前)で先ほどのコードを実行すると、
最新版とは異なった結果が帰ってきます。</p>

<pre><code class="bash">$ cpanm DateTime@1.17
$ perl datetime.pl
2015-07-01T08:59:59
</code></pre>

<p>さて、うるう秒を正確に扱いたい場合は便利な機能ですが、
DateTimeモジュール以外のプログラムがうるう秒を正しく扱えるとは限らないので無視したいケースも多いと思います。
パッと思いつくのは以下のような対応でしょうか・・・。</p>

<ul>
<li>タイムゾーンに <code>floating</code> を指定する

<ul>
<li>「タイムゾーン情報を持っていない」ことを表す特殊なタイムゾーンです</li>
<li>うるう秒の調整のようなタイムゾーン情報が必要な機能はすべて無効になります</li>
<li>タイムゾーンを扱えるのがDateTimeの利点だったのに・・・</li>
</ul>
</li>
<li>うるう秒に関する定義を削除した自前ビルドを用意する

<ul>
<li>DateTimeのレポジトリに<a href="https://github.com/autarch/DateTime.pm/blob/master/leaptab.txt">うるう秒の挿入タイミング一覧</a>が定義されているので、これを削除した自前ビルドを用意する方法</li>
<li>なお、この一覧はビルド時にXSのコードの一部として組み込まれるようなので、ランタイムに何とかすることはできない模様</li>
</ul>
</li>
<li>一度DateTimeをインストールしたら絶対にバージョンアップを行わない。インストールした日時よりも半年以上未来の日時だけ扱う

<ul>
<li>通常半年前にうるう秒の調整は決定されるので、DateTimeはリリース後半年以上未来のうるう秒は知りません</li>
<li>そのため、半年以上未来の日時を扱う限りはうるう秒とは無縁でいられます</li>
</ul>
</li>
</ul>


<p>どれもBK臭溢れる対応なので、もっとスマートな対応方法をご存知のかたはご教授いただけると幸いです。</p>

<h2>ある日からある日までの日数を知りたい</h2>

<p>DateTimeは演算子オーバーロードされているため、通常の数値を同じように引き算が可能です。
引き算を使ったほうが手軽にできるからと以下のように書いてしまうとハマります。</p>

<pre><code class="perl"># 日数計算の間違った例
my $dt1 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 25, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1 - $dt2;
say $dur-&gt;in_units('days'); # 16
</code></pre>

<p>一見動いているように見えますが、期間が一ヶ月を超えるような場合に間違った結果を返します。</p>

<pre><code class="perl"># 日数計算の間違った例
my $dt1 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 25, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 11, day =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1 - $dt2;
say $dur-&gt;in_units('days'); # 16
</code></pre>

<p>引き算で帰ってくるDateTime::Durationオブジェクトは「1ヶ月と16日」という情報を持っているのですが、
「1ヶ月」の日数が月によってことなるため計算ができないのです。
以下のように差分を求める時点で日数を計算するように伝えるのが正しいやり方です。</p>

<pre><code class="perl"># 正しいやりかた
my $dt1 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 25, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 11, day =&gt; 9, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1-&gt;delta_days($dt2);
say $dur-&gt;in_units('days'); # 46
</code></pre>

<h2>ある日時からある日時までの秒数を知りたい</h2>

<p>日数がわかったところで、次は秒数を求めてみましょう。
これも演算子オーバーロードを使うとハマります。</p>

<pre><code class="perl"># 秒数計算の間違った例
my $dt1 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 10, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt;  9, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1-$dt2;
say $dur-&gt;in_units('seconds'); # 0
</code></pre>

<p>$durには「1日」という情報が入っているはずなので、普通に考えるとこれから秒数は求められそうです。
1分は60秒で、1時間は60分で、1日は24時間なので、「1日=60×60×24秒」ですよね。
なぜ求められないのでしょう？</p>

<p>・・・そう、<strong>うるう秒</strong> です。
うるう秒が存在するため、1分は59秒の場合もあれば、61秒の場合もあります。
日数を求めるときと同じように、差分を求める時点で秒数の計算を行うように伝えるとうまくいきます。</p>

<pre><code class="perl"># 正しいやりかた
my $dt1 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt; 10, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 12, day =&gt;  9, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1-&gt;subtract_datetime_absolute($dt2);
say $dur-&gt;in_units('seconds'); # 86400
</code></pre>

<p>ちなみに今年はうるう秒の挿入があったので、 <strong>DateTimeの最新版で今年の秒数を計算すると 365×24×60×60秒よりも1秒だけ長くなります</strong> 。
そして今年のうるう秒の挿入を知らない <strong>DateTime1.17では365×24×60×60秒</strong>が帰ってきます。</p>

<pre><code class="perl">my $dt1 = DateTime-&gt;new( year =&gt; 2016, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dur = $dt1-&gt;subtract_datetime_absolute($dt2);
say $dur-&gt;in_units('seconds'); # 31536001 or 31536000 (DateTimeのバージョンによって異なります)
</code></pre>

<p><code>epoch</code>は1970年1月1日午前0時(UTC)からの経過秒数を返すメソッドですが、
これは実際の経過時間ではなく形式的な経過秒数(つまりうるう秒を考慮しない)を返します。
そのため、以下のように秒数を求めるとどのバージョンでも同じ結果が帰ってくるはずです。</p>

<pre><code class="perl">my $dt1 = DateTime-&gt;new( year =&gt; 2016, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
my $dt2 = DateTime-&gt;new( year =&gt; 2015, month =&gt; 1, day =&gt; 1, time_zone =&gt; 'Asia/Tokyo' );
say $dt1-&gt;epoch() - $dt2-&gt;epoch(); # 31536000
</code></pre>

<p>もうDateTimeなんか使うのやめて<code>epoch</code>使おうぜ！！
(もちろん実際の経過時間はうるう秒の+1があるのが正しいので、ケースバイケースですが)</p>

<h2>まとめ</h2>

<p>DateTimeは日時をしっかり扱ってくれる素晴らしいモジュールです。
きっと <strong>あなたが思っている以上に日時を正確に厳密に扱ってくれます</strong> 。
そこまで厳密にやるか・・・というところまでしっかり扱ってくれるので、
日時計算に潜んだ様々な闇に触れることになるでしょう。
使う側もそれらのことについてしっかりと理解しておく必要があります。</p>

<p>まあ、具体的に言うと <strong>うるう秒</strong> とか <strong>うるう秒</strong> とかですね！
廃止論とかありましたけど、<a href="http://internet.watch.impress.co.jp/docs/news/20151120_731707.html">とりあえず2023年までは調整がはいる</a>そうです・・・。</p>

<p>他にもいろいろ罠がありそう・・・知っているかたがいれば教えて下さい。</p>
]]></content>
  </entry>
  
</feed>
