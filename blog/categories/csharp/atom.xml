<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: csharp | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/csharp/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2015-06-03T10:09:29+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[名前付き引数とオプション引数とオーバーロードを同時に使うとUnityが死ぬ]]></title>
    <link href="http://shogo82148.github.io/blog/2015/03/29/unity-internal-compiler-error/"/>
    <updated>2015-03-29T12:13:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/03/29/unity-internal-compiler-error</id>
    <content type="html"><![CDATA[<p>オーバーロードの優先順位付けが少しおかしくて、
名前付き引数とオプション引数と一緒に使うと死ぬ場合があるというお話。
ぴーちんが昨日言ってたやつ。
いんたーねっつにも乗っけておく。</p>

<!-- More -->


<p>問題となるのは以下のようなコード。</p>

<p>``` csharp
class MainClass
{</p>

<pre><code>void Foo (int fuga)
{
}

void Foo (string hoge, int fuga = 10)
{
}

void Bar()
{
    Foo (fuga: 20);
}
</code></pre>

<p>}
```</p>

<p>このコードは以下のような例外を吐いて死ぬ。</p>

<p>``` plain
Internal compiler error. See the console log for more information. output was:
Unhandled Exception: Mono.CSharp.InternalErrorException: Internal error
  at Mono.CSharp.MethodGroupExpr.IsApplicable (Mono.CSharp.ResolveContext ec, Mono.CSharp.Arguments&amp; arguments, Int32 arg_count, System.Reflection.MethodBase&amp; method, System.Boolean&amp; params_expanded_form) [0x00000] in <filename unknown>:0
  at Mono.CSharp.MethodGroupExpr.OverloadResolve (Mono.CSharp.ResolveContext ec, Mono.CSharp.Arguments&amp; Arguments, Boolean may_fail, Location loc) [0x00000] in <filename unknown>:0
  at Mono.CSharp.Invocation.DoResolveOverload (Mono.CSharp.ResolveContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.Invocation.DoResolve (Mono.CSharp.ResolveContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.Expression.Resolve (Mono.CSharp.ResolveContext ec, ResolveFlags flags) [0x00000] in <filename unknown>:0
  at Mono.CSharp.Expression.Resolve (Mono.CSharp.ResolveContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.ExpressionStatement.ResolveStatement (Mono.CSharp.BlockContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.StatementExpression.Resolve (Mono.CSharp.BlockContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.Block.Resolve (Mono.CSharp.BlockContext ec) [0x00000] in <filename unknown>:0
  at Mono.CSharp.ToplevelBlock.Resolve (Mono.CSharp.FlowBranching parent, Mono.CSharp.BlockContext rc, Mono.CSharp.ParametersCompiled ip, IMethodData md) [0x00000] in <filename unknown>:0</p>

<p>All compiler errors have to be fixed before you can enter playmode!
UnityEditor.SceneView:ShowCompileErrorNotification()
```</p>

<p>内部エラーだからどこが間違っているのか全くわからないという・・・。</p>

<p>このエラーに遭遇したのはUnity4.5.3だけど、
Unity5.0.0f4でも同じように死んだ。</p>

<p><code>Foo (fuga: 20);</code> は <code>void Foo (int fuga)</code> を読んで欲しいけど、
Unityがなぜか <code>void Foo (string hoge, int fuga = 10)</code> を呼び出してしまい、
コード生成時にエラーで落ちたんじゃないかと予想している。</p>

<ul>
<li>引数でオプションを取るのをやめる <code>void Foo (string hoge, int fuga)</code></li>
<li>引数の名前を変える <code>void Foo (string hoge, int fugaa = 10)</code></li>
</ul>


<p>という対処をすると大丈夫っぽい。</p>

<p>メソッド名自体を変えるべきではって気もするけど、
どうしてもインターフェースを変えたくなったら以下のようにオプション引数を使わずに、すべてオーバーロードで解決するとかかなあ。</p>

<p>``` csharp
class MainClass
{</p>

<pre><code>void Foo (int fuga)
{
}

void Foo (string hoge)
{
    Foo (hoge, 10);
}

void Foo (string hoge, int fuga)
{
}

void Bar()
{
    Foo (fuga: 20);
}
</code></pre>

<p>}
```</p>

<h2>追記</h2>

<p><a href="http://pchin.hatenablog.com/entry/2015/03/30/093130">ぴーちんも書いてくれた</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[travisがいつのまにやらcsharpをサポートしていた件]]></title>
    <link href="http://shogo82148.github.io/blog/2015/03/29/travis-supports-csharp/"/>
    <updated>2015-03-29T11:54:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/03/29/travis-supports-csharp</id>
    <content type="html"><![CDATA[<p>いつもテスト実行でお世話になっているtravisさんが<a href="http://docs.travis-ci.com/user/languages/csharp/">C#をサポートしていました</a>。</p>

<!-- More -->


<p>以前から <a href="https://github.com/travis-ci/travis-ci/issues/649">C#をサポートして欲しいという要望</a>はあったのですが、
2014年12月あたりからついに使えるようになってたみたいです。</p>

<p>以前はC言語のフリをして、設定ファルで頑張ってmonoをインストールする必要があったのですが、</p>

<p>``` yaml .travis.yml</p>

<h2>Travis CI Integration</h2>

<p>language: c
install:
  - sudo apt-get install mono-devel mono-gmcs
script:
  - xbuild hogehoge.sln
```</p>

<p>今はlanguageにcsharpを設定して、solutionを指定するだけです。</p>

<p>``` yaml .travis.yml</p>

<h2>Travis CI Integration</h2>

<p>language: csharp
solution: hogehoge.sln
```</p>

<p><a href="https://github.com/shogo82148/MiniMessagePack">MiniMeggagePack</a> もこちらの設定を使うようにしてみました。</p>

<p>nunitを使ってテストする場合は結局<code>sudo apt-get install nunit-console</code>する必要があるみたいですが、
複数バージョンのmonoでテストできたりしていい感じです。
ただ、ドキュメントにはmono2.10.8もサポートしているとあるのにmonoのインストールが404で失敗したり、
他のバージョンでも時たまmonoのインストールにコケたり、
3.8.0でnunitのテストが上手く動かなかったり、不安定な感じがしてます。
徐々に改善していくといいなー。</p>

<h2>参考</h2>

<ul>
<li><a href="http://docs.travis-ci.com/user/languages/csharp/">Building a C#, F#, or Visual Basic Project</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C#のconditional Attributeのコンパイル結果を見てみる]]></title>
    <link href="http://shogo82148.github.io/blog/2014/05/29/conditional-attribute/"/>
    <updated>2014-05-29T19:20:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/05/29/conditional-attribute</id>
    <content type="html"><![CDATA[<p>C#で「ある環境では関数の定義ごと消したい」みたいな要件があって、
そういう用途にconditinal attributeが使えるのかなーと話題のあがったので、実際に確認してみました。</p>

<p>結論から言えばできないのですが、せっかく調べたのでメモとして残しておきます。</p>

<!-- More -->


<h2>conditional attribute</h2>

<p>「デバッグ時のみにしか実行して欲しくない関数」みたいなものを定義するための機能です。</p>

<p>``` csharp
using System;
using System.IO;
using System.Diagnostics;</p>

<p>namespace ConditionalAttributeTest
{</p>

<pre><code>class MainClass
{
    public static void Main (string[] args)
    {
        Log("fugu");
    }

    [ConditionalAttribute("DEBUG")]
    public static void Log(string message)
    {
        Console.WriteLine(message);
    }
}
</code></pre>

<p>}
```</p>

<p>こんなふうに書いておくと <code>DEBUG</code> シンボルが定義されている時にだけ<code>Log</code>の呼び出しが行われます。</p>

<p>``` bash</p>

<blockquote><p>mcs -d:DEBUG ConditionalAttributeTest.cs
mono ConditionalAttributeTest
fugu
mcs ConditionalAttributeTest.cs
mono ConditionalAttributeTest
```</p></blockquote>

<h2>逆アセンブルしてみる</h2>

<p>DEBUG付きでコンパイルした結果を逆アセンブルしてみます。</p>

<p>``` plain
// ...前略
// method line 2
.method public static hidebysig</p>

<pre><code>default void Main (string[] args)  cil managed
</code></pre>

<p>{</p>

<pre><code>// Method begins at RVA 0x2058
.entrypoint
// Code size 11 (0xb)
.maxstack 8
IL_0000:  ldstr "fugu"
IL_0005:  call void class ConditionalAttributeTest.MainClass::Log(string)
IL_000a:  ret
</code></pre>

<p>} // end of method MainClass::Main</p>

<p>// method line 3
.method public static hidebysig</p>

<pre><code>default void Log (string message)  cil managed
</code></pre>

<p>{</p>

<pre><code>.custom instance void class [mscorlib]System.Diagnostics.ConditionalAttribute::'.ctor'(string) =  (01 00 05 44 45 42 55 47 00 00 ) // ...DEBUG..

// Method begins at RVA 0x2064
// Code size 7 (0x7)
.maxstack 8
IL_0000:  ldarg.0
IL_0001:  call void class [mscorlib]System.Console::WriteLine(string)
IL_0006:  ret
</code></pre>

<p>}
```</p>

<p>DEBUGを付けなかったときとのDIFFをとってみます。</p>

<p>``` diff
15c15</p>

<h2>&lt; .module ConditionalAttributeTest.exe // GUID = {A54F3644-5083-4EC7-B846-8A354DD113AA}</h2>

<blockquote><p>.module ConditionalAttributeTest.exe // GUID = {436FE462-17D6-4FDB-9AA7-15DA92658168}
42c42</p>

<h2>&lt;  // Code size 11 (0xb)</h2>

<p> // Code size 1 (0x1)
44,46c44
&lt;  IL_0000:  ldstr "fugu"
&lt;  IL_0005:  call void class ConditionalAttributeTest.MainClass::Log(string)</p>

<h2>&lt;  IL_000a:  ret</h2>

<p> IL_0000:  ret
55c53</p>

<h2>&lt;         // Method begins at RVA 0x2064</h2>

<pre><code>    // Method begins at RVA 0x205a
</code></pre>

<p>```</p></blockquote>

<p>変わったのは呼び出し側であるmain関数だけで、ConditionalAttributeがついたメソッド自体はDEBUGの有無に関係なく同じコードが吐かれます。</p>

<h2>SEE ALSO</h2>

<p>例によってこのことはドキュメントにバッチリ載っております。</p>

<ul>
<li><a href="http://msdn.microsoft.com/ja-jp/library/system.diagnostics.conditionalattribute.aspx">ConditionalAttribute クラス</a></li>
</ul>


<blockquote><p>指定した条件付きコンパイルのシンボルが定義されていない限り、メソッド呼び出しまたは属性を無視するようにコンパイラに指示します。</p></blockquote>

<p>ドキュメントには「呼び出しを無視する」としか書かれてないので、定義がなくなるわけではないですね。
そもそも関数定義がなくなったら、リンク時に Conditional Attribute があるかないか確認する方法がないじゃないですか・・・。</p>
]]></content>
  </entry>
  
</feed>
