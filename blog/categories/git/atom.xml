<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Shogo's Blog]]></title>
  <link href="https://shogo82148.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="https://shogo82148.github.io/"/>
  <updated>2016-06-09T12:29:12+09:00</updated>
  <id>https://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UnityのBitmapフォントの収録文字のdiffを取る]]></title>
    <link href="https://shogo82148.github.io/blog/2015/12/22/diff-of-unity-bitmap-font/"/>
    <updated>2015-12-22T19:04:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/12/22/diff-of-unity-bitmap-font</id>
    <content type="html"><![CDATA[<p>Unityで文字を描画するには
「<a href="http://d.hatena.ne.jp/nakamura001/20120910/1347241168">BMFont(Bitmap Font Generator)でビットマップフォントを作る方法</a>」等にあるように
ビットマップフォントを自分で作ってあげないといけないらしいです。
(ダイナミックフォントというものもあるらしいけど、まだ安定性が検証ができていないので使ってない。)</p>

<p>フォントに入っている全部の文字を収録するとでかくなりすぎるので、一部の文字だけ収録するのが一般的だと思います。
入れる文字は自分で選ぶわけですが、フォントファイルを更新する際に、以前は使えた文字が入っていなくてつらい思いをしたので、
gitで差分をみれるようにしてみました。</p>

<!-- More -->


<p>gitのいろんなファイル形式の差分を見やすくする方法は
<a href="http://shogo82148.github.io/blog/2015/03/24/git-diff-csv/">Git Diffでcsvの差分を見やすく表示する</a>を参照。</p>

<p>csvのときと同じ要領で、まずはfntファイルをdiffを取りやすい形式に変換するスクリプト(fnt2txt)を用意し</p>

<p>``` bash fnt2txt</p>

<h1>!/bin/bash</h1>

<p>grep 'char id=' $1 | cut -d' ' -f2 | cut -d= -f2 | perl -MEncode -ne 'printf "%04x: %s\n", $<em>, encode_utf8 chr($</em>) if $_ >= 32'
```</p>

<p>fnt2txtを使う設定を<code>.git/config</code>に設定します。</p>

<p>``` plain .git/config
[diff "fnt"]</p>

<pre><code>    textconv = fnt2txt
</code></pre>

<p>```</p>

<p>最後に拡張子.fntに対してだけこの設定が反映されるようにすればOKです。</p>

<p><code>plain .gitatrribute
*.fnt diff=fnt
</code></p>

<p>こんな感じでdiffが見れます。</p>

<p><code>diff git-diff
diff --git a/foo.fnt b/foo.fnt
index 79391c0..e262b2d 100755
--- a/foo.fnt
+++ b/foo.fnt
@@ -93,6 +93,7 @@
 007c: |
 007d: }
 007e: ~
+00a0:  
 00a1: ¡
 00a2: ¢
 00a3: £
</code></p>

<p>事故防止に是非ご利用ください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git-mergeの挙動をカスタマイズする]]></title>
    <link href="https://shogo82148.github.io/blog/2015/12/16/customize-git-merge/"/>
    <updated>2015-12-16T22:24:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/12/16/customize-git-merge</id>
    <content type="html"><![CDATA[<p>最近gitのコンフリクト解消職人みたいになっていてすごくつらいです。
普通のプログラムであれば順番が重要なので手動でのコンフリクト解消は避けられないのですが、
僕が相手にしているのは最終的にMySQLに食わせるデータなのでそこまで順番は重要ではありません。
順番に挿入したところで、MySQLが順番にかえしてくれるとは限りませんからね。
このようなケースではある程度機械的にマージできるのでは？と調べてみました。</p>

<!-- More -->


<h2>merge driver</h2>

<p>いろいろググってみると<a href="http://git-scm.com/docs/gitattributes">gitattributes</a>でファイル毎にマージの細かい挙動を制御できるようです。
通常マージの方法はgitがよしなに選択してくれますが、merge属性に以下の項目を指定することでマージの方法を強制することができます。</p>

<ul>
<li>text

<ul>
<li>テキストファイルとしてマージする。</li>
<li>コンフリクトすると <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>でコンフリクトした場所を教えてくれる。</li>
</ul>
</li>
<li>binary

<ul>
<li>バイナリファイルとしてマージする。</li>
<li>コンフリクトするとマージしようとしたファイルを残しておいてくれる。</li>
</ul>
</li>
<li>union

<ul>
<li>テキストファイルとしてマージする。</li>
<li>textと違ってコンフリクトしてもマーカを付けない。どちらの変更も残すように適当にマージしてくれる。</li>
<li>適当なので <strong>コンフリクト時の行の順番は保証されない</strong></li>
</ul>
</li>
</ul>


<p>text, binaryはコンフリクトしたときによく見る挙動ですね。
unionは初めて知ったので、簡単なレポジトリを作って挙動を確かめてみました。</p>

<p>``` bash
$ # masterブランチ上でmembers.txtにAliceを追加する
$ git init
$ echo Alice > members.txt
$ git add members.txt
$ git commit -m 'add Alice'
[master (root-commit) 8c39714] add Alice
 1 file changed, 1 insertion(+)
  create mode 100644 members.txt
$
$ # add-bobブランチ上でmembers.txtにBobを追加する
$ git checkout -b add-bob
Switched to a new branch 'add-bob'
$ echo 'Bob' >> members.txt
$ git add members.txt
$ git commit -m 'add Bob'
[add-bob 9c406ae] add Bob
 1 file changed, 1 insertion(+)
$
$ # masterブランチ上でmembers.txtにEveを追加する
$ git checkout -
 Switched to branch 'master'
$ echo 'Eve' >> members.txt
$ git add members.txt
$ git commit -m 'add Eve'
[master 9eabd8a] add Eve
 1 file changed, 1 insertion(+)
$ git merge add-bob
 Auto-merging members.txt
 CONFLICT (content): Merge conflict in members.txt
 Automatic merge failed; fix conflicts and then commit the result.
$ cat members.txt
 Alice
 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 Eve
 =======
 Bob</p>

<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>add-bob
```</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>わざとコンフリクトを起こしてみるテストです。
ファイル末尾にEveとBobをそれぞれ別々のブランチで追加したためコンフリクトしてしまっています。</p>

<p>では次にgitattributeを追加して<code>merge=union</code>を指定した場合に挙動を確認してみましょう。</p>

<p><code>bash
$ # merge=union属性を追加
$ echo 'members.txt merge=union' &gt; .gitattributes
$ git add -f .gitattributes
$ git commit -m 'add gitattributes'
[master 61d2cfc] add gitattributes
 1 file changed, 1 insertion(+)
  create mode 100644 .gitattributes
$
$ # もう一度マージしてみる
$ git merge add-bob
Auto-merging members.txt
Merge made by the 'recursive' strategy.
 members.txt | 1 +
  1 file changed, 1 insertion(+)
$ cat members.txt
Alice
Eve
Bob
</code></p>

<p>通常はコンフリクトするケースですが、今度はうまくマージできました。</p>

<h2>merge driverをカスタマイズする</h2>

<p>デフォルトではtext, binary, unionしか用意されていないmerge driverですが、<code>.git/config</code>をいじることで自前のmerge driverを追加することができます。
unionでは行の順番が不定になって不便なので、試しに「必ずソートされており重複がないファイルをマージする」ためのmerge driverを作ってみます。
まずはマージするためのコマンド用意しましょう。</p>

<p>``` bash merge-sorted-set.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$tmpfile" "$O" "$B" | sort | uniq > "$A"
rm "$tmpfile"
```</p>

<p>パスの通った場所にこのファイルを置き、<code>.git/config</code>にこれを呼び出す設定を書けば、gitattributeから使用できるようになります。</p>

<p>``` plain .git/config
[merge "zset"]</p>

<pre><code>    name = merge sorted set
    driver = merge-sorted-set.sh %A %O %B
</code></pre>

<p>```</p>

<ul>
<li><code>%A</code>: 現在のブランチの状態</li>
<li><code>%B</code>: マージしようとしているブランチの状態</li>
<li><code>%O</code>: 共通の祖先の状態</li>
<li><code>%L</code>: コンフリクトマーカの長さ。<a href="https://github.com/git/git/commit/23a64c9e771e3caf19cf2ee9a32c8942ddde4a81">1.7から使えるらしい</a></li>
<li><code>%P</code>: ファイルのパス。<a href="https://github.com/git/git/commit/ef45bb1f8156030446658d5bfb3983ce214a9e16">2.5.0から使えるらしい</a></li>
</ul>


<p>このmerge driverを使ってマージすると、先の例ではAlice, Bob, Eveの順番で並ぶようになります。</p>

<h2>theirs-oursの順番に並べてみる</h2>

<p>僕のケースではtheirs-oursの順番で並んでくれると都合が良いので、こんなスクリプトを書いてみました。</p>

<p>``` bash merge-theirs-ours.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$B" "$O" "$tmpfile" > "$A"
rm "$tmpfile"
```</p>

<p>``` plain .git/config
[merge "theirsours"]</p>

<pre><code>    name = theirs first
    driver = merge-theirs-ours.sh %A %O %B
    recursive = text
</code></pre>

<p>```</p>

<p>あとは勝手にコンフリクト解消して欲しいファイルに対して
.gitattributesで<code>merge=theirsours</code>を指定すれば通常はコンフリクトする場合でもマージしてくれます。</p>

<p>ただ、さすがに全自動だとちょっと怖いので、以下の様にコンフリクトするようであればユーザに確認(<code>exit 1</code>するとコンフリクトした扱いになる)
したほうが無難な気もしますね。</p>

<p>``` bash merge-theirs-ours.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
if git merge-file -p -q "$A" "$O" "$B" > /dev/null; then</p>

<pre><code>git merge-file "$A" "$O" "$B";
</code></pre>

<p>else</p>

<pre><code>tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$B" "$O" "$tmpfile" &gt; "$A"
rm "$tmpfile"
exit 1
</code></pre>

<p>fi
```</p>

<h2>まとめ</h2>

<p>gitattribute便利。
gitattributeを使って<a href="http://shogo82148.github.io/blog/2015/03/24/git-diff-csv/">Git Diffでcsvの差分を見やすく表示する</a>のもどうぞ。</p>

<p>ただmerge driverからはファイルのメタ情報に触れないので、「コミット日時が新しい方を残す」みたいなことができないのが残念です。
<a href="http://stackoverflow.com/questions/7607125/git-merge-conflict-to-always-take-the-newest-file">ブランチ決め打ちにする</a>のはちょっと怖いし、
merge strategyのカスタマイズは大変そう・・・
(一応 <code>git-merge-hogehoge</code> をいうコマンドを用意しておけば <code>git merge --strategy hogehoge</code> と使えるようです。が、<code>git-merge-hogehoge &lt;base&gt;... -- &lt;head&gt; &lt;remote&gt; ...</code> の形式で渡ってくるので、そこから再実装するのはつらい・・・)</p>

<h2>参考</h2>

<ul>
<li><a href="http://git-scm.com/docs/gitattributes">gitattributes</a></li>
<li><a href="http://stackoverflow.com/questions/23140240/git-how-do-i-add-a-custom-merge-strategy">git: How do I add a custom merge strategy?</a></li>
<li><a href="http://stackoverflow.com/questions/7607125/git-merge-conflict-to-always-take-the-newest-file">Git merge conflict to always take the newest file</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各ブランチの最後にコミットした人を知る]]></title>
    <link href="https://shogo82148.github.io/blog/2015/05/21/branch-committer/"/>
    <updated>2015-05-21T00:50:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/05/21/branch-committer</id>
    <content type="html"><![CDATA[<p>ブランチが大量にあるので整理したい、けど大人数で開発しているから誰がどのブランチいじってるか分からない、
ということがあったので、出し方のメモ。</p>

<!-- More -->


<p>githubのbranch一覧も見ればいいじゃん！っていう意見もあると思うんだけど、
「自分のbranch一覧」は見れるんですが「特定のだれかのbranch一覧」が見れない・・・。</p>

<p>git-for-each-refを使うと各ブランチに対していろいろ操作できるようです。
各ブランチの最後にコミットした人一覧を出すには以下のコマンド。</p>

<p><code>bash
git for-each-ref --format='%(authordate:short) %(authorname) %(refname)' --sort=-committerdate refs/remotes/origin/
</code></p>

<p>formatは自由にいじれるのでいろいろ遊べます。
例えば、ブランチをたくさん抱え込んでいる人の一覧を表示する例。</p>

<p><code>bash
git for-each-ref --format="%(authorname)" refs/remotes/origin/ | sort | uniq -c | sort -nr
</code></p>

<h2>参考</h2>

<ul>
<li><a href="http://git-scm.com/docs/git-for-each-ref">git-for-each-ref - Output information on each ref</a></li>
<li><a href="http://d.hatena.ne.jp/syohex/20131225/1387948682">リモートブランチも含め更新日時が新しい順番にソートする</a></li>
<li><a href="http://shuzo-kino.hateblo.jp/entry/2014/07/03/232310">ブランチ一覧を更新時刻つきで表示したい場合、gitのfor-each-refが使える。</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git diffでcsvの差分を見やすく表示する]]></title>
    <link href="https://shogo82148.github.io/blog/2015/03/24/git-diff-csv/"/>
    <updated>2015-03-24T23:08:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/03/24/git-diff-csv</id>
    <content type="html"><![CDATA[<p>ExcelやGoogle Spreadsheetを使って作ったデータをプログラムに取り込むのにcsv形式が便利でよく使っているんですが、
gitで履歴管理をしてもdiffが見づらい・・・。
gitのdiffがかなり自由にカスタマイズできることを知ったので、いろいろいじってみたメモ。</p>

<!-- More -->


<p>例として、以下のようなcsvファイルを編集することを考えます。</p>

<p><code>plain hogehoge.csv
id,name,param_a,param_b,param_c,param_d,param_e
101,hoge,314,159,265,358,979
102,fuga,271,828,182,845,904
</code></p>

<p>一行目は列の見出しになっていて、プログラムからは列番号ではなく<code>param_d</code>の様に指定する、
という作りになってます。
<code>id: 101</code>の行の<code>param_d</code>の数値に変更が入った場合、普通のgitだと以下のようになります。</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -1,3 +1,3 @@
id,name,param_a,param_b,param_c,param_d,param_e
-101,hoge,314,159,265,358,979
+101,hoge,314,159,265,359,979
 102,fuga,271,828,182,845,904
</code></p>

<p>二行目に何か変更があったことはわかりますが、
<code>param_d</code> だとはすぐにはわかりませんね・・・</p>

<h2>YAMLに変換して比較する</h2>

<p>バイナリファイルであっても差分が確認できるよう、
git-diffを実行する前に変換ツールを実行する機能があります。
拡張子がcsvのファイルに対してこの機能が働くように<code>.gitattributes</code>に以下の行を足します。</p>

<p><code>plain .gitattributes
*.csv diff=csv
</code></p>

<p><code>.git/config</code> に変換ツールの設定を追加します。
<code>key: value</code>の形式になっていると見やすそうなので、変換先の形式にはyamlを選びました。</p>

<p>``` plain .git/config
[diff "csv"]</p>

<pre><code>textconv = csv2yaml
</code></pre>

<p>```</p>

<p>ここで指定している<code>csv2yaml</code>は自前で用意する必要があります。
インターネット上をさまよえば同名のツールはいくらでもありそうですが、今回は自分でgoを使って書きました。
<a href="https://gist.github.com/shogo82148/8f19cb771dc6f91308a7">csv2yaml.go</a>をコンパイルしてパスの通る場所においておきましょう。
csv2yamlは自分のよく使うcsvのフォーマットにあわせて以下のようなカスタマイズをしてあります。</p>

<ul>
<li><code>id</code>という名前のキーを必ず最初にする</li>
<li>それ以外のキーはアルファベット順にソートする</li>
</ul>


<p>この状態で<code>git diff</code>を実行すると以下のようになります。</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -3,7 +3,7 @@
   param_a: "314"
   param_b: "159"
   param_c: "265"
-  param_d: "358"
+  param_d: "359"
   param_e: "979"
 - id: "102"
   name: fuga
</code></p>

<p>これなら <code>param_d</code> が変更されたとすぐに分かりますね。</p>

<h2>hunk-headerを設定する</h2>

<p>めでたく<code>param_d</code>が変更されていることがわかるようになったのですが、
今度はどの行が変更されたのかがわからなくなってしまいました。</p>

<p>差分の <code>@@ -3,7 +3,7 @@</code> となっている部分はhunk-headerといって、自由にカスタマイズすることができます。
<code>.git/config</code> に表示したい文字列のパターンを入力しましょう。</p>

<p>``` plain .git/config
[diff "csv"]</p>

<pre><code>textconv = csv2yaml
xfuncname = "^- .*$"
</code></pre>

<p>```</p>

<p>この状態で差分を確認すると「<code>id: 101</code>の<code>param_d</code>をいうパラメータ」が更新されたことが一目瞭然ですね！</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -3,7 +3,7 @@ - id: "101"
   param_a: "314"
   param_b: "159"
   param_c: "265"
-  param_d: "358"
+  param_d: "359"
   param_e: "979"
 - id: "102"
   name: fuga
</code></p>

<p><code>csv2yaml</code>を作るときに「<code>id</code>という名前のキーを必ず最初にする」としたのはこの機能を使うためです。
僕のユースケースでは<code>id</code>がわかれば十分なことがほとんどですが、
場合によってはもっと別の情報の方がいいかもしれませんね。</p>

<p>まだ設定したばっかりなので本当に有用かはよくわかってないですが、しばらくこの設定で試してみようと思います。</p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/YasuOza/items/c472f803dab51b7d4f51">gitのdiffを見やすく表示する</a></li>
<li><a href="http://git-scm.com/docs/gitattributes">gitattributes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git で管理しているリポジトリの各ブランチの中身をそれぞれ個別のディレクトリにエクスポートする(git-archive版)]]></title>
    <link href="https://shogo82148.github.io/blog/2015/03/20/git-pack-branch/"/>
    <updated>2015-03-20T18:38:00+09:00</updated>
    <id>https://shogo82148.github.io/blog/2015/03/20/git-pack-branch</id>
    <content type="html"><![CDATA[<p><a href="http://moznion.hatenadiary.com/entry/2015/03/20/175035">git で管理しているリポジトリの各ブランチの中身をそれぞれ個別のディレクトリにエクスポートする</a> を読んで、
git-archive を使うともう少しシンプルに書けるんじゃないかと思ってやってみた。</p>

<p><code>bash
git branch | sed -e 's/^[\* ]*//g' | xargs -n1 -I% sh -c 'git archive --prefix=%/ % | tar x'
</code></p>

<p>.gitconfig とかでエイリアスを設定しておくといいんじゃないでしょうか</p>

<p>以上</p>
]]></content>
  </entry>
  
</feed>
