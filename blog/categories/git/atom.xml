<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Shogo's Blog]]></title>
  <link href="http://shogo82148.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://shogo82148.github.io/"/>
  <updated>2015-12-20T08:45:36+09:00</updated>
  <id>http://shogo82148.github.io/</id>
  <author>
    <name><![CDATA[Shogo Ichinose]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git-mergeの挙動をカスタマイズする]]></title>
    <link href="http://shogo82148.github.io/blog/2015/12/16/customize-git-merge/"/>
    <updated>2015-12-16T22:24:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/12/16/customize-git-merge</id>
    <content type="html"><![CDATA[<p>最近gitのコンフリクト解消職人みたいになっていてすごくつらいです。
普通のプログラムであれば順番が重要なので手動でのコンフリクト解消は避けられないのですが、
僕が相手にしているのは最終的にMySQLに食わせるデータなのでそこまで順番は重要ではありません。
順番に挿入したところで、MySQLが順番にかえしてくれるとは限りませんからね。
このようなケースではある程度機械的にマージできるのでは？と調べてみました。</p>

<!-- More -->


<h2>merge driver</h2>

<p>いろいろググってみると<a href="http://git-scm.com/docs/gitattributes">gitattributes</a>でファイル毎にマージの細かい挙動を制御できるようです。
通常マージの方法はgitがよしなに選択してくれますが、merge属性に以下の項目を指定することでマージの方法を強制することができます。</p>

<ul>
<li>text

<ul>
<li>テキストファイルとしてマージする。</li>
<li>コンフリクトすると <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>でコンフリクトした場所を教えてくれる。</li>
</ul>
</li>
<li>binary

<ul>
<li>バイナリファイルとしてマージする。</li>
<li>コンフリクトするとマージしようとしたファイルを残しておいてくれる。</li>
</ul>
</li>
<li>union

<ul>
<li>テキストファイルとしてマージする。</li>
<li>textと違ってコンフリクトしてもマーカを付けない。どちらの変更も残すように適当にマージしてくれる。</li>
<li>適当なので <strong>コンフリクト時の行の順番は保証されない</strong></li>
</ul>
</li>
</ul>


<p>text, binaryはコンフリクトしたときによく見る挙動ですね。
unionは初めて知ったので、簡単なレポジトリを作って挙動を確かめてみました。</p>

<p>``` bash
$ # masterブランチ上でmembers.txtにAliceを追加する
$ git init
$ echo Alice > members.txt
$ git add members.txt
$ git commit -m 'add Alice'
[master (root-commit) 8c39714] add Alice
 1 file changed, 1 insertion(+)
  create mode 100644 members.txt
$
$ # add-bobブランチ上でmembers.txtにBobを追加する
$ git checkout -b add-bob
Switched to a new branch 'add-bob'
$ echo 'Bob' >> members.txt
$ git add members.txt
$ git commit -m 'add Bob'
[add-bob 9c406ae] add Bob
 1 file changed, 1 insertion(+)
$
$ # masterブランチ上でmembers.txtにEveを追加する
$ git checkout -
 Switched to branch 'master'
$ echo 'Eve' >> members.txt
$ git add members.txt
$ git commit -m 'add Eve'
[master 9eabd8a] add Eve
 1 file changed, 1 insertion(+)
$ git merge add-bob
 Auto-merging members.txt
 CONFLICT (content): Merge conflict in members.txt
 Automatic merge failed; fix conflicts and then commit the result.
$ cat members.txt
 Alice
 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 Eve
 =======
 Bob</p>

<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>add-bob
```</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>わざとコンフリクトを起こしてみるテストです。
ファイル末尾にEveとBobをそれぞれ別々のブランチで追加したためコンフリクトしてしまっています。</p>

<p>では次にgitattributeを追加して<code>merge=union</code>を指定した場合に挙動を確認してみましょう。</p>

<p><code>bash
$ # merge=union属性を追加
$ echo 'members.txt merge=union' &gt; .gitattributes
$ git add -f .gitattributes
$ git commit -m 'add gitattributes'
[master 61d2cfc] add gitattributes
 1 file changed, 1 insertion(+)
  create mode 100644 .gitattributes
$
$ # もう一度マージしてみる
$ git merge add-bob
Auto-merging members.txt
Merge made by the 'recursive' strategy.
 members.txt | 1 +
  1 file changed, 1 insertion(+)
$ cat members.txt
Alice
Eve
Bob
</code></p>

<p>通常はコンフリクトするケースですが、今度はうまくマージできました。</p>

<h2>merge driverをカスタマイズする</h2>

<p>デフォルトではtext, binary, unionしか用意されていないmerge driverですが、<code>.git/config</code>をいじることで自前のmerge driverを追加することができます。
unionでは行の順番が不定になって不便なので、試しに「必ずソートされており重複がないファイルをマージする」ためのmerge driverを作ってみます。
まずはマージするためのコマンド用意しましょう。</p>

<p>``` bash merge-sorted-set.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$tmpfile" "$O" "$B" | sort | uniq > "$A"
rm "$tmpfile"
```</p>

<p>パスの通った場所にこのファイルを置き、<code>.git/config</code>にこれを呼び出す設定を書けば、gitattributeから使用できるようになります。</p>

<p>``` plain .git/config
[merge "zset"]</p>

<pre><code>    name = merge sorted set
    driver = merge-sorted-set.sh %A %O %B
</code></pre>

<p>```</p>

<ul>
<li><code>%A</code>: 現在のブランチの状態</li>
<li><code>%B</code>: マージしようとしているブランチの状態</li>
<li><code>%O</code>: 共通の祖先の状態</li>
<li><code>%L</code>: コンフリクトマーカの長さ。<a href="https://github.com/git/git/commit/23a64c9e771e3caf19cf2ee9a32c8942ddde4a81">1.7から使えるらしい</a></li>
<li><code>%P</code>: ファイルのパス。<a href="https://github.com/git/git/commit/ef45bb1f8156030446658d5bfb3983ce214a9e16">2.5.0から使えるらしい</a></li>
</ul>


<p>このmerge driverを使ってマージすると、先の例ではAlice, Bob, Eveの順番で並ぶようになります。</p>

<h2>theirs-oursの順番に並べてみる</h2>

<p>僕のケースではtheirs-oursの順番で並んでくれると都合が良いので、こんなスクリプトを書いてみました。</p>

<p>``` bash merge-theirs-ours.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$B" "$O" "$tmpfile" > "$A"
rm "$tmpfile"
```</p>

<p>``` plain .git/config
[merge "theirsours"]</p>

<pre><code>    name = theirs first
    driver = merge-theirs-ours.sh %A %O %B
    recursive = text
</code></pre>

<p>```</p>

<p>あとは勝手にコンフリクト解消して欲しいファイルに対して
.gitattributesで<code>merge=theirsours</code>を指定すれば通常はコンフリクトする場合でもマージしてくれます。</p>

<p>ただ、さすがに全自動だとちょっと怖いので、以下の様にコンフリクトするようであればユーザに確認(<code>exit 1</code>するとコンフリクトした扱いになる)
したほうが無難な気もしますね。</p>

<p>``` bash merge-theirs-ours.sh</p>

<h1>!/bin/bash</h1>

<p>A="$1"
O="$2"
B="$3"
if git merge-file -p -q "$A" "$O" "$B" > /dev/null; then</p>

<pre><code>git merge-file "$A" "$O" "$B";
</code></pre>

<p>else</p>

<pre><code>tmpfile=$(mktemp temp.XXXXXX)
cp "$A" "$tmpfile"
git merge-file -p -q --union "$B" "$O" "$tmpfile" &gt; "$A"
rm "$tmpfile"
exit 1
</code></pre>

<p>fi
```</p>

<h2>まとめ</h2>

<p>gitattribute便利。
gitattributeを使って<a href="http://shogo82148.github.io/blog/2015/03/24/git-diff-csv/">Git Diffでcsvの差分を見やすく表示する</a>のもどうぞ。</p>

<p>ただmerge driverからはファイルのメタ情報に触れないので、「コミット日時が新しい方を残す」みたいなことができないのが残念です。
<a href="http://stackoverflow.com/questions/7607125/git-merge-conflict-to-always-take-the-newest-file">ブランチ決め打ちにする</a>のはちょっと怖いし、
merge strategyのカスタマイズは大変そう・・・
(一応 <code>git-merge-hogehoge</code> をいうコマンドを用意しておけば <code>git merge --strategy hogehoge</code> と使えるようです。が、<code>git-merge-hogehoge &lt;base&gt;... -- &lt;head&gt; &lt;remote&gt; ...</code> の形式で渡ってくるので、そこから再実装するのはつらい・・・)</p>

<h2>参考</h2>

<ul>
<li><a href="http://git-scm.com/docs/gitattributes">gitattributes</a></li>
<li><a href="http://stackoverflow.com/questions/23140240/git-how-do-i-add-a-custom-merge-strategy">git: How do I add a custom merge strategy?</a></li>
<li><a href="http://stackoverflow.com/questions/7607125/git-merge-conflict-to-always-take-the-newest-file">Git merge conflict to always take the newest file</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各ブランチの最後にコミットした人を知る]]></title>
    <link href="http://shogo82148.github.io/blog/2015/05/21/branch-committer/"/>
    <updated>2015-05-21T00:50:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/05/21/branch-committer</id>
    <content type="html"><![CDATA[<p>ブランチが大量にあるので整理したい、けど大人数で開発しているから誰がどのブランチいじってるか分からない、
ということがあったので、出し方のメモ。</p>

<!-- More -->


<p>githubのbranch一覧も見ればいいじゃん！っていう意見もあると思うんだけど、
「自分のbranch一覧」は見れるんですが「特定のだれかのbranch一覧」が見れない・・・。</p>

<p>git-for-each-refを使うと各ブランチに対していろいろ操作できるようです。
各ブランチの最後にコミットした人一覧を出すには以下のコマンド。</p>

<p><code>bash
git for-each-ref --format='%(authordate:short) %(authorname) %(refname)' --sort=-committerdate refs/remotes/origin/
</code></p>

<p>formatは自由にいじれるのでいろいろ遊べます。
例えば、ブランチをたくさん抱え込んでいる人の一覧を表示する例。</p>

<p><code>bash
git for-each-ref --format="%(authorname)" refs/remotes/origin/ | sort | uniq -c | sort -nr
</code></p>

<h2>参考</h2>

<ul>
<li><a href="http://git-scm.com/docs/git-for-each-ref">git-for-each-ref - Output information on each ref</a></li>
<li><a href="http://d.hatena.ne.jp/syohex/20131225/1387948682">リモートブランチも含め更新日時が新しい順番にソートする</a></li>
<li><a href="http://shuzo-kino.hateblo.jp/entry/2014/07/03/232310">ブランチ一覧を更新時刻つきで表示したい場合、gitのfor-each-refが使える。</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git diffでcsvの差分を見やすく表示する]]></title>
    <link href="http://shogo82148.github.io/blog/2015/03/24/git-diff-csv/"/>
    <updated>2015-03-24T23:08:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/03/24/git-diff-csv</id>
    <content type="html"><![CDATA[<p>ExcelやGoogle Spreadsheetを使って作ったデータをプログラムに取り込むのにcsv形式が便利でよく使っているんですが、
gitで履歴管理をしてもdiffが見づらい・・・。
gitのdiffがかなり自由にカスタマイズできることを知ったので、いろいろいじってみたメモ。</p>

<!-- More -->


<p>例として、以下のようなcsvファイルを編集することを考えます。</p>

<p><code>plain hogehoge.csv
id,name,param_a,param_b,param_c,param_d,param_e
101,hoge,314,159,265,358,979
102,fuga,271,828,182,845,904
</code></p>

<p>一行目は列の見出しになっていて、プログラムからは列番号ではなく<code>param_d</code>の様に指定する、
という作りになってます。
<code>id: 101</code>の行の<code>param_d</code>の数値に変更が入った場合、普通のgitだと以下のようになります。</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -1,3 +1,3 @@
id,name,param_a,param_b,param_c,param_d,param_e
-101,hoge,314,159,265,358,979
+101,hoge,314,159,265,359,979
 102,fuga,271,828,182,845,904
</code></p>

<p>二行目に何か変更があったことはわかりますが、
<code>param_d</code> だとはすぐにはわかりませんね・・・</p>

<h2>YAMLに変換して比較する</h2>

<p>バイナリファイルであっても差分が確認できるよう、
git-diffを実行する前に変換ツールを実行する機能があります。
拡張子がcsvのファイルに対してこの機能が働くように<code>.gitattributes</code>に以下の行を足します。</p>

<p><code>plain .gitattributes
*.csv diff=csv
</code></p>

<p><code>.git/config</code> に変換ツールの設定を追加します。
<code>key: value</code>の形式になっていると見やすそうなので、変換先の形式にはyamlを選びました。</p>

<p>``` plain .git/config
[diff "csv"]</p>

<pre><code>textconv = csv2yaml
</code></pre>

<p>```</p>

<p>ここで指定している<code>csv2yaml</code>は自前で用意する必要があります。
インターネット上をさまよえば同名のツールはいくらでもありそうですが、今回は自分でgoを使って書きました。
<a href="https://gist.github.com/shogo82148/8f19cb771dc6f91308a7">csv2yaml.go</a>をコンパイルしてパスの通る場所においておきましょう。
csv2yamlは自分のよく使うcsvのフォーマットにあわせて以下のようなカスタマイズをしてあります。</p>

<ul>
<li><code>id</code>という名前のキーを必ず最初にする</li>
<li>それ以外のキーはアルファベット順にソートする</li>
</ul>


<p>この状態で<code>git diff</code>を実行すると以下のようになります。</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -3,7 +3,7 @@
   param_a: "314"
   param_b: "159"
   param_c: "265"
-  param_d: "358"
+  param_d: "359"
   param_e: "979"
 - id: "102"
   name: fuga
</code></p>

<p>これなら <code>param_d</code> が変更されたとすぐに分かりますね。</p>

<h2>hunk-headerを設定する</h2>

<p>めでたく<code>param_d</code>が変更されていることがわかるようになったのですが、
今度はどの行が変更されたのかがわからなくなってしまいました。</p>

<p>差分の <code>@@ -3,7 +3,7 @@</code> となっている部分はhunk-headerといって、自由にカスタマイズすることができます。
<code>.git/config</code> に表示したい文字列のパターンを入力しましょう。</p>

<p>``` plain .git/config
[diff "csv"]</p>

<pre><code>textconv = csv2yaml
xfuncname = "^- .*$"
</code></pre>

<p>```</p>

<p>この状態で差分を確認すると「<code>id: 101</code>の<code>param_d</code>をいうパラメータ」が更新されたことが一目瞭然ですね！</p>

<p><code>diff git-diff
diff --git a/hogehoge.csv b/hogehoge.csv
index c8dbd17..37f4ff5 100644
--- a/hogehoge.csv
+++ b/hogehoge.csv
@@ -3,7 +3,7 @@ - id: "101"
   param_a: "314"
   param_b: "159"
   param_c: "265"
-  param_d: "358"
+  param_d: "359"
   param_e: "979"
 - id: "102"
   name: fuga
</code></p>

<p><code>csv2yaml</code>を作るときに「<code>id</code>という名前のキーを必ず最初にする」としたのはこの機能を使うためです。
僕のユースケースでは<code>id</code>がわかれば十分なことがほとんどですが、
場合によってはもっと別の情報の方がいいかもしれませんね。</p>

<p>まだ設定したばっかりなので本当に有用かはよくわかってないですが、しばらくこの設定で試してみようと思います。</p>

<h2>参考</h2>

<ul>
<li><a href="http://qiita.com/YasuOza/items/c472f803dab51b7d4f51">gitのdiffを見やすく表示する</a></li>
<li><a href="http://git-scm.com/docs/gitattributes">gitattributes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git で管理しているリポジトリの各ブランチの中身をそれぞれ個別のディレクトリにエクスポートする(git-archive版)]]></title>
    <link href="http://shogo82148.github.io/blog/2015/03/20/git-pack-branch/"/>
    <updated>2015-03-20T18:38:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2015/03/20/git-pack-branch</id>
    <content type="html"><![CDATA[<p><a href="http://moznion.hatenadiary.com/entry/2015/03/20/175035">git で管理しているリポジトリの各ブランチの中身をそれぞれ個別のディレクトリにエクスポートする</a> を読んで、
git-archive を使うともう少しシンプルに書けるんじゃないかと思ってやってみた。</p>

<p><code>bash
git branch | sed -e 's/^[\* ]*//g' | xargs -n1 -I% sh -c 'git archive --prefix=%/ % | tar x'
</code></p>

<p>.gitconfig とかでエイリアスを設定しておくといいんじゃないでしょうか</p>

<p>以上</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gitで作業ディレクトリの変更を破棄したのに差分が出続けて困った話その2]]></title>
    <link href="http://shogo82148.github.io/blog/2014/10/21/git-case-sensitivity/"/>
    <updated>2014-10-21T00:56:00+09:00</updated>
    <id>http://shogo82148.github.io/blog/2014/10/21/git-case-sensitivity</id>
    <content type="html"><![CDATA[<p>先日「<a href="http://shogo82148.github.io/blog/2014/10/04/gitattribute-eol-equals-crlf/">Gitで作業ディレクトリの変更を破棄したのに差分が出続けて困った話</a>」と
いうのを書きましたが、より強力な敵が現われました。
このときは文字コードが原因で <code>git checkout -- &lt;file&gt;</code> しても差分が残り続けるというもので、<code>git add</code> してコミットし直すことで回避出来ました。
しかし、今度の敵は <code>git checkout -- &lt;file&gt;</code> しても <code>git add &lt;file&gt;</code>しても差分が残り続けます。</p>

<p>なんだ・・・このボスを倒したら新たなラスボスが現れた感・・・</p>

<p>acidlemon先生の手助けにより事無きを得たのですが、
ちょっと不明な点もあったので、その点もあわせてメモを残しておきます。</p>

<!-- More -->


<h2>症状</h2>

<p><code>git checkout -- &lt;file&gt;</code> しても、<code>git add &lt;file&gt;</code> しても、<code>git reset --hard HEAD</code> しても、
何をしても差分が出続ける・・・なんだこいつ・・・</p>

<p>``` plain
$ git checkout -- AwesomeFeature
$ git add .
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)</p>

<pre><code>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

modified:   AwesomeFeature/HogeHoge.txt

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>

<p>```</p>

<p>操作は全てMac上で行いました。</p>

<h2>原因</h2>

<p>原因はファイル名の大文字小文字でした。
<code>git ls-files</code> でgitに管理されているファイルの一覧を表示します。</p>

<p><code>
$ git ls-files
AwesomeFeature/HogeHoge.txt
AwesomeFeature/hogehoge.txt
README.txt
</code></p>

<p>大文字小文字だけが違う「HogeHoge.txt」と「hogehoge.txt」が管理されています。</p>

<p>しかしワーキングディレクトリにあるのは「HogeHoge.txt」のみです。</p>

<p><code>
$ ls AwesomeFeature/
HogeHoge.txt
</code></p>

<p>Macのファイルシステムは大文字小文字を区別しないので、
ワーキングディレクトリ上で「HogeHoge.txt」と「hogehoge.txt」を同時に扱えません。
しかしgitは両者を区別するので、よくわからない差分が生まれてしまったわけです。</p>

<p>両方同時に扱えないので、どちらか片方を消して解決します。
<code>git diff</code>で「HogeHoge.txt」と「hogehoge.txt」の差分が見れるのでどっちを残すが選択、
<code>git checkout -- &lt;file&gt;</code>で必要なほうをワーキングディレクトリに反映後、
<code>git rm --cached &lt;file&gt;</code>で不要なファイルをレポジトリから削除です。
「hogehoge.txt」を残す場合は以下のような感じです。全てファイル名を明示してるのがポイントです(症状のところではディレクトリ名指定だった)。</p>

<p><code>
$ # 差分確認
$ # 今はHogeHoge.txtの方がワーキングディレクトリに反映されているので、hogehoge.txtに変更があるように見える
$ git diff
diff --git a/AwesomeFeature/hogehoge.txt b/AwesomeFeature/hogehoge.txt
index 3488202..1150100 100644
--- a/AwesomeFeature/hogehoge.txt
+++ b/AwesomeFeature/hogehoge.txt
@@ -1 +1 @@
-this is hogehoge.txt
+this is HogeHoge.txt
$
$ # hogehoge.txt の内容をワーキングディレクトリに反映
$ git checkout -- AwesomeFeature/hogehoge.txt
$
$ # 今度はHogeHoge.txtに変更があるように見える
$ git diff
diff --git a/AwesomeFeature/HogeHoge.txt b/AwesomeFeature/HogeHoge.txt
index 1150100..3488202 100644
--- a/AwesomeFeature/HogeHoge.txt
+++ b/AwesomeFeature/HogeHoge.txt
@@ -1 +1 @@
-this is HogeHoge.txt
+this is hogehoge.txt
$
$ # HogeHoge.txtの方はgitから削除
$ git rm AwesomeFeature/HogeHoge.txt
rm 'AwesomeFeature/HogeHoge.txt'
$ git commit -m 'rm AwesomeFeature/HogeHoge.txt'
</code></p>

<p>「HogeHoge.txt」があるブランチと「hogehoge.txt」があるブランチをマージするとこうなるようです。
gitの扱いに慣れてない人が触っているレポジトリなのでトラブルが絶えない・・・それにしたってなんでこう見事に地雷を踏抜いて行くんだ・・・(ヽ´ω`)</p>

<h2>まとめ</h2>

<p>大文字小文字を区別しないファイルシステムなんか滅んでしまえ。</p>
]]></content>
  </entry>
  
</feed>
